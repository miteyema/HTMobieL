\section{Productiviteit}
\label{sec:evaluatie-productiviteit}

In deze sectie zal de productiviteit van de vier raamwerken worden onderzocht.
Voor de score van productiviteit wordt naar formule \ref{eq:productiviteit} verwezen.
Tabel~\ref{tabel:evaluatie-productiviteit} bevat een overzicht van de behaalde scores.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Productiviteit,ST,Kendo,jQM,Lungo},
  columns/Productiviteit/.style={column name=\textbf{Productiviteit}, column type={l}},  
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/productiviteit.csv}
\caption{Overzicht van productiviteit voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-productiviteit}
\end{table}

\lungo{} is de afgetekende winnaar,  gevold door \kendo{} en \jqm{}. 
\st{} blijkt het minst productief te zijn.
De productiviteit van \lungo{} stijgt met $71\%$ ten opzichte van \jqm{}.
De productiviteit van \kendo{} stijgt met $44\%$ ten opzichte van \st{}.

De belangrijkste factor waarom \lungo{} en \kendo{} beter scoren is omdat beide raamwerken als tweede werden behandeld.
De POC werd eerst in \jqm{} en \st{} geïmplementeerd.
Er zijn vijf redenen waarom dit de data sterk beïnvloedt.
\begin{enumerate}
\item Betere ervaring met de POC versnelt het overzicht van vereisten die nodig zijn om te implementeren. 
\item Betere ervaring met HTML5-raamwerken in het algemeen. 
Dit weerspiegelt zich vooral tussen \jqm{} en \lungo{}.
Hoewel ze beide op een verschillende \js{}-bibliotheek steunen - respectievelijk jQuery en QuoJS - zijn de gelijkenissen tussen deze twee raamwerken groot.
\item Er kon ook veel code,  zoals van de implementatie in \jqm{},  overgenomen worden bij de implementatie van de POC met \lungo{} en \kendo{}.
\item Er kwamen bij de eerste implementatie problemen met de \term{backend} naar boven.
Deze waren bij de tweede implementatie reeds opgelost.
Door het onnauwkeurig opmeten van de tijd kan er geen schatting worden gemaakt van de tijd die aan de \term{backend} werd besteed.
\item Niet de volledige POC kon met \lungo{} en \st{} worden ontwikkeld.
Hierop zal in sectie \ref{sec:evaluatie-gebruik} verder worden ingegaan.
\end{enumerate}
De werkuren van de loginapplicatie bevestigen voorgaande resultaten niet.
Ze zijn dan ook niet onderheven aan de zonet vijf opgenoemde redenen om wille van:
\begin{enumerate}
\item Bij elke implementatie werd met dezelfde achtergrondkennis gestart.  
De implementatie van de loginapplicatie is triviaal en eenduidig.
Er geldt dus voor alle raamwerken dat de ervaring met de applicatie reeds hoog was.
\item Ook werd eerst de implementatie van de POC gemaakt voordat aan de loginapplicatie werd begonnen.
Hierdoor was de algemene ervaring met HTML5-raamwerken gelijkgesteld.
\item Er werd geen code gekopieerd. 
\item Er waren geen problemen met de \term{backend}.
\item Ten slotte werd alle functionaliteit van de loginapplicatie met alle vier raamwerken gebouwd.
\end{enumerate}
Om al deze redenen werd beslist de score voor productiviteit aan te passen door enkel de uren van de login applicatie ($t_{r,login}$) te beschouwen.
De verbeterde formule voor productiviteit is dan
\begin{equation}
  \text{Productiviteit}'_r = t_{r,login}
  \label{eq:productiviteit-enhanced}
\end{equation}
voor een raamwerk $r$.

Uit deze data blijkt \jqm{} productiever dan \lungo{}. 
De volgorde van \kendo{} en \st{} blijft echter wel behouden.
De relatieve verschillen tussen \jqm{} en \lungo{} en tussen \st{} en \kendo{} zijn ook verkleind.  
Respectievelijk een stijging van $11.7\%$ en een daling met $31.8\%$.
Toch zijn er twee trends vast te stellen: het type raamwerk (\js-gedreven of opmaakgedreven) en het al dan niet afdwingen van een architectuur bepalen de productiviteit.
Raamwerken zonder architectuur (\jqm{} en \lungo{}) zijn productiever dan raamwerken die een architectuur afdwingen (\st{} en \kendo{}).
Indien het raamwerk een architectuur afdwingt, dan is een puur \js{}-gedreven raamwerk (in dit geval \st{}) minder productief dan een raamwerk die zowel \js{}- als opmaakgedreven is.

\subsection{xxx}
In wat volgt zullen andere factoren worden besproken die de verschillen in productiviteit kunnen verklaren.

\paragraph{Tools}
Enkel bij de ontwikkeling met \st{} kon beroep worden gedaan op een grafische tool om het ontwikkelingsproces te vergemakkelijken:  Sencha Architect~\cite{Sencha2012a}.
Dit is een desktopapplicatie die het ontwikkelingsproces vergemakkelijkt met een GGI en \term{drag-and-drop} commando's.  
Bij de ontwikkeling van de POC werd Sencha Architect versie 2.1 gebruikt voor een tijdsduur van $21$ dagen.
Het grootste voordeel van Sencha Architect kon bij de ontwikkeling van \code{Views} worden gevonden.
De \code{Views} kunnen specifiek voor mobiele schermen worden geoptimaliseerd, dit zowel voor staande als liggende apparaten.
Na $21$ dagen werd overgeschakeld op PhpStorm~\cite{JetBrains2012} als Integrated Development Environment~(IDE).
Dezelfde IDE werd ook gebruikt bij de ontwikkeling met andere raamwerken en biedt ondersteuning voor zowel Windows, Mac als Linux.
Een voordeel bij het gebruik van deze IDE is onder andere de automatische code-aanvulling.
Daarnaast toont de IDE hints voor het optimaliseren van \js{}-code die specifiek gebruikt maakt van de jQuery bibliotheek.

Als laatste werd Yeoman~\cite{Yeoman2013} gebruikt bij \kendo{}, \jqm{}, en \lungo{} om applicaties bouwen.
Enkel \lungo{} kon gebruik maken van Twitter Bower~\cite{Twitter2013} om de bestanden van \gh{}-\term{repository} toe te voegen.
Bij \st{} werd Sencha Cmd gebruikt om de applicatie te bouwen.

\paragraph{Boilerplate code}
Het initialiseren van een nieuwe applicatie van het raamwerk beïnvloed ook sterk de productiviteit.
\st{} biedt hiervoor terug een tool,  Sencha Cmd~\cite{Sencha2012}.
Deze tool kan de initiële applicaties opzetten,  bestanden toevoegen en de applicatie bouwen en uitrollen.
Na de geautomatiseerde initialisatie van een project zijn de gemaakte folders en bestanden echter niet geheel duidelijk.
Een nieuwe \code{Controller},  \code{Store},  \code{Model} of \code{View} genereren kan manueel of automatisch met Sencha Cmd.
Bij de manuele aanpak moet het nieuwe \js-bestand in de juiste folder worden ondergebracht.
\st{} legt een strenge structuur van folders op die ongewijzigd moet blijven opdat de applicatie zou werken wat in het begin tot verwarring leidt.

\jqm{} en \kendo{} beschrijven \term{boilerplate}code in hun documentatie~\cite{JQuery2012b,Telerikd}.
Ook is bij de documentatie van beide raamwerken een expliciete sectie aanwezig die de programmeur helpt om een applicatie op te zetten.
Bij \lungo{} is dit niet het geval.  
Om een \lungo{} applicatie op te zetten, moest naar de broncode van de voorbeelden op de documentatie gekeken worden.

\paragraph{Documentatie}
Ook de kwaliteit en kwantiteit van de documentatie kunnen de scores van de productiviteit verklaren.
De \st{} documentatie is het grootst in vergelijking met de andere raamwerken.
De grootte van de documentatie maakt het moeilijk om zelf gericht naar onduidelijkheden te zoeken.
De zoekfunctie met auto-aanvulling is noodzakelijk om de juiste documentatie terug te vinden.
De documentatie van \kendo{} is overzichtelijker en volledig.
De combinatie van de secties API en Getting Started boden de voornaamste hulp.
Ook worden alle kenmerken die het raamwerk aanbiedt met demo's en codevoorbeelden getoond.
De zoekfunctie van de documentatie is niet optimaal en hierdoor werd deze maar weinig gebruikt.
De documentatie van \jqm{}~1.2 bevat geen zoekfunctie en codevoorbeelden.
Hierdoor moet naar de broncode worden gekeken om de code van een kenmerk te begrijpen.
Een voordeel van de \jqm{} documentatie is dat de documentatie zelf met \jqm{} is gebouwd.
Een belangrijke opmerking is dat de \jqm{}~1.3 wel een zoekfunctie en codevoorbeelden in zijn documentatie heeft opgenomen.
De documentatie van \lungo{} is zeer beknopt en daarenboven bestaat deze van \quo{} uit slechts één pagina.
Alle kenmerken van \lungo{} worden met codevoorbeelden verduidelijkt.
Sommige voorbeelden zijn echter incorrect.

\paragraph{Debugging}
Het zoeken naar bugs in de code verliep bij elk raamwerk gelijkaardig.
De applicatie werd lokaal uitgerold en in de Web Inspector van Chrome gedebugd.
Debuggen op de apparaten kon door deze te connecteren via USB met de computer.
Enkel Android toestellen met een Chrome browser kunnen worden gedebugd met de Web Inspector van het apparaat.
Debuggen op iOS toestellen kan op een Mac met dezelfde Web Inspector maar in de Safari browser.
Dit werkt echter niet op \ipadi{}.

\paragraph{Literatuur}
Zowel \jqm{} als \st{} werden vaak in de literatuur aangehaald.
Op Safari Books Online kunnen 13 boeken teruggevonden worden die volledig op \jqm{} zijn toegespitst.
Het boek van Dutson in de Sam Teach Yourself serie werd gebruikt om met \jqm{} vertrouwd te geraken~\cite{PhilDutson2012}.
Ook Pro jQuery Mobile van Broulik~\cite{Broulik2012} werd gelezen maar dit is nagenoeg een kopie van de documentatie en bevat bijgevolg niet veel extra informatie.
Vier boeken over \st{} kunnen op Safari Books Online worden teruggevonden.
Het boek van Clark et al. werd gebruikt~\cite{JohnEClark2012}.
\kendo{} komt slechts in een boek voor~\cite{Bhandari2013},  \lungo{} helemaal niet.
Het boek rond \kendo{} is slechts een proefdruk en wordt pas in augustus 2013 officieel gepubliceerd.
Dit werk werd niet gebruikt.


\paragraph{Fora}
Wanneer de programmeur met problemen van het raamwerk werd geconfronteerd, kan op het web naar oplossingen gezocht worden.
In sectie \ref{sec:evaluatie-populariteit} werden reeds het aantal vragen van het raamwerk op \so{} bekeken.
Hoe groter dit aantal,  hoe groter de kans dat een probleem reeds is aangehaald.
Bij \lungo{} is dit aantal minimaal en was de programmeur vaak aangewezen om zelf oplossingen te zoeken.
%TODO referentie naar fora?
Er werden twee vragen gesteld op twee specifieke fora, maar hier is tot op heden nooit antwoord op gekomen.
Voor \st{} en \kendo{} geldt dat ook het forum voor professionele ondersteuning hulpvaardig was.
Het plaatsen van vragen bij \st{} is onmogelijk zonder betaalde ondersteuning,  \kendo{} laat het stellen van maximaal vijf vragen toe zonder de aankoop van een licentie.
De meest voorkomende problemen zijn op de fora al aangehaald en gedetailleerd besproken.


\paragraph{Lijnen code}
Als laatste wordt in tabel \ref{tabel:evaluatie-gebruik-loc} het aantal lijnen effectief geschreven code getoond dat nodig is om de POC en login applicatie te maken.
Het type van het raamwerk (\js- of opmaakgedreven) komt sterk in de tabel naar boven.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
	column type=l,
	every head row/.style={
		before row={%
			\toprule
			\textbf{Code}
			& \multicolumn{2}{c}{\textbf{\sta}}
			& \multicolumn{2}{c}{\textbf{\kendoa}} 
			& \multicolumn{2}{c}{\textbf{\jqma}}
			& \multicolumn{2}{c}{\textbf{\lungoa}} \\
			\cmidrule(r){2-3}
			\cmidrule(r){4-5}
			\cmidrule(r){6-7}
			\cmidrule(r){8-9}
		},
		after row=\midrule,
		},
  	every last row/.style={
  		before row=\toprule,
 		after row=\bottomrule},
	columns={Geschreven,ST(poc),ST(login),Kendo(poc),Kendo(login),jQM(poc),jQM(login),Lungo(poc),Lungo(login)},
	begin table=\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}} lcccccccc},
	end table=\end{tabular*},
	header=true,
	skip coltypes=true,
	columns/Geschreven/.style ={column name=},
	columns/ST(poc)/.style ={column name=POC},
	columns/ST(login)/.style={column name=Login},
	columns/Kendo(poc)/.style ={column name=POC},
	columns/Kendo(login)/.style={column name=Login},
	columns/jQM(poc)/.style ={column name=POC},
	columns/jQM(login)/.style={column name=Login},
	columns/Lungo(poc)/.style ={column name=POC},
	columns/Lungo(login)/.style={column name=Login},
	col sep=comma,
	string type,
]{tabellen/gebruik/loc.csv}
\caption{Overzicht van het aantal lijnen effectief geschreven code.}
\label{tabel:evaluatie-gebruik-loc}
\end{table}