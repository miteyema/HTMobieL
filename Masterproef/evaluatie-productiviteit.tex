\section{Productiviteit}
\label{sec:evaluatie-productiviteit}

In deze sectie zal de productiviteit van de vier raamwerken worden onderzocht.
%Voor de score van productiviteit wordt naar formule \ref{eq:productiviteit} verwezen.
%TODO Sander: tabel met enkel uren van loginapplicatie
Tabel~\ref{tabel:evaluatie-productiviteit} bevat een overzicht van de behaalde scores.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Productiviteit,ST,Kendo,jQM,Lungo},
  columns/Productiviteit/.style={column name=\textbf{Productiviteit}, column type={l}},  
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/productiviteit.csv}
\caption{Overzicht van productiviteit voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-productiviteit}
\end{table}

% \lungo{} is de afgetekende winnaar,  gevold door \kendo{} en \jqm{}. 
% \st{} blijkt het minst productief te zijn.
% De productiviteit van \lungo{} stijgt met $71\%$ ten opzichte van \jqm{}.
% De productiviteit van \kendo{} stijgt met $44\%$ ten opzichte van \st{}.

% De belangrijkste factor waarom \lungo{} en \kendo{} beter scoren is omdat beide raamwerken als tweede werden behandeld.
% De POC werd eerst in \jqm{} en \st{} geïmplementeerd.


De uren voor de implementatie van de loginapplicatie tonen dat \jqm{} productiever is dan \lungo{}. 
Hierna volgt \kendo{} en \st{}.
De productiviteit van \lungo{} stijgt met $11.7\%$ ten opzichte van \jqm{}.
De productiviteit van \kendo{} stijgt met $31.8\%$ ten opzichte van \st{}.
%TODO: ofwel die stijgingen in % ergens in een tabel zetten?
% De relatieve verschillen tussen \jqm{} en \lungo{} en tussen \st{} en \kendo{} zijn ook verkleind.  
% Respectievelijk een stijging van $11.7\%$ en een daling met $31.8\%$.
Hieruit volgen twee conclusies: het type raamwerk (\js-gedreven of opmaakgedreven) en het al dan niet afdwingen van een architectuur bepalen de productiviteit.
Raamwerken zonder architectuur (\jqm{} en \lungo{}) zijn productiever dan raamwerken die een architectuur afdwingen (\st{} en \kendo{}).
Indien het raamwerk een architectuur afdwingt, dan is een puur \js{}-gedreven raamwerk (in dit geval \st{}) minder productief dan een raamwerk die zowel \js{}- als opmaakgedreven is.

\subsection{Lijnen code}
In tabel \ref{tabel:evaluatie-gebruik-loc} staan het aantal lijnen effectief geschreven code getoond dat nodig is om de POC en loginapplicatie te maken.
%TODO bij de loginapplicatie komen de LOC overeen met productiviteit
% bij POC tussen kui en jqm is som van html en js lager bij kui. Veel minder schrijven maar minder productief dan jqm.

Het type van het raamwerk (\js- of opmaakgedreven) komt sterk in de tabel naar boven.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
	column type=l,
	every head row/.style={
		before row={%
			\toprule
			\textbf{Code}
			& \multicolumn{2}{c}{\textbf{\sta}}
			& \multicolumn{2}{c}{\textbf{\kendoa}} 
			& \multicolumn{2}{c}{\textbf{\jqma}}
			& \multicolumn{2}{c}{\textbf{\lungoa}} \\
			\cmidrule(r){2-3}
			\cmidrule(r){4-5}
			\cmidrule(r){6-7}
			\cmidrule(r){8-9}
		},
		after row=\midrule,
		},
  	every last row/.style={
  		before row=\toprule,
 		after row=\bottomrule},
	columns={Geschreven,ST(poc),ST(login),Kendo(poc),Kendo(login),jQM(poc),jQM(login),Lungo(poc),Lungo(login)},
	begin table=\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}} lcccccccc},
	end table=\end{tabular*},
	header=true,
	skip coltypes=true,
	columns/Geschreven/.style ={column name=},
	columns/ST(poc)/.style ={column name=POC},
	columns/ST(login)/.style={column name=Login},
	columns/Kendo(poc)/.style ={column name=POC},
	columns/Kendo(login)/.style={column name=Login},
	columns/jQM(poc)/.style ={column name=POC},
	columns/jQM(login)/.style={column name=Login},
	columns/Lungo(poc)/.style ={column name=POC},
	columns/Lungo(login)/.style={column name=Login},
	col sep=comma,
	string type,
]{tabellen/gebruik/loc.csv}
\caption{Overzicht van het aantal lijnen effectief geschreven code.}
\label{tabel:evaluatie-gebruik-loc}
\end{table}

\subsection{Duiding}
In wat volgt zullen andere factoren worden besproken die de verschillen in productiviteit verklaren.
Ze kunnen als factoren worden gezien die de leercurve bepalen.

\paragraph{Tools}
Enkel bij de ontwikkeling met \st{} kon beroep worden gedaan op een grafische tool om het ontwikkelingsproces te vergemakkelijken:  Sencha Architect~\cite{Sencha2012a}.
Dit is een desktopapplicatie die het ontwikkelingsproces vergemakkelijkt met een GGI en \term{drag-and-drop} commando's.  
Bij de ontwikkeling van de POC werd Sencha Architect versie 2.1 gebruikt voor een tijdsduur van $21$ dagen.
Het grootste voordeel van Sencha Architect kon bij de ontwikkeling van \code{Views} worden gevonden.
De \code{Views} kunnen specifiek voor mobiele schermen worden geoptimaliseerd, dit zowel voor staande als liggende apparaten.
Na enkele dagen werd er overgeschakeld op PhpStorm~\cite{JetBrains2012} als Integrated Development Environment~(IDE).
De voornaamste reden hiervoor was de beperkte bruikbaarheid van Sencha Architect voor de ontwikkeling van meer geavanceerde functionaliteit.
PhpStorm werd ook gebruikt bij de ontwikkeling met andere raamwerken en biedt ondersteuning voor zowel Windows, Mac als Linux.
Een voordeel bij het gebruik van deze IDE is onder andere de automatische code-aanvulling.
Daarnaast toont de IDE hints voor het optimaliseren van \js{}-code die specifiek gebruikt maakt van de jQuery bibliotheek.

Als laatste werd Yeoman~\cite{Yeoman2013} gebruikt bij \kendo{}, \jqm{} en \lungo{} om applicaties te bouwen.
\kendo{} en \lungo{} konden gebruik maken van Twitter Bower~\cite{Twitter2013} om de bestanden van \gh{}-\term{repository} toe te voegen.
Bij \st{} werd Sencha Cmd gebruikt om de applicatie te bouwen.

\paragraph{Boilerplate code}
%Het initialiseren van een nieuwe applicatie van het raamwerk beïnvloedt ook sterk de productiviteit.
\st{} biedt een tool voor het initialiseren van een nieuwe applicatie,  Sencha Cmd~\cite{Sencha2012}.
Deze tool kan de initiële applicaties opzetten,  bestanden toevoegen en de applicatie bouwen en uitrollen.
Na de geautomatiseerde initialisatie van een project zijn de gemaakte folders en bestanden echter niet geheel duidelijk.
Een nieuwe \code{Controller},  \code{Store},  \code{Model} of \code{View} genereren kan manueel of automatisch met Sencha Cmd.
Bij de manuele aanpak moet het nieuwe \js-bestand in de juiste folder worden ondergebracht.
\st{} legt een strenge structuur van folders op die ongewijzigd moet blijven opdat de applicatie zou werken.
Dit leidde bij aanvang van de implementatie tot veel verwarring.

\jqm{} en \kendo{} beschrijven \term{boilerplate} code in hun documentatie~\cite{JQuery2012b,Telerikd}.
Ook is bij de documentatie van beide raamwerken een expliciete sectie aanwezig die de programmeur helpt om een applicatie op te zetten.
Bij \lungo{} is dit niet het geval.  
Om een \lungo{} applicatie op te zetten, moest naar de broncode van de voorbeelden op de documentatie gekeken worden.

\paragraph{Documentatie}
%Ook de kwaliteit en kwantiteit van de documentatie kunnen de scores van de productiviteit verklaren.
De \st{} documentatie is het grootst in vergelijking met de andere raamwerken.
De grootte van de documentatie maakt het moeilijk om zelf gericht naar onduidelijkheden te zoeken.
De zoekfunctie met auto-aanvulling is noodzakelijk om de juiste documentatie terug te vinden.
De documentatie van \kendo{} is overzichtelijker en volledig.
De combinatie van de secties API en Getting Started boden de voornaamste hulp.
Ook worden alle kenmerken die het raamwerk aanbiedt met demo's en codevoorbeelden getoond.
De zoekfunctie van de documentatie is niet optimaal en hierdoor werd deze maar weinig gebruikt.
De documentatie van \jqm{}~1.2 bevat geen zoekfunctie en codevoorbeelden.
Hierdoor moet naar de broncode worden gekeken om de code van een kenmerk te begrijpen.
Een voordeel van de \jqm{} documentatie is dat deze zelf met \jqm{} is gebouwd.
Een belangrijke opmerking is dat de \jqm{}~1.3 wel een zoekfunctie en codevoorbeelden in zijn documentatie heeft opgenomen.
De documentatie van \lungo{} is zeer beknopt en daarenboven bestaat deze van \quo{} uit slechts één pagina.
Alle kenmerken van \lungo{} worden met codevoorbeelden verduidelijkt.
Sommige voorbeelden zijn echter incorrect.

\paragraph{Debugging}
%Het zoeken naar bugs in de code verliep bij elk raamwerk gelijkaardig.
De applicatie werd lokaal uitgerold en in de Web Inspector van Chrome gedebugd.
%TODO USB voluit en in lijst?
Debuggen op de apparaten kon door deze te connecteren met de computer via USB.
Enkel Android toestellen met een Chrome browser kunnen worden gedebugd met de Web Inspector van het apparaat.
Debuggen op iOS toestellen kan op een Mac met dezelfde Web Inspector maar in de Safari browser.
Dit werkt echter niet op \ipadi{}.

\paragraph{Literatuur}
Zowel \jqm{} als \st{} werden vaak in de literatuur aangehaald.
%TODO referentie safaribooks?  Ik wil zeggen dat het boek volledig over het raamwerk gaat en niet enkel voorkomt in het boek. Is dat dan zo voldoende?
Op Safari Books Online kunnen 13 boeken teruggevonden worden die volledig op \jqm{} zijn toegespitst.
Het boek van Dutson in de Sam Teach Yourself serie werd gebruikt om met \jqm{} vertrouwd te geraken~\cite{PhilDutson2012}.
Ook Pro jQuery Mobile van Broulik~\cite{Broulik2012} werd gelezen maar dit is nagenoeg een kopie van de documentatie en bevat bijgevolg niet veel extra informatie.
Vier boeken over \st{} kunnen op Safari Books Online worden teruggevonden.
Het boek van Clark et al. werd gebruikt~\cite{JohnEClark2012}.
\kendo{} komt slechts in één boek voor~\cite{Bhandari2013},  \lungo{} helemaal niet.
Het boek rond \kendo{} is slechts een proefdruk en wordt pas in augustus 2013 officieel gepubliceerd.
Dit werk werd niet gebruikt.


\paragraph{Fora}
Wanneer de programmeur met problemen van het raamwerk werd geconfronteerd, kan op het web naar oplossingen gezocht worden.
In sectie \ref{sec:evaluatie-populariteit} werden reeds het aantal vragen van het raamwerk op \so{} bekeken.
Hoe groter dit aantal,  hoe groter de kans dat een probleem reeds is aangehaald.
Bij \lungo{} is dit aantal minimaal en was de programmeur vaak aangewezen om zelf oplossingen te zoeken.
Er werden twee vragen gesteld op Google Groups en LungoJS Community, maar hier is tot op moment van schrijven nooit antwoord op gekomen.
Voor \st{} en \kendo{} geldt dat ook het forum voor professionele ondersteuning hulpvaardig was.
Het plaatsen van vragen bij \st{} is onmogelijk zonder betaalde ondersteuning,  \kendo{} laat het stellen van maximaal vijf vragen toe zonder de aankoop van een licentie.
De meest voorkomende problemen zijn op de fora al aangehaald en gedetailleerd besproken.
De antwoorden kunnen zonder licentie bekeken worden.