\section{Gebruik}
\label{sec:evaluatie-gebruik}
Het gebruik van de vier raamwerken wordt samengevat voor de $13$ uitdagingen in tabel \ref{tabel:evaluatie-gebruik}.
Voor de score van gebruik wordt naar formule \ref{eq:gebruik} verwezen waarbij de scores van alle uitdagingen worden opgeteld.
Voor \st{} werd gebruik gemaakt van versie~2.1.1, voor \kendo{} van versie~2013~Q1, voor \jqm{} van versie~1.3.0 en voor \lungo{} van versie~2.1.
Per sectie zal iedere uitdaging per raamwerk worden besproken.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik.csv}
\caption{Overzicht van gebruik.}
\label{tabel:evaluatie-gebruik}
\end{table}

Het raamwerk dat het beste scoort bij gebruik is \kendo{}, kort gevolgd door \st{}.
Dit kan grotendeels door de aanwezigheid van een ontwerppatroon, respectievelijk MVVM en MVC, worden verklaard.
Het ontbreken van een ontwerppatroon bij de andere twee raamwerken resulteert in een omslachtige aanpak, waardoor punten worden verloren.
Opmerkelijk is de perfecte score van \kendo{} voor formulieren en de mindere ondersteuning voor offline in vergelijking met \st{}.
\jqm{} behaalt de helft met wat overschot.
Op het vlak om data automatisch in te laden in velden of lijsten, scoort het nul door het ontbreken van een ontwerppatroon. 
Als laatste komt \lungo{} dat een onvoldoende behaalt.
Dezelfde pijnpunten van \jqm{} zijn ook geldig voor \lungo{}.
Daarenboven is er bij \lungo{} een totaal gebrek aan formuliervalidatie en aan de meer geavanceerdere formulierelementen.
Voor deze laatste moet er een plug-in worden gebruikt of zal de functionaliteit zelf moeten worden geïmplementeerd. 

Een algemene trend bij ieder raamwerk is de volle ondersteuning van AJAX-verzoeken, behalve dan bij één geval voor \lungo{}.
Ook laadschermen en dialoogvensters zijn bij ieder raamwerk volledig aanwezig.


%%%%%%%%%%%%%

\subsection{\uit{anatomie}}
\label{sec:evaluatie-gebruik-anatomie}

In tabel \ref{tabel:evaluatie-gebruik-anatomie} worden de resultaten getoond van de drie deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/anatomie.csv}
\caption{Gebruik van \uit{anatomie}.}
\label{tabel:evaluatie-gebruik-anatomie}
\end{table}

\paragraph{\st}
Het opbouwen van een \code{View} in \st{} gebeurt hiërarchisch met containers.
Een component die aan een container kan worden toegevoegd is de \code{Toolbar}.
Een \code{Toolbar} kan zowel bovenaan als onderaan een container worden vastgezet.
Dit kan dan dienst doen als kop- en voettekst.
Een cascade van kopteksten is door de hiërarchische opbouw van containers mogelijk en laat zo onderkopteksten toe.
Een \code{Toolbar} kan voorzien worden van een titel door de \code{title}-eigenschap in te vullen.
Knoppen aan een \code{Toolbar} toevoegen kan door een lijst van \code{buttons} aan de \code{items}-eigenschap toe te voegen.
Het toevoegen van een tabbar verloopt analoog.
De \code{items}-eigenschap bevat dan een lijst van \code{Views} met een titel waarbij de \code{View} zichtbaar wordt als op de titel wordt gedrukt.
Knoppen van kleur veranderen kan door de \code{style}-eigenschap van een knop te zetten.

\paragraph{\kendo}
Het skelet van een \code{View} kan binnen een HTML-tag worden geschreven.
Kop- en/of voetteksten toevoegen kan door in het skelet de bijhorende HTML-tags te gebruiken.
\code{Header}-tags kunnen niet genest worden, dus zijn onderkopteksten niet mogelijk.
Een tabbar moet met een \code{Buttongroup} worden gemaakt,  dit is een lijst van knoppen.
Na deze lijst moeten de bijhorende \code{Views} worden geschreven.
De \code{Buttongroup} voorziet een gebeurtenis bij het selecteren van een knop.
Hier moet de overeenkomstige \code{View} zichtbaar worden gemaakt met behulp van CSS-manipulaties.
De kleur van een knop wijzigen kan door een nieuwe CSS-klasse aan de knop toe te kennen.

\paragraph{\jqm}
Het toevoegen van een kop- en voettekst gebeurt door gebruik te maken van HTML5-tags. 
Wel moest dezelfde code op ieder scherm worden herhaald. 
Dit kan worden vermeden door gebruik te maken van eenzelfde data-attribuut. 
Daarnaast werd de voettekst gefixeerd aan de onderkant van het scherm en de bijhorende logo's links en rechts uitgelijnd. 
Voor dit laatste werd gebruik gemaakt van de zogenaamde \term{grid} die \jqm{}~1.3 zelf aanbiedt. 
De voettekst wordt niet getoond op een smartphone, wat wordt bekomen door gebruik te maken van de CSS3 Media Queries.

%Om de onderkoptekst te implementeren, werd eerst geprobeerd om bovenaan een lijst met enkel één lijstdeler te plaatsen.
De onderkoptekst werd eerst geïmplementeerd met een lijst met enkel één lijstdeler.
Dit schoof echter de inhoud van de pagina niet mee naar onder. 
De uiteindelijke oplossing kwam vanuit de documentatie om dit met behulp van de CSS-klasse \code{ui-bar} te implementeren~\cite{JQuery2013b}. 
Deze extra titel wordt ook gebruikt om naar het menu voor de smartphone te gaan (zie \ref{sec:evaluatie-gebruik-toestel}).

Standaard is er een tabbalk aanwezig in \jqm, maar de POC impliceerde een tabbalk die niet de volledige breedte innam.
Daarom werd gekozen voor een formulierveld met twee opties.
ThemeRoller~\cite{JQuery2012c} werd gebruikt om de knoppen groen te maken.
Door daarna de knop te annoteren met de bekomen CSS-klasse, wordt het betreffende thema geactiveerd. 
Om de knop blauw te maken was er geen nood aan een aanpassing.
Blauw is al één van de standaard thema's en kon dus direct worden gebruikt.

\paragraph{\lungo}
Het tonen van kop- en voettekst gebeurt door de verschillende schermen van de applicatie te omvatten met HTML5-tags.
Dit is in tegenstelling tot \jqm{} waarbij wordt gebruik gemaakt van data-attributen.
In de voettekst kunnen door CSS-regels de twee logo's links en rechts uitgelijnd worden.
De onderkoptekst werd met een omweg bekomen door een lijst te maken met slechts één lijstitem.
Het maken van een tabbar is standaard aanwezig in \lungo{}.
De tabbar wordt getoond over de volledige breedte en komt onmiddellijk onder de koptekst en dus boven de onderkoptekst.
Dit in tegenstelling tot het gevraagde in de POC waar de tabbar onder de onderkoptekst diende te komen.
Het veranderen van de kleur van knoppen gebeurt in CSS waarbij de achtergrondkleur van de knop kan worden aangepast.

%%%%%%%%%%%%%

\subsection{\uit{toestel}}
\label{sec:evaluatie-gebruik-toestel}

In tabel \ref{tabel:evaluatie-gebruik-toestel} worden de resultaten getoond van de drie deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/toestel.csv}
\caption{Gebruik van \uit{toestel}.}
\label{tabel:evaluatie-gebruik-toestel}
\end{table}

\paragraph{\st}
\st{} ondersteunt het herkennen van de context waarin de applicatie wordt gebruikt.
Het kan zowel besturingssysteem, browser als ondersteunde (HTML5-)kenmerken opvragen en herkennen.
De creatie van de tablet lay-out steunt op de \code{HBox}-lay-out die componenten horizontaal naast elkaar plaatst.
%De \code{flex} eigenschap van deze lay-out definieert de ratio van de groottes van beide componenten.
De creatie van de smartphone lay-out maakt het menu in de linkse component van de lay-out onzichtbaar.
%Om naar het menu terug te keren moet een extra knop in de koptekst worden toegevoegd die naar het menu navigeert.
\st{} ondersteunt geen klikbare kopteksten om naar het smartphonemenu terug te keren.
Hiervoor werd een extra knop in de koptekst toegevoegd.

\paragraph{\kendo}
Ook \kendo{} kan de context waarin de applicatie wordt uitgevoerd, opvragen.
%Een onderscheid maken tussen smartphone of tablet kan met \code{Kendo.support.tablet}.
% mss kort woordje bij splitview zoals je deed bij ST voor Hbox
De lay-out van de tablet is mogelijk met een \code{Splitview}.
Deze \code{View} is specifiek voor tablets en kan het scherm horizontaal of verticaal opdelen.
De tablet lay-out wordt standaard gebruikt.
Om de smartphone lay-out te verkrijgen moet de \code{Splitview} door standaard \code{Views} worden vervangen met DOM-manipulaties.

\paragraph{\jqm}
Het raamwerk biedt zelf geen functies aan om te herkennen of het toestel een smartphone of tablet is.
In \jqm{} is er ook geen functionaliteit aanwezig om een menu in te schakelen op tablets.
Drie plug-ins~\cite{Rahman2013,Yared2013,Franck2012} werden gevonden via een blogpost~\cite{Deering2012} en getest.
Elk hadden ze hun tekorten. 
Zo was de eerste destructief ten opzichte van het raamwerk.
Dit betekent dat de bestanden van het raamwerk zelf werden aangepast, wat het moeilijker maakt als er moet worden geüpdatet naar een nieuwe versie. 
De tweede plug-in werkte enkel tot versie 1.0.1.
De laatste plug-in paste zich niet aan aan de veranderende afmetingen van de browser. 
Uiteindelijk werden CSS3 Media Queries gebruikt~\cite{Hadlock2012,JQuery2013e}. 
Bij CSS3 Media Queries moet zelf een breekpunt (uitgedrukt in pixels) worden opgegeven wanneer dient geschakeld te worden tussen smartphone lay-out of tablet lay-out.
Het smartphonemenu is altijd geactiveerd en kan ook worden gebruikt als de applicatie op een tablet wordt getoond.

\paragraph{\lungo}
Het raamwerk biedt enkel een functie aan om te weten of het huidige apparaat mobiel is.
\quo{} biedt daarenboven de mogelijkheid om de breedte en hoogte van het scherm terug te geven.
Dit betekent dat de ontwikkelaar nog altijd zelf instaat voor de bepaling of het een smartphone of tablet is.
Als oplossing werd gebruik gemaakt van CSS3 Media Queries, met dezelfde aanpak als \jqm{}.
Het smartphonemenu is altijd geactiveerd en kan ook worden gebruikt als de applicatie op een tablet wordt getoond.

%%%%%%%%%%%%%

\subsection{\uit{laadscherm}} 
\label{sec:evaluatie-gebruik-laadscherm}

In tabel \ref{tabel:evaluatie-gebruik-laadscherm} worden de resultaten getoond van de twee deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/laadscherm.csv}
\caption{Gebruik van \uit{laadscherm}.}
\label{tabel:evaluatie-gebruik-laadscherm}
\end{table}

\paragraph{\st}
Een laadscherm tonen kan door een masker op de huidige \code{View} te plaatsen.
Dit masker kan een bericht bevatten dat de laadtekst voorstelt.
\st{} biedt drie standaarden van dialoogvensters aan: \code{alert}, \code{prompt} en \code{confirm}.
De eerste laat de gebruiker een bericht zien,  de tweede vraagt de gebruiker om invoer en de laatste vraagt bevestiging aan de gebruiker.
De dialoogvensters kunnen met gelijknamige functies opgeroepen worden,  waarbij parameters de knoppen, titel en tekst bepalen.
% Een meer generieke aanpak is het oproepen van de \code{show}-methode op \code{Ext.Msg}.
% Intern roepen de standaard dialoogvensters deze methode ook op.

\paragraph{\kendo}
%Een \code{Application}-object wordt na initialisatie van een \kendo{}-applicatie aangemaakt.
Het raamwerk biedt methoden om het laadscherm te tonen of te verbergen.
De laadtekst voor alle laadschermen wordt opgegeven bij de initialisatie van de applicatie.
Een dialoogvenster wordt in \kendo{} \code{ModelView} genoemd.
Dit is niet hetzelfde als de View Model component van het MVVM-ontwerppatroon.
% Het attribuut \code{data-role} moet \code{modelview} als waarde hebben om een HTML-fragment als dialoogvenster te definiëren.
% Dit fragment kan kop- en/of voetteksten bevatten.
Het is mogelijk een \code{ModelView} in \js{} te selecteren en bijhorende methoden op te roepen.
In HTML kan er gelinkt worden naar een dialoogvenster zoals er naar traditionele \code{Views} wordt gelinkt.
Een attribuut moet dan wel weergeven dat de link naar een \code{ModelView} gaat.

\paragraph{\jqm}
Het standaard laadscherm is enkel een laadindicator die ronddraait, die niet opvallend aanwezig is en zonder tekst eronder.
Door de opties in de API te gebruiken, komt de laadindicator duidelijk naar voor door een zwarte achtergrond en kan er ook tekst worden ondergezet.
Eerst werd een plug-in~\cite{Sage2013} gebruikt om een dialoogvenster te tonen, maar deze was slecht aanpasbaar.
Uiteindelijk werden de dialoogvensters van \jqm{} gebruikt zodat de lay-out gemakkelijker kon worden aangepast.

\paragraph{\lungo}
Een laadscherm of dialoogvenster tonen, gebeurt met dezelfde functie.
Indien er geen parameters worden meegegeven, zal een laadscherm getoond worden.
De parameters bevatten de titel, omschrijving, tijd op het scherm en de functie die wordt opgeroepen bij het sluiten van het venster.
Daarnaast worden er ook specifieke dialoogvensters aangeboden om een succes- of foutmelding te tonen.
Deze zullen respectievelijk een groene en rode kleur hebben.
Als eerst een laadscherm wordt getoond, daarna wordt verborgen en daarna een dialoogvenster wordt getoond, verschijnt het dialoogvenster niet.
Een oplossing hiervoor is om het laadscherm niet te verbergen, waardoor enkel het dialoogvenster zal worden getoond.

%%%%%%%%%%%%%

\subsection{\uit{formulieren}}
\label{sec:evaluatie-gebruik-formulieren}

In tabel \ref{tabel:evaluatie-gebruik-formulieren} worden de resultaten getoond van de zeven deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/formulieren.csv}
\caption{Gebruik van \uit{formulieren}.}
\label{tabel:evaluatie-gebruik-formulieren}
\end{table}

\paragraph{\st} 
% Placeholders, text, email and number fields are supported by the framework and can be easily created.  
% Labels can be avoided by not defining them.  
% Creating custom datepickers is not supported.  
% It is impossible to ignore the days field and only years can be delimited.  
% Clearing the form after it was send, has to be programmed manually.
Een formulier kan in \st{} aan een \code{Formpanel} worden toegevoegd.
Dit object kan op zijn beurt voorzien worden van onder andere tekst-, e-mail- en nummervelden.
Ook optievelden of schakelaars kunnen hier aan het formulier worden toegevoegd.
Bij het renderen worden deze tot HTML5-invoertypes omgevormd.
Een \term{placeholder} toevoegen kan door een veld te voorzien met de eigenschap \code{placeholder}.

\st{} voorziet een \term{datepicker} maar deze is niet aanpasbaar volgens de vereisten van de POC.
Wel kan een begin- en eindjaar van de \term{datepicker} worden geconfigureerd.
Een \term{datepicker} maken waarbij het bereik kleiner is dan een jaar, is niet mogelijk.
Ook is het onmogelijk om enkel een maand- en jaarveld te tonen.
Het leegmaken van een formulier gebeurt niet automatisch wanneer het verzonden wordt.
Hiervoor moet de \code{reset}-methode op het bijhorende \code{Formpanel} worden opgeroepen.

\paragraph{\kendo}
 Formulierelementen definiëren kan via attributen door gebruik te maken van de opmaakgedreven aanpak van \kendo.
%  Het \code{placeholder}attribuut kan een \term{placeholder} definiëren,  het vermijden van \code{label}-tags zal geen labels genereren.
%  Het type van het formulierelement moet met het \code{type} attribuut worden gedefinieerd.
 Volgende HTML5-invoertypes worden onder andere door \kendo{} ondersteund:  \code{text}, \code{email}, \code{number} en \code{radio}.
 HTML5 voorziet het invoertype \code{range} voor een veld met beperkte invoer maar \kendo{} heeft een \code{Switch} om een schakelaar te maken.

 \term{Datepickers} worden als \term{widget} aangeboden in \kendo{} Web.
 Het bereik van de selectie kan worden ingeperkt door de minimum en maximum eigenschap te zetten.
 Enkel maand- en jaarvelden tonen kan door de diepte van de \term{datepicker} in te stellen.
 Deze eigenschappen worden bij initialisatie van het object meegegeven.
 
 Het wissen van formulieren steunt op het MVVM-ontwerppatroon.
 Een formulier kan worden gebonden aan een (View) Model.
 Wanneer een uitgave wordt toegevoegd, zal de huidige waarde van het (View) Model worden gereset.
 Door de dubbele binding tussen het formulier en het (View) Model zal ook de inhoud van de formulierelementen worden gewist.
 
\paragraph{\jqm} 
Voor het toevoegen van \term{placeholders} in de formuliervelden werd beroep gedaan op het \code{placeholder}-attribuut van HTML5. 
Labels zijn verplicht in \jqm{}, maar kunnen onzichtbaar worden gemaakt met de CSS-klasse \code{ui-hide-label}~\cite{JQuery2013}. 
Als er wordt teruggekeerd naar het formulier nadat het verzonden is, bevat het nog alle waarden. 
Na het versturen van het formulier, wordt het leeggemaakt met behulp van de \code{reset}-functie in \js{}.
 
Voor de types van de formuliervelden werd beroep gedaan op de HTML-invoertypes, gelijkaardig met \kendo{}.
Het type voor een datum werd echter niet gebruikt omwille van twee redenen.
Ten eerste was hiervoor een slechte ondersteuning naar mobiele browsers toe~\cite{Deveria2013c}.
Android~2.3 ondersteunt dit niet en de \term{placeholder} tekst in het veld ontbrak op iOS~6 en Android~4.2.
Hierdoor weet de gebruiker in eerste instantie niet wat hij hier moet invullen. 
Zelf een \term{placeholder} instellen is onmogelijk~\cite{Berjon2012}. 
Een tweede probleem was het opleggen van het bereik van datums, wat ook onmogelijk is. 
Beide problemen werden opgelost door gebruik te maken van de Date \& Time Picker van Mobiscroll~\cite{Mobiscroll2013} die ook aangepaste lay-out heeft conform met die van \jqm{}.
Het veld heeft dan wel tekst als invoertype.
Het is dus in principe mogelijk om iets anders dan een datum in te geven. 
Dit wordt belet door ook nog eens een datumvalidatie (zie \ref{sec:evaluatie-gebruik-validatie}) te doen op dit tekstveld mocht de plug-in het niet hebben afgedwongen.
 
Het was ook nodig om enkel de maand en het jaar in te geven als datum, dus zonder dag.
Ook hier kon niet het \code{date}-type gebruikt worden, omdat daar ook een dag voor nodig is. 
Daardoor werden de maanden handmatig geprogrammeerd als vaste lijstitems. 
De jaren zijn dynamisch en zijn telkens dit jaar, het volgende en het vorige jaar. 
Deze functionaliteit kon ook met de plug-in van Mobiscroll worden verwezenlijkt.
Als laatste werd zowel het optieveld als de schakelaar door \jqm{} zelf aangeboden en konden direct gebruikt worden. 
 
\paragraph{\lungo} 
Het toevoegen van \term{placeholders} in de formuliervelden gebeurt met het HTML5-atttribuut \code{placeholder}.
In \lungo{} zijn labels niet verplicht.
Indien deze niet gewenst zijn, kunnen deze gewoon uit de HMTL5-code weggelaten worden.

Voor de types van de formuliervelden werd beroep gedaan op de HTML-invoertypes, gelijkaardig met \kendo{}.
Door de twee aangehaalde problemen bij \jqm{} werd een plug-in gebruikt om de functionaliteit met datums op te lossen.
De \code{date-picker} werd gebruikt van de plug-in pagina van \lungo{} zelf~\cite{TapQuo2013b}.
Bij deze plug-in is al voorbeeldcode aanwezig die nodig is om automatisch een \term{datepicker} te openen en de aangeklikte datum in het formulierveld te zetten.
De plug-in laat echter niet toe om een bereik op te geven.
De datum met enkel een maand en jaar diende handmatig geprogrammeerd te worden omdat de aangeboden plug-in hiervoor geen ondersteuning bood.
De jaren zijn dynamisch en zijn telkens dit jaar, het volgende en het vorige jaar. 

Een optieveld werd niet aangeboden door \lungo{} en werd vervangen door een dropdownmenu. 
Een schakelaar daarentegen werd dan weer wel aangeboden.
Het legen van een formulier gebeurt door de \code{reset}-functie in \js{} op te roepen op dat formulier.

%%%%%%%%%%%%%

\subsection{\uit{vullen}}
\label{sec:evaluatie-gebruik-vullen}

In tabel \ref{tabel:evaluatie-gebruik-vullen} worden de resultaten getoond van de twee deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/vullen.csv}
\caption{Gebruik van \uit{vullen}.}
\label{tabel:evaluatie-gebruik-vullen}
\end{table}

\paragraph{\st}
Het invullen van een formulier wordt ondersteund door het MVC-ontwerppatroon.
Twee verschillende methoden worden in de POC gebruikt.
De eerste methode zal een formulier vullen door er een instantie van een model aan toe te kennen.
\st{} zal automatisch de velden invullen waarbij de naam gelijk is aan de eigenschap van het model.
Zo kan tekst op tekstvelden worden gemapt,  nummers op numerieke velden en \code{booleans} op schakelaars.
Er bestaat echter geen exacte mapping tussen een model en \code{radio}-velden.
Deze moeten apart worden ingevuld door een extra methode op te roepen.
De tweede methode voor het invullen van formulieren maakt gebruik van een \code{Navigationview} en wordt besproken in \ref{sec:evaluatie-gebruik-lijsten}.
De \code{readOnly}-eigenschap bepaalt de aanpasbaarheid van formulierelementen.
Bij \code{radio}-velden heet deze eigenschap \code{disabled}.


\paragraph{\kendo}
Het invullen van een formulier steunt op het MVVM-ontwerppatroon.
De dubbele binding tussen een formulier en (View) Model wordt met een HTML-tag aangegeven.
Een View Model wordt in \kendo{} \code{ObservableObject} genoemd.
Een \code{Model} breidt een \code{ObservableObject} uit met de mogelijkheid om schema's,  velden en methoden te definiëren.  
%In wat volgt zal aangenomen worden dat een \code{ObservableObject} wordt gebruikt in plaats van een \code{Model}.
Om een formulier met data te vullen is het de taak van de programmeur de eigenschappen van het \code{ObservableObject} van de gewenste waarden te voorzien.
De gebonden formulierelementen zullen vervolgens automatisch worden ingevuld.
\term{Read-only} velden moeten als attribuut in het formulierelement worden gespecificeerd.

\paragraph{\jqm}
Het vullen van formuliervelden wordt niet door \jqm{} geautomatiseerd.
Hierdoor moet ieder formulierveld worden gezocht om daarna zijn waarde in te stellen.
Bij een dropdownmenu en \code{radio}-velden kan deze methode niet worden gebruikt.
Voor de eerstgenoemde moet de gewenste optie worden gezocht en daaraan het \code{selected}- of \code{checked}-attribuut moeten worden toegevoegd.
Het \term{read-only} maken van velden gebeurt via het HTML-attribuut \code{readonly}.
Dit geldt voor alle types van velden, behalve voor dropdownmenu's en \code{radio}-velden waar \code{disabled} moeten worden gebruikt.
De andere niet-benodigde items worden uit de lijst verwijderd.

\paragraph{\lungo}
Velden vullen met data dient handmatig te gebeuren door eerst het formulierveld op te zoeken en daarna de waarde te zetten.
Deze waarde moet tekst zijn, waardoor bijvoorbeeld getallen eerst moeten worden omgevormd.
Geoptimaliseerde mobiele lay-out voor \code{radio}-velden is niet aanwezig in \lungo.
Het \term{read-only} maken van velden gebeurt via het HTML-attribuut \code{readonly}.
Dit gaat voor alle types van velden, behalve voor dropdownmenu's.
Daar worden de niet-benodigde opties uit de selectie verwijderd.

%%%%%%%%%%%%%

\subsection{\uit{autoaanvullen}}
\label{sec:evaluatie-gebruik-autoaanvullen}

In tabel \ref{tabel:evaluatie-gebruik-autoaanvullen} worden de resultaten getoond van de twee deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/autoaanvullen.csv}
\caption{Gebruik van \uit{autoaanvullen}.}
\label{tabel:evaluatie-gebruik-autoaanvullen}
\end{table}

\paragraph{\st}
Het automatisch aanvullen van een formulierelement steunt op een plug-in van Tajur~\cite{Tajur2012}.
Deze plug-in is niet op de Sencha Market terug te vinden.
Het toevoegen van de plug-in zal een invoerelement beschikbaar maken dat suggesties met een dropdownmenu weergeeft.
Dit element kan een \code{Proxy} definiëren die de \term{backend} aanspreekt om suggesties asynchroon op te halen.
De \term{backend} van de POC geeft bij een bepaalde invoer suggesties in een JSON-rij terug.
De rij is voorzien van een sleutel, maar alle elementen van de rij hebben er geen.
Geen van de beschikbare methoden was in staat de rij met suggesties te parsen van rij-element naar modelinstantie.
Hierdoor kon geen klikbaar dropdownmenu worden getoond.

\paragraph{\kendo}
Het automatisch aanvullen van een formulierelement wordt als \term{widget} door \kendo{} Web aangeboden.
Suggesties van het element kunnen zowel door een lokale als externe bron worden aangeleverd.
Externe suggesties moeten via een \code{DataSource} worden ingeladen.
Ook het minimale aantal suggesties en een filter kunnen worden opgegeven.
De filter bepaalt de methode om suggesties op te halen en kan \code{startswith} zijn.

\paragraph{\jqm}
Indien er wordt gebruik gemaakt van versie~1.2 is een plug-in nodig om auto-aanvulling te bekomen.
Hiervoor kan de plug-in van Andy Matthews worden gebruikt die zowel met lokale data als externe data kan werken~\cite{Matthews2013}. 
Sinds versie~1.3 voorziet \jqm{} deze functionaliteit zelf~\cite{JQuery2013c}.
De filterfunctie moet zelf worden geschreven, maar code op de site kon als voorbeeld worden overgenomen.

\paragraph{\lungo}
Standaard biedt \lungo{} geen auto-aanvullig aan, maar wel op zijn site van plug-ins~\cite{TapQuo2013b}.
Daar werd de plug-in AutoComplete gebruikt.
De voorbeeldcode maakt het gemakkelijk om onmiddellijk een werkend voorbeeld van de plug-in te hebben.
Veel code kon dus worden overgenomen om een werkende auto-aanvulling te bekomen.
Er diende nog één extra CSS-regel te worden toegevoegd om het symbool voor de suggesties te verwijderen.
%Deze maakten namelijk gebruik van \code{li}-items binnen een \code{ul}-tag waardoor er symbolen voor de suggesties kwamen.


%%%%%%%%%%%%%

\subsection{\uit{afbeelding}}
\label{sec:evaluatie-gebruik-afbeelding}

In tabel \ref{tabel:evaluatie-gebruik-afbeelding} worden de resultaten getoond van de drie deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/afbeelding.csv}
\caption{Gebruik van \uit{afbeelding}.}
\label{tabel:evaluatie-gebruik-afbeelding}
\end{table}

\paragraph{\st}
Het opladen van een afbeelding steunt op een plug-in van Smirnov~\cite{Smirnov2012} en kan in de Sencha Market gevonden worden.
De plug-in is generiek voor het opladen van elk type bestand.
% Na het toevoegen van de plug-in wordt het \code{xtype} \code{img} beschikbaar voor \st{} componenten.
De plug-in voorziet twee modes voor het opladen van bestanden: lokaal of extern.
De eerste laat toe afbeeldingen lokaal of in het DOM als Base64 op te laden.
De tweede mode zal bestanden naar de externe server versturen.
De POC vereist de eerste aanpak.
Nadat een bestand is opgeladen zal een gebeurtenis het slagen of falen van de operatie bepalen.
Het is de taak van een \code{Controller} om deze gebeurtenissen op te vangen en te delegeren naar een bijhorende methode.
De succesfunctie krijgt de Base64-tekst mee en kan een voorbeeld van de afbeelding weergeven.

\paragraph{\kendo}
\kendo{} Web biedt een \term{widget} aan die het opladen van bestanden toelaat.
Deze \term{widget} kan in twee modi worden gebruikt: synchroon of asynchroon.
In synchrone modus wordt het formulier samen met de afbeelding verzonden als een uitgave wordt toegevoegd.
In asynchrone modus gebeurt het opladen meteen na het selecteren van de afbeelding.
Deze methode steunt op de HTML5 FileReaderAPI.
Omdat een voorbeeld van de afbeelding werd gevraagd, is de asynchrone oplossing gekozen.	
Voor ASP.NET MVC,  JSP en PHP is een implementatie beschikbaar om het opladen van bestanden aan serverzijde af te handelen.
Er werd gekozen om de PHP-implementatie te gebruiken omdat deze technologie reeds gekend was.
Wanneer een afbeelding succesvol is opgeladen, wordt het bestand met een \code{FileReaderAPI} gelezen,  aan een \code{canvas} toegevoegd en naar Base64 omgezet met de \code{toDataURL}-methode.

\paragraph{\jqm}
Het toevoegen van een afbeelding gebeurt door het bestandstype als invoertype aan het formulierveld toe te voegen. 
In versie~1.2 wordt dit veld niet opgemaakt met lay-out, maar dit gebeurt wel in versie 1.3~\cite{JQuery2013d}. 
Het omvormen van de afbeelding naar Base64 is analoog aan \kendo{}.
Het voorvertonen van de geüploade afbeelding hangt af van het mobiele besturingssysteem.
Zo wordt op iOS~6 een miniatuurafbeelding getoond, terwijl op Android de bestandsnaam wordt getoond in het invoerveld.
Het is natuurlijk ook mogelijk om de voorvertoning na conversie zelf te tonen op het scherm.
Bij iOS zouden er dan twee voorvertoningen te zien zijn op hetzelfde scherm.

\paragraph{\lungo}
Een afbeelding kiezen gebeurt door aan het formulierveld het bestandstype toe te voegen.
De methode om een afbeelding om te vormen naar Base64 is analoog met \kendo{}.
Het voorvertonen van de geüploade afbeelding gebruikt dezelfde aanpak als \jqm{}.

%%%%%%%%%%%%%

\subsection{\uit{validatie}}
\label{sec:evaluatie-gebruik-validatie}

In tabel \ref{tabel:evaluatie-gebruik-validatie} worden de resultaten getoond van de vier deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.


\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/validatie.csv}
\caption{Gebruik van \uit{validatie}.}
\label{tabel:evaluatie-gebruik-validatie}
\end{table}

\paragraph{\st}
Een model kan worden voorzien van validatieregels.
Deze regels worden in een rij aan de \code{validations}-eigenschap van een model toegekend.
% Volgende validatieregels zijn ingebouwd:
% \begin{description}
%   \item [presence] verzekert dat het veld een waarde heeft waarbij nul als geldig wordt beschouwd,  lege tekst niet.
%   \item [length] verzekert dat een tekst een minimale en/of maximale waarde heeft.
%   \item [format] verzekert dat een tekst voldoet aan een opgegeven reguliere expressie.
%   \item [inclusion] verzekert dat de waarde van een veld gelijk is aan een element van een gespecificeerde set.
%   \item [exclusion] verzekert dat de waarde van een veld zeker niet gelijk is aan een element van een gespecificeerde set.
% \end{description}
Verplichte velden moeten worden aangeduid met \code{presence}.
De controle op geldige e-mailadressen kan door \code{email} als validatieregel aan het invoerelement toe te kennen. 
Controleren op een nummer kan met \code{format} en de \code{\textbackslash{}d+} reguliere expressie. 
Om een bepaalde modelinstantie te valideren moet de \code{validate}-methode op de instantie worden opgeroepen.
Om eigen validatieregels toe te laten moet de implementatie van deze methode worden overschreven~\cite{Krause2011}.
Deze functionaliteit zit dus niet standaard in \st{}.
Met de nieuwe \code{validate}-methode kan een \code{validator} aan een validatieregel worden toegevoegd.
Dit is een functie die de programmeur zelf bepaalt en \code{true} of \code{false} teruggeeft bij het al dan niet slagen van een conditie.

Het opbouwen van een foutboodschap kan door te itereren over de fouten die na validatie worden teruggegeven.
Een specifieke foutboodschap kan aan elke validatieregel worden toegekend.
Incorrecte formulierelementen aanduiden met een rode rand wordt niet door \st{} ondersteund.
Foutief ingevulde formulierelementen moeten na validatie met een eigen CSS-klasse worden aangevuld.

\paragraph{\kendo}
Het \kendo{}-raamwerk ondersteunt de validaties zoals aangeboden binnen HTML5.
% \begin{description}
%   \item [required] verzekert dat een het veld een waarde heeft.
%   \item [pattern] verzekert dat de waarde van een veld voldoet aan een opgegeven reguliere expressie.
%   \item [min/max] verzekert dat de waarde van een veld groter en/of kleiner is dan een opgegeven waarde.
%   \item [data types] verzekert dat de waarde van een veld gelijk is aan het opgegeven type (e-mail, URL, getal, enz.)
% \end{description}
%Deze validaties moeten binnen het data-attribuut van het formulierelement worden aangebracht.
Het \code{required}-attribuut maakt de velden verplicht \code{email} en \code{number} als invoertype zullen de opgegeven waarden controleren op geldigheid.
De \kendo{} \code{validator} gebruikt attributen van HTML5-validaties.
HTML5-validatie wordt echter niet ondersteund op mobiele browsers~\cite{Deveria2013c}. 
\kendo{} zal de HTML5-attributen omvormen tot een validatie in \js{}. 
Het definiëren van een eigen validatieregel kan door een \js-functie aan de \code{validator} toe te voegen.
% De validatiecontrole starten kan door de \code{validate}-methode op de \code{validator} op te roepen.
Bij het controleren van invoerelementen worden altijd eerst de standaard validatieregels gecontroleerd,  daarna de eigen validatieregels.
De volgorde waarin de controles worden uitgevoerd, ligt vast en zal stoppen zodra één controle mislukt.
Validatieberichten kunnen voor standaard validaties door het raamwerk zelf worden opgebouwd.
Deze kunnen worden overschreven door zelf een bericht aan het invoerelement toe te kennen.
Bij eigen validatieregels kan een bericht per validatieregel worden gespecificeerd.

Incorrecte formulierelementen aanduiden met een rode rand wordt niet door \kendo{} ondersteund.
De standaard implementatie voorziet een \code{tooltip} per incorrect veld.
Deze zal het validatiebericht naast het invalide formulierelement plaatsen. 
Een venster tonen waarbij alle foutboodschappen zijn samengevat is ook niet standaard aanwezig.
De volledige foutboodschap moet worden geconstrueerd door foutboodschappen,  zoals teruggegeven door de \code{validator}, te concateneren.
Hoe een dialoogvenster gemaakt wordt, werd in sectie \ref{sec:evaluatie-gebruik-laadscherm} besproken.

\paragraph{\jqm}
Validatie is niet standaard aanwezig in \jqm. 
Eerst werd geprobeerd om de verplichte velden te voorzien van het \code{required}-attribuut in HTML5. 
Doordat er geen ondersteuning is voor mobiele browsers, zoals opgemerkt bij \kendo{}, werd de plug-in van Jörn Zaefferer gebruikt~\cite{Zaefferer2013}. 
Deze kan op twee manieren gebruikt worden: enerzijds annoteren van de formuliervelden met speciale CSS-klassen in de HTML-code en anderzijds door programmatie met \js{}. 
Beide aanpakken werden gebruikt doorheen de implementatie. 
De plug-in bevat alle gevraagde validatieregels.
Daarnaast was het nodig dat een veld verplicht was enkel indien een bepaalde optie was aangevinkt.
Deze afhankelijkheidsrelatie is standaard aanwezig in de plug-in.

De plug-in toont standaard een foutboodschap onder het foute formulierveld.
Door de uitvoerig documentatie van de plug-in, konden alle foutboodschappen samen in één dialoogvenster worden weergegeven.
De plug-in annoteert de incorrecte velden met een CSS-klasse.
Hierdoor kon de rode rand in CSS worden geprogrammeerd. 
Voor \code{radio}-velden en dropdownmenu's gaf dit problemen door de extra code die \jqm{} genereert rond deze velden.
Als oplossing moest de omvattende code worden geannoteerd.

\paragraph{\lungo}
Validatie is niet aanwezig in \lungo{} en er kon ook geen plug-in voor QuoJS gevonden worden.
Er werd geprobeerd om bestaande plug-ins voor andere \js{}-bibliotheken om te vormen en deze te laten werken met \quo{}.
Aangezien deze manier niet direct een oplossing bracht en er geen beroep kon worden gedaan op HTML5-validatie (zie \kendo{}), moest alle validatie manueel geprogrammeerd worden. 
Bij wijze van voorbeeld werd enkel validatie op het loginscherm geprogrammeerd.
Validatie op de rest van de formulieren doorheen de POC is volgens dezelfde werkwijze mogelijk, maar werd niet geïmplementeerd.
Het tonen van foutboodschappen alsook het tonen van een rode rand rond de foute velden werden ook zelf geprogrammeerd.
Bij een incorrect veld werd een CSS-klasse toegevoegd die zorgde voor een rode rand.

%%%%%%%%%%%%%

\subsection{\uit{handtekening}}
\label{sec:evaluatie-gebruik-handtekening}

In tabel \ref{tabel:evaluatie-gebruik-handtekening} worden de resultaten getoond van de deeluitdaging.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/handtekening.csv}
\caption{Gebruik van \uit{handtekening}.}
\label{tabel:evaluatie-gebruik-handtekening}
\end{table}

\paragraph{\st}
Het tekenen van een handtekening steunt op een plug-in van SimFla~\cite{SimFla2011} en is in de Sencha Market te vinden.
De plug-in maakt een nieuw invoerelement beschikbaar dat in een formulier kan worden gebruikt.
Dit element maakt gebruik van het HTML5 \code{canvas} en retourneert de handtekening als Base64-tekst.

\paragraph{\kendo}
Aangezien \kendo{} steunt op de jQuery bibliotheek is \kendo{} ook compatibel met jQuery plug-ins.
De jSignature handtekening plug-in van Willow Systems~\cite{Systems2013} werd geïmplementeerd.
De plug-in maakt gebruik van het HTML5 \code{canvas}-element en de \code{toDataURL}-methode.
Hierdoor kan de Base64-string bekomen worden die naar de \term{backend} moet worden gestuurd.

\paragraph{\jqm}
Er werd gezocht naar een plug-in om deze functionaliteit te bekomen, doordat \jqm{} dit niet standaard aanbiedt. 
De eerst gevonden plug-in~\cite{Bradley2013} werd niet gebruikt wegens problemen met het aanpassen van de lay-out.
Uiteindelijk werd dezelfde plug-in als bij \kendo{} gebruikt.
Deze gaf ook het voordeel dat het gebied van de handtekening de volledige schermbreedte innam. 
Dezelfde aanpak zoals bij \kendo{} werd gevolgd voor het omvormen naar Base64.

\paragraph{\lungo}
Het maken van een handtekening is niet standaard aanwezig en daarenboven kon ook geen plug-in worden gevonden.

%%%%%%%%%%%%%

\subsection{\uit{ajax}}
\label{sec:evaluatie-gebruik-ajax}

In tabel \ref{tabel:evaluatie-gebruik-ajax} worden de resultaten getoond van de vier deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/ajax.csv}
\caption{Gebruik van \uit{ajax}.}
\label{tabel:evaluatie-gebruik-ajax}
\end{table}

\paragraph{\st}
AJAX-verzoeken kunnen zowel expliciet via een directe oproep met \code{Ext.Ajax.request} als impliciet via \code{Stores} worden uitgevoerd.
De expliciete oproep is gelijkaardig aan de \code{\$.ajax}-methode van de jQuery bibliotheek.
De enige uitzondering is te vinden bij AJAX-verzoeken naar een ander domein.
Om aan de CORS-standaarden (Cross-Origin Resource Sharing) te voldoen moet de eigenschap \code{useDefaultXhrHeader} op \code{false} worden gezet.

De tweede impliciete methode voor AJAX-verzoeken is via \code{Stores}.
Een \code{Store} wordt voorzien van een \code{Proxy}.  
Een \code{Proxy} kan data verzenden via AJAX.  
Hierbij kunnen \code{Readers} geconfigureerd worden om data van de server te lezen.
\st{} voorziet drie methoden om de resultaten van een \code{Proxy} te parsen naar modelinstanties:
\begin{description}
 \item [\code{JsonReader}] parst JSON-sleutels naar velden van een model.
 \item [\code{XmlReader}] parst XML-tags naar velden van een model.
 \item [\code{ArrayReader}] mapt elementen van een rij op velden van een model.
\end{description}
Het verzenden van een JSON-\term{payload} moet met een expliciet AJAX-verzoek gebeuren.
Na het encoderen kan de JSON-data aan het verzoek worden gekoppeld.

\paragraph{\kendo}
Om asynchrone verzoeken naar de \term{backend} te implementeren, moet een \code{DataSource} worden gebruikt.
Deze bevat een \code{transport}-eigenschap die data kan creëren (\code{create}-eigenschap),  lezen (\code{read}-eigenschap),  verwijderen (\code{destroy}-eigenschap) en op te waarderen (\code{update}-eigenschap).
Deze vier eigenschappen moeten geconfigureerd worden zoals de \code{\$.ajax}-methode van de jQuery-bibliotheek.

Hoe data moet worden geparset, staat gedefinieerd in de \code{schema}-eigenschap van de \code{DataSource}.
Zowel JSON als XML worden ondersteund.
Aan een \code{schema} kan een (View) Model worden toegekend.
Er onderscheiden zich twee gevallen:  één bestaand \code{ObservableObject} kan met data worden geladen of nieuwe instanties van een \code{Model} kunnen worden aangemaakt.
Het eerste geval zal de velden van één \code{ObservableObject} wijzigen als CRUD-operaties worden uitgevoerd.
De eigenschap moet dan aan het \code{ObservableObject} worden gelijkgesteld.
Het tweede geval zal de instanties van een \code{Model} wijzigen als CRUD-operaties worden uitgevoerd.
Hiervoor moet het model in de \code{schema}-eigenschap worden gedefinieerd.
Een \code{OservableObject} kan met de \code{toJSON}-methode als JSON-object worden verkregen.
Het serialiseren kan via \code{JSON.stringify} en deze kan met een AJAX-verzoek worden verstuurd.

\paragraph{\jqm}
Het maken van oproepen via AJAX gebeurt door \code{\$.ajax} in jQuery. 
Bij de oproep wordt ingesteld wat het te verwachten antwoord is (tekst, JSON of XML). 
Met tekst en JSON kan onmiddellijk worden omgegaan.
Gegevens uit XML halen vraagt meer werk doordat \term{selectors} moet worden gebruikt.

Het versturen van JSON is gelijkaardig met het versturen van andere data.
Eerst moet de JSON-data worden omgezet naar tekst, wat gebeurt door \code{JSON.stringify}.
Daarna moet in het AJAX-verzoek worden aangegeven dat de inhoud JSON is, wat gebeurt door \code{contentType:"{}application/json"}.

\paragraph{\lungo}
Standaard biedt \lungo{} functies aan voor het ophalen en versturen van data via AJAX.
Deze functies zullen intern de functies van \quo{} oproepen.
Tekst en JSON kunnen onmiddellijk worden gebruikt.
Voor XML dient er gebruik te worden gemaakt van de \term{selector} in \quo{} om de gevraagde data op te zoeken.

Bij het versturen van JSON-data konden de functies van \lungo{} zelf niet worden gebruikt.
Deze hadden te weinig opties om aan te geven dat de verstuurde data JSON was.
Hierdoor werden de functies van \quo{} gebruikt, die meer opties hadden.
Toch bleef er een probleem bij het versturen van JSON-\term{payload}.
\quo{} wil namelijk altijd de parameters serialiseren.
Dit is uiteraard niet nodig als ruwe data, zoals JSON, wordt meegegeven.
Aangezien dit een fout was in de bibliotheek werd het \js-bestand zelf aangepast.

%%%%%%%%%%%%%

\subsection{\uit{lijsten}}
\label{sec:evaluatie-gebruik-lijsten}

In tabel \ref{tabel:evaluatie-gebruik-lijsten} worden de resultaten getoond van de drie deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/lijsten.csv}
\caption{Gebruik van \uit{lijsten}.}
\label{tabel:evaluatie-gebruik-lijsten}
\end{table}

\paragraph{\st}
Een lijst kan voorzien worden van een sjabloon.
Hier kunnen HTML-tags de lay-out van de lijstelementen vastleggen of kan er \js-code worden uitvoeren.
Zoals reeds besproken in sectie \ref{sec:evaluatie-gebruik-vullen}, kan een formulier worden ingevuld met een \code{Navigationview}.
Deze \code{View} heeft een \code{push}- en \code{pop}-methode om een \code{View} op een stapel te plaatsen of af te halen.
Om een \code{View} te tonen die hoort bij een lijstelement, wordt gebruik gemaakt van deze \code{Navigationview} en de \code{push}-methode.

Een \code{Controller} merkt het aanraken van een lijstelement en zal de \code{push}-methode op de \code{Navigationview} oproepen.
De methode kan geparameteriseerd worden met de modelinstantie die hoort bij het lijstelement.
Hierdoor zal de nieuwe \code{View} worden gevuld met waarden van de modelinstantie.
Automatisch zal er ook een \term{back} knop worden gegenereerd die na aanklikken de \code{pop}-methode zal oproepen.

Een \code{Store} kan aan een lijst worden gekoppeld zodat alle modelinstanties van de \code{Store} in de lijst worden weergegeven.
Het sorteren van een lijst kan automatisch door de \code{Store} te voorzien van een \code{Sorter}.
Deze kan modelinstanties van een \code{Store} sorteren op basis van eigenschappen van het bijhorende model.
Ook kan de richting van sorteren worden geconfigureerd.

\paragraph{\kendo}
Lijsten worden met een \code{Listview} gemaakt en kunnen worden gebonden met een \code{DataSource}.
Hierdoor zullen alle instanties van de \code{DataSource} als element in de lijst verschijnen.
Ook kan een \js-rij aan een \code{Listview} worden gebonden op basis van de \code{source}-eigenschap.
Deze methodiek is uitvoerig in de documentatie beschreven.
De opmaak van lijsten kan met \code{Templates} worden uitgedrukt.
Dit zijn sjablonen die met specifieke scripts in een HTML-bestand worden geschreven.
De sjablonen hebben toegang tot de velden van de modelinstanties en kunnen \js-functies uitvoeren.

De link van elk lijstelement moet in het sjabloon worden gedefinieerd.
Om de elementen uit het uitgavenoverzicht te linken, werd gebruik gemaakt van een geparameteriseerde \code{View}.
Dit laat toe om parameters in de link naar de \code{View} op te geven,  analoog aan HTTP GET-verzoeken.
De functie zal een \code{ObservableObject} laden met data op basis van de meegegeven parameter.
Dit \code{ObservableObject} is gekoppeld aan een formulier dat automatisch zal worden ingevuld zodra het object wordt geïnitialiseerd.
Het sorteren van een lijst kan door de \code{DataSource} die aan de lijst is gekoppeld van een sorteereigenschap te voorzien.

\paragraph{\jqm}
Het laden van data in een lijst dient zelf geprogrammeerd te worden.
Via jQuery wordt één voor één een item toegevoegd aan de lijst.
Na alle elementen te hebben toegevoegd, moet de lijst ververst worden zodat \jqm{} de correcte lay-out toepast op de volledige lijst
Het klikbaar maken van de gegenereerde lijstitems gebeurt bij het toevoegen van de items zelf.
Ieder lijstitem krijgt een unieke \term{identifier} waarmee de uit te voeren actie wordt bepaald.
Er komt geen functionaliteit van het raamwerk om data te sorteren.
Eerst moet zelf een vergelijkingsfunctie in \js{} worden geschreven, waarna die aan de sorteerfunctie van \js{} wordt meegegeven.

\paragraph{\lungo}
Het laden van data in een lijst dient zelf geprogrammeerd te worden.
Items worden één voor één toegevoegd aan de lijst met behulp van \quo{}.
Het is daarentegen niet nodig om de lijst te verversen.
Om de gegenereerde lijstitems klikbaar te maken, wordt de werkwijze van \jqm{} gebruikt.
Dit gebeurt bij het genereren van de items zelf en op basis van een unieke \term{identifier} die de uit te voeren actie bepaald.
Het sorteren van data gebeurt door de aangeboden functies van het raamwerk zelf.
Deze maken het mogelijk om te sorteren volgens een bepaalde eigenschap, zowel oplopend als aflopend.

%%%%%%%%%%%%%

\subsection{\uit{pdf}}
\label{sec:evaluatie-gebruik-pdf}

In tabel \ref{tabel:evaluatie-gebruik-pdf} worden de resultaten getoond van de twee deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/pdf.csv}
\caption{Gebruik van \uit{pdf}.}
\label{tabel:evaluatie-gebruik-pdf}
\end{table}

\paragraph{\st}
Het tonen van een PDF steunt op een plug-in van Fiedler~\cite{Fiedler2012} en kan op de Sencha Market gevonden worden.
De PDF zal in een paneel met een koptekst worden getoond.
Het paneel toont één pagina van het PDF-bestand,  de koptekst bevat de navigatie naar andere pagina's.
Om de plug-in in de POC te gebruiken, waren echter twee aanpassingen noodzakelijk.
Het PDF-bestand moet via een POST-verzoek worden opgehaald waarbij parameters het exacte PDF-bestand aanduiden.
Ook moest er een terugknop in de koptekst van het paneel worden aangebracht om terug naar het overzicht van doorgestuurde formulieren te gaan.

\paragraph{\kendo}
AJAX is bedoeld om tekst op te halen, maar geen ruwe data zoals een PDF~\cite{Scott2009}. 
Hierdoor werd gebruik gemaakt van een verborgen formulier met de nodige parameters die de PDF ophaalt bij de \term{backend}. 
Na het klikken op een lijstitem in het overzicht, wordt dit verborgen formulier opgestuurd naar de \term{backend} die dan een PDF teruggeeft in de browser. 
Het weergeven van de PDF wordt overgelaten aan het mobiel apparaat dat de correcte applicatie hiervoor opstart.

\paragraph{\jqm}
De implementatie voor het tonen van het PDF-bestand is analoog als de implementatie met \kendo{}.

\paragraph{\lungo}
De implementatie voor het tonen van het PDF-bestand is analoog als de implementatie met \kendo{}.

%%%%%%%%%%%%%

\subsection{\uit{offline}}
\label{sec:evaluatie-gebruik-offline}

In tabel \ref{tabel:evaluatie-gebruik-offline} worden de resultaten getoond van de twee deeluitdagingen.
Hieronder wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/offline.csv}
\caption{Gebruik van \uit{offline}.}
\label{tabel:evaluatie-gebruik-offline}
\end{table}

\paragraph{\st}
Zoals besproken in sectie~\ref{sec:evaluatie-gebruik-ajax} kan een \code{Store} voorzien worden van een \code{Proxy} die data lokaal opslaat aan klantzijde.
Deze \code{Store} maakt gebruik van de HTML5 \code{localStorage}.
Om gegevens van een gebruiker en onverzonden onkosten lokaal te bewaren moeten twee \code{Stores} met deze \code{Proxy} worden gedefinieerd.
Een belangrijke opmerking is dat geen twee \code{Proxies} aan dezelfde \code{Store} kunnen worden toegevoegd.
Gegevens van een gebruiker moeten van de server worden opgehaald - met een AJAX-\code{Proxy} - en lokaal worden opgeslagen - met een \code{LocalStorageProxy}.
Hiervoor zijn twee verschillende \code{Store} instanties nodig die gesynchronizeerd moeten worden.
Bij het laden van de applicatie zal de \code{Store} die gebruikers lokaal opslaat, op data worden gecontroleerd.
Indien er data wordt gevonden,  was de gebruiker reeds ingelogd.
De applicatie zal dan meteen naar het startscherm navigeren.

Om onverzonden uitgaven lokaal op te slaan, moeten de uitgaven ook aan een \code{Store} met lokale \code{Proxy} worden toegevoegd.
De uitgaven worden dan automatisch naar de \code{localStorage} weggeschreven.
De controle op onverzonden uitgaven wordt herleid tot het controleren van data in de \code{Store}.
Het verwijderen van onverzonden lokale uitgaven kan door de data in de \code{Store} te wissen.

De applicatie offline beschikbaar maken wordt ondersteund door Sencha Cmd~\cite{Sencha2012}.
Hiervoor moet de applicatie gebouwd worden voor productie (zie sectie \ref{sec:raamwerk-st-omkadering}).
De tool zal automatisch een \code{manifest}-bestand aanmaken die alle vereiste bestanden bevat die offline nodig zijn.

\paragraph{\kendo}
Vanuit het raamwerk is er geen ondersteuning om gegevens offline te bewaren.
Hiervoor werd gebruik gemaakt van \code{localStorage}, wat gespecificeerd is in HTML5.
Het controleren of \code{localStorage} al dan niet wordt ondersteund, gebeurd door Modernizr~\cite{Modernizr2012}.

Na het aanmelden zullen alle gegevens van de werknemer geserialiseerd worden opgeslagen.
Wanneer het inlogscherm wordt getoond, zal gecontroleerd worden of er gegevens van een werknemer lokaal beschikbaar zijn.
Indien dit het geval is, wordt automatisch naar het startscherm genavigeerd en de \code{DataSource} met informatie van de gebruiker ingevuld.
Een uitgave toevoegen moet zowel aan een \code{DataSource} als in de \code{localStorage} gebeuren.
Nadat een uitgaveformulier is verzonden, worden de uitgaven uit beide plaatsen verwijderd.

Het offline beschikbaar maken van de applicatie wordt vanuit \kendo{} zelf niet ondersteund.
Dit kan opgelost worden met HTML5 Application Cache.
Om het proces te vergemakkelijken werd het \code{manifest}-bestand gegenereerd aan de hand van Yeoman~\cite{Yeoman2013}.

\paragraph{\jqm}
Vanuit het raamwerk komt er standaard geen ondersteuning om gegevens offline te bewaren of de applicatie offline beschikbaar te maken.
Net zoals \kendo{} werden lokale opslag en HTML5 Application Cache gebruikt.
Het startscherm werd als eerste scherm gekozen, omdat \jqm{} altijd het eerste scherm in de HTML-code inlaadt.
Indien gemerkt wordt dat de gebruiker niet aangemeld was, dan wordt hij doorverwezen naar het inlogscherm.
Hierdoor zal, als de applicatie offline is, de gebruiker kunnen navigeren doorheen de applicatie doordat zijn gegevens werden bewaard.

\paragraph{\lungo}
Het raamwerk biedt zelf functies aan om data lokaal op te slaan.
Dit kan zowel permanent als voor de huidige browsersessie zijn.
Net zoals \kendo{} werd HTML5 Application Cache gebruikt.