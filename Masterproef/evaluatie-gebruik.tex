\section{Gebruik}
\label{sec:evaluatie-gebruik}
Het gebruik van de vier raamwerken wordt samengevat voor de 13 uitdagingen in tabel \ref{tabel:evaluatie-gebruik}.
Per sectie zal iedere uitdaging per raamwerk worden besproken.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik.csv}
\caption{Overzicht van gebruik voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik}
\end{table}

Het raamwerk dat het beste scoort bij gebruik is \kendo{}, kort gevolgd door \st{}.
Dit kan grotendeels door de aanwezigheid van een architectuur, respectievelijk MVVM en MVC, worden verklaard.
Het ontbreken van een architectuur bij de andere twee raamwerken resulteert in een omslachtige aanpak, waardoor punten worden verloren.
Daarnaast worden beide raamwerken beheerd door een bedrijf en aangezien de POC een typische bedrijfsapplicatie is, kan mede de goede score worden verklaard.
Opmerkelijk is de perfecte score van \kendo{} voor formulieren, maar de mindere ondersteuning voor offline dan \st{}.
\jqm{} behaalt de helft met wat overschot, maar goed is dat zeker niet.
Vooral op het vlak om data automatisch in te laden in velden of lijsten, scoort het nul door het ontbreken van een architectuur. 
Als laatste komt \lungo{} dat een onvoldoende behaalt.
Dezelfde pijnpunten van \jqm{} zijn ook geldig voor \lungo{}.
Daarenboven is er bij \lungo{} een totaal gebrek aan formuliervalidatie en aan de meer geavanceerdere formulierelementen.
Voor deze laatste moet er het geluk zijn om plug-in te vinden of zal de functionaliteit zelf moeten worden geïmplementeerd. 

\kendo{} en \st{} behalen elk zes perfecte uitdagingen.
\kendo{} scoort twee maal onvoldoende, terwijl \st{} dat slechts één keer doet.
\jqm{} heeft drie perfecte uitdagingen en vier onvoldoendes.
Als laatste komt \lungo{} met slechts één perfecte uitdaging en zeven onvoldoendes.

Een algemene trend bij iedere raamwerk is de volle ondersteuning van AJAX-oproepen, behalve dan bij één geval voor \lungo{}.
Ook laadschermen en dialoogvensters zijn bij ieder raamwerk volledig aanwezig.


%%%%%%%%%%%%%

\subsection{\uit{anatomie}}
\label{sec:evaluatie-gebruik-anatomie}

In tabel \ref{tabel:evaluatie-gebruik-anatomie} worden de resultaten getoond van de drie deeluitdagingen van \uit{anatomie}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/anatomie.csv}
\caption{Gebruik van \uit{anatomie} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-anatomie}
\end{table}

\paragraph{\st}
Het opbouwen van een \code{view} in \st{} gebeurt hiërarchisch met containers.
Een component die aan een container kan worden toegevoegd is de \code{toolbar}.
Een \code{toolbar} kan zowel bovenaan als onderaan een container worden vastgezet.
Dit kan dan dienstdoen als hoofdtekst en voettekst.
Een cascade van hoofdteksten is door de hiërarchische opbouw van containers mogelijk en laat zo onderkopteksten toe.
Een \code{toolbar} kan voorzien worden van een titel door de \code{title} eigenschap in te vullen.
Knoppen aan een \code{toolbar} toevoegen kan door een lijst van \code{buttons} aan de \code{items} eigenschap toe te voegen.

Het toevoegen van een tabbar verloopt analoog door een \code{tabpanel} toe te voegen.
De \code{items} eigenschap bevat dan een lijst van \code{views} met een titel waarbij de \code{view} zichtbaar wordt als op de titel wordt gedrukt.

Knoppen van kleur veranderen kan door de \code{style} van een knop te zetten.
Deze eigenschap laat toe om CSS-eigenschappen als tekst of object aan de knop toe te voegen.

\paragraph{\kendo}
De anatomie van een \code{view} wordt met het data-attribuut \code{data-layout} bepaald.
Hier wordt de id van een HTML-fragment opgegeven waar het skelet van een \code{view} staat.
Hoofd- en/of voetteksten toevoegen kan door in het fragment de \code{header} of \code{footer} tags te gebruiken.
Een hoofdtekst kan een \code{navbar} hebben waarin knoppen kunnen worden gedefinieerd.
\code{Header}-tags kunnen niet genest worden, dus zijn onderhoofdteksten niet mogelijk in \kendo{}.
%TODO referentie

Een tabbar moet met een \code{buttongroup} worden gemaakt.
Dit is een lijst van knopppen.
Na deze lijst moeten de bijhorende \code{views} worden geschreven.
Het initialiseren van de lijst van knoppen moet via \code{\$("\#id").kendoMobileButtonGroup()}.
Het bijhorende \js-object bevat een \code{select} gebeurtenis die zich afspeeld wanneer een knop is geslecteerd.
Aan deze gebeurtenis moet een functie worden gekoppeld die alle \code{views} verbergt behalve diegene die hoort bij de geselecteerde knop.
Deze operaties steunen op de CSS-manipulatie zoals aangeboden door jQuery.

De kleur van een knop wijzigen moet met CSS gebeuren.
Omdat knoppen met HTML-tags worden aangemaakt kan de CSS-klasse rechtstreeks aan de tags worden toegevoegd.

\paragraph{\jqm}
Het toevoegen van een kop- en voettekst gebeurt door gebruik te maken van \code{data-role="header"} en \code{data-role="footer"}. 
Wel moest dezelfde code op ieder scherm worden herhaald. 
Dit kan worden vermeden door gebruik te maken van eenzelfde \code{data-id} attribuut. 
Daarnaast werd de voettekst gefixeerd aan de onderkant van het scherm en de bijhorende logo's links en rechts uitgelijnd. 
Voor dit laatste werd gebruik gemaakt van de zogenaamde \term{grid} die \jqm{}~1.3 zelf aanbiedt. 
De voettekst wordt niet getoond op een smartphone, wat wordt bekomen door gebruik te maken van de CSS3 media queries.

Voor de onderkoptekst werd eerst geprobeerd om bovenaan een lijst met enkel één lijstdeler te plaatsen, maar dan schoof de inhoud van de pagina niet mee naar onder. 
De uiteindelijke oplossing kwam vanuit de documentatie om dit met behulp van de CSS-klasse \code{ui-bar} te implementeren~\cite{JQuery2013b}. 
Deze extra titel wordt ook gebruikt op de smartphone om naar de speciale navigatie te gaan (zie \ref{sec:evaluatie-gebruik-toestel}).

Standaard is er een tabbalk aanwezig in jQuery Mobile, maar de POC impliceerde een tabbalk die niet de volledige breedte innam.
Daarom werd gekozen voor \code{fieldset} met twee opties.

De kleur van de knoppen aanpassen kan op twee manieren. 
Ofwel wordt dit gedaan met CSS-code ofwel wordt gebruik gemaakt van ThemeRoller~\cite{JQuery2012c}. 
Deze laatste manier werd gebruikt om de knoppen groen te maken. 
Men sleept dan eenvoudigweg in die webinterface de groene kleur op de knop en daarna kan de bijhorende CSS-code worden gedownload. 
Door daarna de knop te annoteren met het \code{data-theme}-attribuut wordt het betreffende thema geactiveerd. 
Om de knop blauw te maken was er geen nood aan een aanpassing, doordat blauw al één van de standaard thema's (\term{swatch} \code{b}) was en kon deze direct worden gebruikt.

\paragraph{\lungo}
Het tonen van kop- en voettekst gebeurt door de verschillende schermen van de applicatie te omvatten door \code{<article>}-tags en daarbinnen de \code{<header>}- en \code{<footer>}-tag te gebruiken.
Deze drie tags zijn nieuw in HTML5.
In de voettekst kunnen door CSS-regels de twee logo's links en rechts uitgelijnd worden.
De onderkoptekst werd met een omweg bekomen door een lijst te maken met slechts één lijstitem.

Het maken van een tabbar is standaard aanwezig in \lungo{}.
Deze wordt bekomen door een \code{<nav>}-tag te annoteren met de \code{groupbar}-klasse.
In de \code{<nav>}-tag worden de links naar de verschillende tabbladen gemaakt door middel van \code{<a>}-tags.
De tabbar wordt getoond over de volledige breedte en komt onmiddellijk onder de koptekst en dus boven de onderkoptekst.
Dit in tegenstelling tot het gevraagde in de POC waar de tabbar onder de onderkoptekst diende te komen.

Het veranderen van de kleur van knoppen gebeurt in CSS waarbij de achtergrondkleur van de knop eenvoudig kan worden aangepast.

%%%%%%%%%%%%%

\subsection{\uit{toestel}}
\label{sec:evaluatie-gebruik-toestel}

In tabel \ref{tabel:evaluatie-gebruik-toestel} worden de resultaten getoond van de drie deeluitdagingen van \uit{toestel}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/toestel.csv}
\caption{Gebruik van \uit{toestel} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-toestel}
\end{table}

\paragraph{\st}
\st{} ondersteunt het herkennen van de context waarin de applicatie wordt gebruikt.
\st{} kan zowel besturingssysteem, browser als ondersteunde (HTML5-)kenmerken opvragen en herkennen.
Het besturingssysteem kan bevraagd worden via \code{Ext.os.name}.
Deze methode herkent onder andere Android, iOS, Windows en BlackBerry.
Er kan ook gebruik worden gemaakt van de \term{singleton} klasse \code{Ext.os.is}.
Zo geeft \code{Ext.os.is.Android} terug of Android het gebruikte besturingssysteem is of niet.
Het opvragen en herkennen van browser en (HTML5-)kenmerken gebeurt op een analoge manier.


\st{} voorziet vijf lay-outs die aan een component kunnen worden toegekend:
\begin{description}
 \item [\code{HBox}] plaatst de componenten horizontaal naast elkaar.
 \item [\code{VBox}] plaatst de componenten verticaal onder elkaar.
 \item [\code{Card}] plaatst de componenten boven elkaar.
 \item [\code{Fit}] maakt de component passend voor zijn ouder container.
 \item [\code{Docking}] maakt het plaatsen van extra componenten mogelijk in de top-, rechter-, bodem- of linkerrand van zijn ouder container.
\end{description}
De creatie van de tablet lay-out steunt op de \code{HBox} lay-out.
De \code{flex} eigenschap van deze lay-out definieert de ratio van de groottes van beide componenten.
De creatie van de smartphone lay-out maakt het menu in de linkse component van de lay-out onzichtbaar.
Om naar het menu terug te keren moet een extra knop in de hoofdtekst worden toegevoegd die naar het menu navigeert.
\st{} ondersteund geen klikbare hoofdteksten die deze functionaliteit toelaten.

\paragraph{\kendo}
De methodes die \code{Kendo.support} aanbiedt, kunnen de context waarin de applicatie wordt uitgevoerd, opvragen.
Een onderscheid maken tussen smartphone of tablet kan met \code{kendo.support.tablet}.

De lay-out van de tablet is mogelijk met een \code{splitview}.
Deze \code{view} is specifiek voor tablets en kan het scherm horizontaal of verticaal opdelen.
Een \code{splitview} moet als waarde bij het data-attribuut \code{data-role} worden toegekend.
De verschillende schermen binnen een \code{splitview} moeten als \code{pane} worden geannoteerd.
Het scherm van de \code{splitview} dat moet wijzigen bij het aanklikken van een knop, moet met het \code{data-target} attribuut bij de kop worden gedefinieerd.

De tablet lay-out wordt als standaard gebruikt.
Om de smartphone lay-out te verkrijgen moeten drie aanpassingen gebeuren.
Beide \code{panes} van de \code{splitview} moeten als apparte \code{view} worden toegevoegd ter vervanging van de \code{splitview}.
Ook moeten de \code{data-target} attributen worden verwijderd.
Ten slotte moet de hoofdtekst linken naar het menu in de schermen voor het toevoegen van een uitgave.

%TODO layout als data-role bespreken?

% Dit zijn de mogelijkheden:
% \begin{description}
%   \item [\code{touch}] geeft terug of de browser \term{touch} gebeurtenissen ondersteund.
%   \item [\code{pointers}] geeft terug of de browser \code{pointer} gebeurtenissen ondersteund.
%   \item [\code{scrollbar}] geeft de breedte van de \code{scrollbar} terug in pixels.
%   \item [\code{hasHW3D}] geeft terug of de browser 3D-ondersteuning biedt voor transities en transformaties.
%   \item [\code{hasNativeScrolling}] geeft terug of de browser deze CSS-eigenschap ondersteund.
%   \item [\code{devicePixelRatio}] geeft het huidige pixel ratio terug (Android).
%   \item [\code{placeHolder}] geeft terug of de browser invoer placeholders ondersteund.
%   \item [\code{zoomLevel}] geeft het huidige zoom niveau terug van de browser.
% \end{description}

\paragraph{\jqm}
Het raamwerk biedt zelf geen functies aan om te herkennen of het toestel een smartphone of tablet is.
In \jqm{} is er ook geen functionaliteit aanwezig om een menu te tonen voor tablets, maar niet voor smartphones. 
Eerst werd gezocht naar plug-ins aan de hand van een blogpost~\cite{Deering2012}, wat leidde tot: Splitview~\cite{Rahman2013}, SimpleSplitView~\cite{Yared2013} en Multiview~\cite{Franck2012}. 
Deze drie mogelijke kanshebbers hadden elk hun tekorten. 
Zo was de eerste destructief ten opzichte van het raamwerk. 
Dit betekent dat de bestanden van het raamwerk zelf werden aangepast, wat het moeilijker maakt als er moeten worden geüpdatet naar een nieuwe versie. 
De tweede plug-in werkte enkel tot versie 1.0.1 van \jqm{}. 
De laatste plug-in had moeite met het zich aanpassen aan veranderende afmetingen van de browser. 

Uiteindelijk werd van een plug-in afgestapt doordat werd aangetoond hoe via CSS3 media queries hetzelfde kon worden bereikt~\cite{Hadlock2012}. 
Ook uit de documentatie van versie 1.3 \cite{JQuery2013e} blijkt dat dit de correcte manier is om hiermee om te gaan.
Daarnaast wordt op de documentatiesite van \jqm{}~1.2 al een gelijkaardige lay-out gebruikt~\cite{JQuery2012b}. 
De uiteindelijke oplossing voor het probleem kwam voort uit het idee van CSS3 media queries en de documentatiesite van \jqm{}~1.2.
Bij CSS3 media queries moet zelf een breekpunt (uitgedrukt in pixels) worden opgegeven wanneer dient geschakeld te worden tussen smartphonelay-out of tabletlay-out.

Het smartphonemenu is altijd geactiveerd en kan ook worden gebruikt als de applicatie op een tablet wordt gebruikt.

\paragraph{\lungo}
Het raamwerk zelf biedt de functie \code{Lungo.Core.isMobile()} aan om te weten of het huidige apparaat een mobiel apparaat is.
QuoJS biedt daarnaast ook nog \code{browser}, \code{os.name}, \code{os.name}, \code{env.os.version} en \code{screen} aan.
Deze laatste geeft de breedte en hoogte terug.
Dit betekent dat de ontwikkelaar nog altijd zelf instaat voor de bepaling of het een smartphone of tablet is.
Als oplossing werd gebruik gemaakt van CSS3 media queries, met dezelfde aanpak als \jqm{}.
Het smartphonemenu is altijd geactiveerd en kan ook worden gebruikt als de applicatie op een tablet wordt gebruikt.

%%%%%%%%%%%%%

\subsection{\uit{laadscherm}} 
\label{sec:evaluatie-gebruik-laadscherm}

In tabel \ref{tabel:evaluatie-gebruik-laadscherm} worden de resultaten getoond van de twee deeluitdagingen van \uit{laadscherm}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/laadscherm.csv}
\caption{Gebruik van \uit{laadscherm} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-laadscherm}
\end{table}

\paragraph{\st}
Een laadscherm tonen kan door een masker met xtype \code{loadmask} op de huidige \code{view} te plaatsen.
Een object van dit xtype kan een bericht bevatten wat de laadtekst voorstelt.
Het toten van een masker kan door de \code{setMasked} methode op een \code{view} op te roepen.
Een courante aanpak is te werken met de \term{singleton} klasse \code{Ext.Viewport} die de huidige zichtbare \code{view} voorsteld.
Hierop de \code{setMasked} methode oproepen verzekert dat het laadscherm bovenop alle andere schermen wordt geplaatst.

De \code{Ext.Msg} \term{singleton} klasse bevat alle methoden om dialogen weer te geven.
\st{} biedt drie standaarden van dialogen aan: \code{alert}, \code{promt} en \code{confirm}.
De eerste laat de gebruiker een bericht zien,  de tweede vraagt de gebruiker om invoer en de laatste vraagt bevestiging aan de gebruiker.
Deze drie standaarden zijn als methode in \code{Ext.Msg} beschikbaar.
Parameters van de methoden kunnen de titel, tekst en functie van de knoppen bepalen.
Een meer generieke aanpak is het oproepen van de \code{show} methode van \code{Ext.Msg}.
Intern roepen de standaard dialogen deze methode ook op.

\paragraph{\kendo}
%laadscherm
Een \code{Application} object wordt na initialisatie van een \kendo{} applicatie aangemaakt.
Hierop kunnen de \code{showLoading} en \code{hideLoading} methoden worden opgeroepen om de animatie van het laadscherm te tonen of te verbergen.

%dialoogvenster
Een dialoogvenster wordt in \kendo{} \code{ModelView} genoemd (niet te verwarren met het \code{viewModel} van de MVVM-architectuur).
Het attribuut \code{data-role} moet \code{modelview} als waarde hebben om een HTML-fragment als dialoogvenster te definiëren.
Dit fragment kan hoofd- en/of voetteksten bevatten.
Het is mogelijk het \code{ModelView} in \js{} te selecteren met \code{\$("\#id").data("kendoMobileModalView")}.
%todo waarbij id voor de id van het modelview staat?
Openen van het venster kan in \js{} met de \code{open} methode of in HTML door te linken naar het \code{modelview} en het \code{data-rel} attribuut aan \code{modelview} gelijk te stellen.

\paragraph{\jqm}
Het standaard laadscherm is enkel een \term{spinner} die ronddraait, die niet opvallend aanwezig is en zonder tekst eronder.
Door de opties in de API te gebruiken, komt de \term{spinner} duidelijk naar voor door een zwarte achtergrond en kan er ook een tekst worden ondergezet.

De laadschermen werden in combinatie met de AJAX-oproepen gebruikt.
Bij de AJAX-oproep wordt de functie \code{beforeSend} voor de oproep opgeroepen en de functie \code{complete} na de oproep.
Dit zijn dus de ideale plaatsen om respectievelijk de laadschermen te tonen en te verbergen.
Indien de AJAX-oproepen in een ketting worden geplaatst, lukt deze aanpak niet meer.
De \code{complete}-functie van de eerste AJAX-oproep zal pas opgeroepen worden als de laatste AJAX-oproep klaar is.
Hierdoor zal gedurende de ketting van AJAX-oproepen, alleen het eerste laadscherm zichtbaar zijn en zullen de andere nooit worden getoond.
Een oplossing hiervoor is om het verbergen van het laadscherm uit de \code{complete}-oproep te halen en deze in zowel in de \code{succes}-functie als de \code{error}-functie te plaatsen.

Om gemakkelijk dialoogvensters te tonen, werd eerst gebruik gemaakt van DateBox~\cite{Sage2013} als plug-in.
Uiteindelijk bleek de plug-in niet zo gemakkelijk aanpasbaar en daarenboven zijn dialoogvensters standaard in \jqm{} aanwezig.
Het is dan ook helemaal niet nodig om hiervoor een plug-in te gebruiken.
Door zelf het dialoogvenster met \jqm{} aan te maken, kon de lay-out gemakkelijker worden aangepast.

\paragraph{\lungo}
Een laadscherm of dialoogvenster tonen gebeurt met eenzelfde functie die wordt aangeboden door het raamwerk, namelijk: \code{Lungo.Notification.show()}.
Indien er geen parameters worden meegegeven, zal een laadscherm getoond worden.

Het laadscherm wordt in samenwerking met de AJAX-oproepen gebruikt.
Net voor de AJAX-oproep zal het laadscherm worden getoond en in de \term{callback} van de AJAX-oproep zal het worden verborgen.
Er treedt zich echter een probleem op wanneer deze manier gebruikt wordt in een ketting van AJAX-oproepen.
Volgens de documentatie verbergt de functie \code{Lungo.Notification.hide()} het huidige laadscherm of dialoogvenster. 
Uit ervaring blijkt dat wanneer eerst een laadscherm wordt getoond, daarna wordt verborgen en daarna een dialoogvenster wordt getoond, het dialoogvenster niet verschijnt verborgen.
Dit betekent dus dat de verbergfunctie ervoor zorgt dat het dialoogvenster niet wordt getoond.
Een oplossing hiervoor is om bij een ketting van vensters, nooit de vensters tussenin te sluiten.
Wanneer zowel een laadscherm als dialoogvenster worden geopend, zal enkel dat laatste getoond worden.

Om een dialoogvenster te tonen, worden de volgende parameters meegegeven: titel, omschrijving, tijd op het scherm en de \term{callback} functie.
Indien er beslist wordt om geen tijd op te geven, kan het venster worden gesloten met \code{Lungo.Notification.hide()}.
Daarnaast worden er ook specifieke dialoogvensters aangeboden om een succes- of foutmelding te tonen.
Deze zullen respectievelijk een groene en rode kleur hebben.


%%%%%%%%%%%%%

%TODO: controleren of iedereen iets over dat optieveld en die schakelaar heeft geschreven
\subsection{\uit{formulieren}}
\label{sec:evaluatie-gebruik-formulieren}

In tabel \ref{tabel:evaluatie-gebruik-formulieren} worden de resultaten getoond van de zeven deeluitdaging van \uit{formulieren}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/formulieren.csv}
\caption{Gebruik van \uit{formulieren} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-formulieren}
\end{table}

\paragraph{\st} 
% Placeholders, text, email and number fields are supported by the framework and can be easily created.  
% Labels can be avoided by not defining them.  
% Creating custom datepickers is not supported.  
% It is impossible to ignore the days field and only years can be delimited.  
% Clearing the form after it was send, has to be programmed manually.
Een formulier wordt in \st{} \code{fielset} genoemd.
Een \code{view} van een formulier voorzien kan door in de rij van elementen een object met \code{xtype} \code{fieldset} te maken.
Dit object kan op zijn beurt voorzien worden van een rij van elementen.
Volgende velden worden aangeboden in \st{}:
\begin{itemize}
  \item \code{textfield}        Ext.field.Text
  \item \code{numberfield}      Ext.field.Number
  \item \code{emailfield}	 Ext.field.Email			
  \item \code{textareafield}    Ext.field.TextArea
  \item \code{hiddenfield}      Ext.field.Hidden
  \item \code{radiofield}       Ext.field.Radio
  \item \code{checkboxfield}    Ext.field.Checkbox
  \item \code{selectfield}      Ext.field.Select	
  \item \code{togglefield}      Ext.field.Toggle
  \item \code{fieldset}         Ext.form.FieldSet
\end{itemize}

Tekst-, email en nummervelden worden bij het renderen tot HTML5-invoertypes omgevormd en bijgevolg worden op mobiele toestellen bijhorende virtuele toetsenborden weergegeven.
Een placeholder toevoegen kan door een veld met \code{placeholder} eigenschap te voorzien en de waarde aan de gewenste placeholder gelijk te stellen. 
Een label toevoegen verloopt analoog,  deze weglaten zal geen label renderen.

Een aangepaste \term{datepicker} maken is niet standaard voorzien.
Een standaard \term{datepicker} is echter wel voorzien met \code{datepicker} als xtype.
Deze kan enkel geconfigureerd worden door een begin- en eindjaar in te stellen.
Een \term{datepicker} maken waarbij het bereik kleiner is dan een jaar, is niet mogelijk.
Ook is het onmogelijk om enkel een maand- en jaarveld te tonen.

%TODO challenge bekijken (enkel reset oproepen normaal ok )
Het leegmaken van een formulier gebeurt niet automatisch wanneer het verzonden wordt.
Hiervoor moet de \code{reset} methode op het bijhorende \code{formpanel} worden opgeroepen.

\paragraph{\kendo}
 Formulierelementen definiëren kan via data-attributen door gebruik te maken van de opmaakgedreven aanpak van \kendo.
 Deze methodologie volgt dus sterk de HTML5-standaard.
 Het placeholder attribuut kan een placeholder definiëren,  het vermijden van een label zal geen labels genereren.
 Het type van het formulierelement moet met het type attribuut worden weergegeven.
 Volgende types worden door \kendo{} ondersteund:
 \begin{itemize}
  \item \code{text}
  \item \code{password}
  \item \code{search}
  \item \code{url}
  \item \code{email}
  \item \code{number}
  \item \code{tel}
  \item \code{file} (niet in iOS)
  \item \code{date}
  \item \code{timemonth} 
  \item \code{datetime}
 \end{itemize}

 \term{Datepickers} worden als widget aangeboden in het Web luik van \kendo{}.
 Het raamwerk zal een invoerelement omvormen naar een \code{kendoDatePicker}.
 Het invoerelement ziet er als volgt uit: \code{<input id=\"datepicker\"\/>}.  
 Vervolgens moet het element worden geïnitialiseerd met \code{\$("\#datePicker").kendoDatePicker()}.
 De datepicker is aanpasbaar zoals gevraagd in de POC.
 Het bereik van de data selectie kan worden ingeperkt door de \code{min} en \code{max} eigenschap van de \code{kendoDatePicker} te zetten.
 Deze eigenschappen worden bij initialisatie van het object meegegeven.
 Enkel maand- en jaarvelden tonen kan door de diepte van de \term{datepicker} in te stellen.
 Hiervoor moet de eigenschap \code{depth} aan \code{year} worden gelijkgesteld.
 
 Het wissen van formulieren steunt op de MVVM-architectuur.
 Een fomulier is gebonden aan een \code{(view)model}:  de inhoud van elk formulierelement komt overeen met de waarde van een eigenschap van een \code{(view)model} met dezelfde naam.
 Wanneer een uitgave wordt verzonden, zal de huidige waarde van het \code{(view)model} in een \js-object worden opgeslagen en wordt het \code{(view)model} gereset.
 Door de dubbele binding tussen formulier en \code{(view)model} zal ook de inhoud van de formulierelementen worden gewist.
 
\paragraph{\jqm} 
Voor het toevoegen van \term{placeholders} in de formuliervelden kon beroep worden gedaan op het \code{placeholder}-attribuut in HTML5. 
Labels zijn verplicht in \jqm{}, maar kunnen onzichtbaar worden gemaakt met de CSS-klasse \code{ui-hide-label}~\cite{JQuery2013}. 
Wat wel opmerkelijk is wanneer een formulier wordt ingevuld, daarna verstuurd en dan wordt teruggegaan, het formulier nog alle waarden bevat. 
Men moet na het formulier te hebben verstuurd, zelf het formulier altijd leegmaken. 
Dit kan met behulp van \js{} via de \code{reset()}-functie op het formulier.
 
Voor de types van de formuliervelden werd beroep gedaan op de volgende types: \code{text}, \code{number} en \code{email}. 
%Deze zorgen ervoor dat op de mobiele apparaten aangepaste toetsenborden te voorschijn komen. 
Het \code{date} type werd echter niet gebruikt om wille van twee redenen.
Ten eerste was hiervoor een slechte ondersteuning naar mobiele browsers toe~\cite{Deveria2013b}.
Android~2.3 ondersteunt dit niet en de \term{placeholder}-tekst in het veld ontbrak op iOS~6 en Android~4.2.
Hierdoor weet de gebruiker in eerste instantie niet wat hij hier moet invullen. 
Zelf een \term{placeholder} instellen is onmogelijk voor een \code{date}-type~\cite{Berjon2012}. 
Een tweede probleem was het opleggen van het bereik van datums, wat met het \code{date}-type onmogelijk is. 
Beide problemen werden opgelost door gebruik te maken van de Date \& Time Picker van Mobiscroll~\cite{Mobiscroll2013} die ook aangepaste lay-out heeft conform met die van \jqm{}. 
Het veld heeft dan wel het type \code{text}.
Het is dus in principe mogelijk om iets anders dan een datum in te geven. 
Dit wordt belet door ook nog eens een datumvalidatie (zie \ref{sec:evaluatie-gebruik-validatie}) te doen op dit tekstveld mocht de plug-in het niet hebben afgedwongen.
 
Het was ook nodig om enkel de maand en jaar in te geven als datum, dus zonder dag.
Ook hier kon niet het \code{date}-type gebruikt worden, omdat daar ook een dag voor nodig is. 
Daardoor werden de maanden handmatig geprogrammeerd als vaste lijstitems. 
De jaren zijn dynamisch en zijn telkens dit jaar, het volgende en het vorige jaar. 
Deze functionaliteit kon ook met de plug-in van Mobiscroll worden verwezenlijkt.

Als laatste werd zowel het optieveld als de schakelaar door \jqm{} zelf aangeboden en konden direct gebruikt worden. 
 
\paragraph{\lungo} 
Het toevoegen van \term{placeholders} in de formuliervelden gebeurt met het HTML5-atttribuut \code{placeholder}.
In \lungo{} zijn labels niet verplicht.
Indien deze niet gewenst zijn, kunnen deze gewoon uit de HMTL5-code weggelaten worden.

De types \code{text}, \code{number} en \code{email} voor formuliervelden worden verwezenlijkt door deze als type voor de \code{input}-tags mee te geven in het formulier.
Gelijkaardig met de twee aangehaalde problemen voor \jqm{}, werd niet gekozen voor het \code{date}-type, maar een plug-in om de functionaliteit met datums op te lossen.
De \code{date-picker} werd gebruikt van de plug-in pagina van Lungo zelf~\cite{TapQuo2013b}.
Bij deze plug-in is al voorbeeldcode aanwezig die nodig is om automatisch een \term{datepicker} te openen en de aangeklikte datum in het formulierveld te zetten.
De plug-in laat echter niet toe om een bereik op te geven.
De datum met enkel een maand en jaar diende handmatig geprogrammeerd te worden omdat de aangeboden plug-in hiervoor geen ondersteuning bood.

Een optieveld werd niet aangeboden door \lungo{} en werd vervangen door een \term{dropdown}menu. 
Een schakelaar daarentegen werd dan weer wel aangeboden.
Het legen van een formulier gebeurt in \lungo{} door de \code{reset}-functie in \js{} op te roepen op dat formulier.

%%%%%%%%%%%%%

\subsection{\uit{vullen}}
\label{sec:evaluatie-gebruik-vullen}

In tabel \ref{tabel:evaluatie-gebruik-vullen} worden de resultaten getoond van de twee deeluitdaging van \uit{vullen}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/vullen.csv}
\caption{Gebruik van \uit{vullen} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-vullen}
\end{table}

\paragraph{\st}
Het invullen van een formulier wordt ondersteund door de MVC-architectuur.
Twee verschillende methoden worden in de POC gebruikt.
Een eerste maakt gebruik van de \code{setRecord} methode van een \code{formpanel}.
De modelinstantie die het formulier zal invullen als parameter worden meegeven.
\st{} zal automatisch de velden invullen waarbij de naam gelijk is aan de eigenschap van het model.
Zo kan tekst op tekstvelden worden gemapt,  nummers op numerieke velden en \code{booleans} op \code{togglefields}.
Een opmerking over het invullen van een \code{radiofield} moet worden gemaakt.
Een model kan worden voorzien met eigenschappen met volgende types:
\begin{itemize}
  \item auto (Default, implies no conversion)
  \item string
  \item int
  \item float
  \item boolean
  \item date
\end{itemize}
Er bestaat dus geen vlekkeloze mapping tussen een eigenschap van een model en een \code{radiofield}.
Hetzelfde geldt voor een \code{checkboxfield}.
Om deze in te vullen moet de \code{setGroupValue} van het veld worden aangesproken.


%TODO u13 lijsten en click invullen van formulier,  hier ook...
De tweede methode voor het invullen van formulieren maakt gebruikt van een \code{navigationview} en wordt in \uit{lijsten}.

Velden read-only maken kan door objecten te voozien van de \code{readOnly} eigenschap en de waarde op \code{true} te zetten.
Bij \code{radiofields} en \code{checkboxfields} heet deze eigenschap \code{disabled}.


\paragraph{\kendo}
Het invullen van een formulier steunt ook op de MVVM-architectuur en is gelijkaardig aan het resetten van een formulier.
De dubbele binding tussen een formulier en \code{(view)model} wordt met de HTML-tag \code{data-model} aangegeven.
Een \code{viewmodel} wordt in \kendo{} \code{ObservableObject} genoemd.
Een \code{model} heet \code{Model} en erft over van een \code{ObservableObject}.
Deze laatste breidt een \code{ObservableObject} uit met de mogelijkheid om schema's,  velden en methoden te definiëren.  
In wat volgt zal aangenomen worden dat een \code{ObservableObject} wordt gebruikt in plaats van een \code{Model},  tenzij anders vermeld.
Om een formulier met data te vullen is het de taak van de programmeur de velden van het \code{ObservableObject} van de correct waarden te voorzien.
De gebonden formulierelementen zullen vervolgens automatisch worden ingevuld.


Read-only velden moeten in het data-attribuut van het formulierelement worden gespecificeerd.
Alle invoer types buiten radio- en selectknoppen gebruiken hiervoor het \code{readOnly} sleutelwoord.
Radio- en selectknoppen worden onbeschikbaar met het \code{disabled} sleutelwoord.

\paragraph{\jqm}
Om een formulierveld in te vullen met data, dient eerst het formulierveld gezocht te worden en daarna zijn waarde gezet te worden.
Dit gebeurt typisch voor velden van het type \code{input} en \code{textarea} volgens de volgende code: \code{\$("\#form-veld").val("waarde")}.
Bij het \code{select}-type voor een veld kan deze code niet worden gebruik.
Hier moet de waarde worden gezocht in de lijst en dan aan de gevonden waarde het \code{selected}-attribuut worden toegevoegd.
Een gelijkaardige manier dient gevolgd te worden voor het \code{radio}-type voor een veld.
Ook hier moet eerst de waarde worden gezocht, waarna aan de gevonden waarde het \code{checked}-attribuut wordt toegevoegd.
Het vullen van formuliervelden wordt niet door \jqm{} geautomatiseerd, wat betekent dat dit dus voor iedere formulierveld dient te gebeuren.

Het \term{read-only} maken van velden gebeurt via het HTML-attribuut \code{readonly}.
Dit geld voor alle types van velden, behalve voor \code{radio}-elementen en \code{select}-items waar \code{disabled} wordt gebruikt.
Voor \code{select}-items moeten de andere niet-benodigde lijstitems verwijderd worden, want deze kunnen nog steeds aangeklikt worden.

\paragraph{\lungo}
Velden vullen met data dient handmatig te gebeuren door eerst het formulierveld op te zoeken en daarna de waarde te zetten.
Dit gebeurt typisch volgens de volgende code: \code{\$\$("\#form-veld").val("waarde")}.
Deze functie kan ook gebruikt worden voor \code{select}-types.
Geoptimaliseerde mobiele lay-out voor \code{radio}-types is niet aanwezig in \lungo.
Een opmerking dient wel gemaakt te worden dat de waarde altijd een \code{string} moet zijn.
Dit betekent dus voor getallen dat deze altijd eerst moeten worden omgevormd met de \js{}-functie \code{toString()}. 

Het \term{read-only} maken van velden gebeurt via het HTML-attribuut \code{readonly}.
Dit gaat voor alle types van velden, behalve voor \code{select}-types.
Daar worden de niet-benodigde lijstitems verwijderd en wordt de \code{select} zelf \code{disabled} gemaakt.

%%%%%%%%%%%%%

\subsection{\uit{autoaanvullen}}
\label{sec:evaluatie-gebruik-autoaanvullen}

In tabel \ref{tabel:evaluatie-gebruik-autoaanvullen} worden de resultaten getoond van de twee deeluitdagingen van \uit{autoaanvullen}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/autoaanvullen.csv}
\caption{Gebruik van \uit{autoaanvullen} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-autoaanvullen}
\end{table}

\paragraph{\st}
Het automatisch aanvullen van een formulierelement steunt op een plug-in van Tajur~\cite{Tajur2012}.
Deze plug-in is niet op de Sencha Market terug te vinden.
Door het \js-bestand toe te voegen wordt het xtype \code{autocompletefield} beschikbaar.
Een object met dit xtype kan een \code{proxy} definiëren die de server kan aanspreken om suggesties asynchroon op te halen.
Ook is het mogelijk het maximaal aantal suggesties vast te leggen.

De \term{backend} server die bij de POC hoort geeft bij een bepaald sleutelwoord suggesties in een JSON-rij terug.
De rij is voorzien van een sleutel maar alle elementen van de rij hebben geen sleutel.
\st{} voorziet vier methoden om de resultaten van een \code{proxy} te parsen naar modelinstanties:
\begin{description}
 \item [\code{JsonReader}] parst JSON-sleutels naar model velden.
 \item [\code{XmlReader}] parst XML-tags naar model velden.
 \item [\code{ArrayReader}] mapt elementen van een rij op velden van een model.
\end{description}
Geen van voorgaande methoden was in staat de rij met suggesties te parsen van rij-element naar modelinstantie.
Hierdoor kon geen klikbare dropdownmenu worden getoond.

\paragraph{\kendo}
Het automatisch aanvullen van een formulierelement wordt als widget door \kendo{} Web aangeboden.
Een HTML-invoerelement met id met worden aangemaakt en geinitialiseerd met \code{\$("\#id").kendoAutoComplete()}.
Elementen die automatisch aanvullen kunnen zowel van een lokale als externe bron worden aangeleverd.
Externe suggesties moeten via een \code{dataSource} worden ingeladen.
Een \code{DataSource} ondersteunt alle CRUD (\term{Create, Read, Update en Delete}) operaties en het sorteren, pagineren, filteren, groeperen en aggregeren van data.
Deze moet geconfigureerd worden om suggesties van de \term{backend} op te halen.
Buiten een \code{DataSource} kan het minimale aantal suggesties en een filter worden opgegeven.
De filter bepaalt de methode om suggesties op te halen:  en kan \code{startswith}, \code{endswith} of \code{contains} zijn.

\paragraph{\jqm}
Indien er wordt gebruik gemaakt van versie~1.2 is een plug-in nodig om auto-aanvulling te bekomen.
Hiervoor kan de plug-in van Andy Matthews worden gebruikt~\cite{Matthews2013}. 
Dit is een zeer gemakkelijk te integreren plug-in die zowel met lokale data als data op afstand kan werken.
Sinds versie~1.3 voorziet \jqm{} deze functionaliteit zelf~\cite{JQuery2013c}.
Er wordt aangehaakt op het \code{listviewbeforefilter}-\term{event} waarbij een eigen filterfunctie geschreven kan worden.
De voorbeeldcode op de site kon integraal worden gebruikt. 

\paragraph{\lungo}
Standaard biedt \lungo{} geen auto-aanvullig aan, maar wel op zijn site van plug-ins~\cite{TapQuo2013b}.
Daar werd de plug-in AutoComplete gebruikt.
De voorbeeldcode maakt het gemakkelijk om onmiddellijk een werkend voorbeeld van de plug-in te hebben.
Veel code kon dus gewoon worden overgenomen om een werkende auto-aanvulling te bekomen.
Er diende nog één extra CSS-regel te worden toegevoegd om de bollen voor de suggesties te verwijderen.

%%%%%%%%%%%%%

\subsection{\uit{afbeelding}}
\label{sec:evaluatie-gebruik-afbeelding}

In tabel \ref{tabel:evaluatie-gebruik-afbeelding} worden de resultaten getoond van de drie deeluitdagingen van \uit{afbeelding}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/afbeelding.csv}
\caption{Gebruik van \uit{afbeelding} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-afbeelding}
\end{table}

\paragraph{\st}
Het opladen van een afbeelding steunt op een plug-in van Smirnov~\cite{Smirnov2012} en kan in de Sencha Market gevonden worden op \exturl{market.sencha.com/extensions/file-uploading-component-for-sencha-touch}.
De plug-in is generiek voor het opladen van elk type bestand,  niet uitsluitend afbeeldingen.
Het \js-bestand moet in de touch/src/ux folder worden geplaatst en de \code{Ext.ux.Fileup} klasse moet worden geïnitialiseerd.
Het xtype \code{img} wordt dan beschikbaar voor \st{} componenten.

De plug-in voorziet twee modes voor het opladen van bestanden: lokale als base64 of extern naar een server.
De eerste laat toe afbeeldingen in het DOM of \term{local storage} te laden.
Dit laatste is een aspect van de POC.

Nadat een bestand is opgeladen kunnen twee gebeurtenissen zich voordoen:  \code{loadsuccess} of \code{loadfailure}.
Het is de taak van een \code{controller} om deze gebeurtenissen op te vangen en een bijhorende methode te definiëren.
De succes functie krijgt de base64 text mee en kan een voorbeeld van de afbeelding laten weergeven.

\paragraph{\kendo}
\kendo{} Web biedt een widget aan die het opladen van bestanden toelaat.
Deze widget kan in twee modes worden gebruikt: syncroon of asynchroon.
Een HTML-invoerelement met \code{id} moet worden toegevoegd en geïnitialiseerd met \code{\$("\#id").kendoUpload()}.
In synchrone wordt het formulier met het oplaadelement verzonden naar de \term{backend} als een uitgave wordt toegevoegd.
In asynchrone mode gebeurt het opladen meteen na het selecteren van de afbeelding.
Deze methode voor het opladen van bestanden steunt op de HTML5 File API.
Het verzoek naar de \term{backend} is een POST-verzoek met \code{Content Type} \code{multipart/form-data}.
Omdat een voorbeeld van afbeelding werd gevraagd, is de asynchrone oplossing gekozen.	
\kendo{} voorziet \term{backend} integratie met ASP.NET MVC,  JSP en PHP.
Voor deze drie technologieën is een implementatie beschikbaar om het opladen van bestanden aan serverzijde af te handelen.
Er werd gekozen om de PHP-implementatie te gebruiken.
Wanneer een afbeelding succesvol is opgeladen, wordt de \code{success callback} opgeroepen met het bestand als parameter.
Het bestand wordt met een \code{FileReader} gelezen,  aan een \code{canvas} toegevoegd en naar base64 omgezet met de \code{toDataURL} methode.
Deze werkwijze is aanloog aan de \jqm{} implementatie.

\paragraph{\jqm}
Het toevoegen van een afbeelding gebeurt door \code{file} als invoertype van het formulierveld te gebruiken. 
In versie~1.2 wordt dit veld nog niet opgemaakt met lay-out, maar dit gebeurt wel in versie 1.3~\cite{JQuery2013d}. 
Het omvormen van de afbeelding naar base64 werd geïmplementeerd met de FileReaderAPI en het canvas, wat beide HTML5-specificaties zijn. 
De aangeklikte afbeelding wordt gelezen door middel van de FileReaderAPI, waarna het tijdelijk als afbeelding wordt opgeslagen en daarna geïmporteerd wordt op het canvas. 
Eenmaal geïmporteerd, kan de functie \code{.toDataURL()} opgeroepen worden op het canvas om de geïmporteerde afbeelding om te vormen naar base64. 

Het voorvertonen van het geüploade afbeelding hangt af van het mobiele besturingssysteem.
Zo wordt op iOS~6 een miniatuurafbeelding getoond, terwijl op Android de bestandsnaam wordt getoond.
Het is natuurlijk ook mogelijk om de preview na conversie zelf te tonen op het scherm.
Bij iOS zouden er dan twee voorvertoningen te zien zijn op hetzelfde scherm.

\paragraph{\lungo}
Een afbeelding kiezen gebeurt door het formulierveld met het type \code{file} toe te voegen.
De methode om een afbeelding om te vormen naar base64 is volledig analoog met die van \jqm{}.

%%%%%%%%%%%%%

\subsection{\uit{validatie}}
\label{sec:evaluatie-gebruik-validatie}

In tabel \ref{tabel:evaluatie-gebruik-validatie} worden de resultaten getoond van de vier deeluitdaging van \uit{validatie}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.


\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/validatie.csv}
\caption{Gebruik van \uit{validatie} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-validatie}
\end{table}

\paragraph{\st}
Een model kan worden voorzien van validatieregels.
Deze regels worden als objecten in een rij aan de \code{validations} eigenschap van een model toegekend.
Volgende validatieregels zijn ingebouwd:
\begin{description}
  \item [presence] verzekert dat het het veld een waarde heeft waarbij nul als geldig wordt beschouwd,  lege tekst niet.
  \item [length] verzekert dat een text een minimale en/of maximale waarde heeft.
  \item [format] verzekert dat een text voldoet aan een opgegeven reguliere expressie.
  \item [inclusion] verzekert dat de waarde van een veld gelijk is aan een element van een gespecifieerde set.
  \item [exclusion] verzekert dat de waarde van een veld zeker niet gelijk is aan een element van een gespecifieerde set.
\end{description}
De controle of een opgegeven waarde een nummer is kan met de \code{format} regel en de \code{/\d+/} reguliere expressie.
Om een bepaalde modelinstantie te valideren moet de \code{validate} methode op de instantie worden opgeroepen.
Om eigen validatieregels toe te laten moet de implementatie van deze methode worden overschreven. \footnote{Informatie gevonden op \exturl{www.sencha.com/forum/showthread.php?122680-Conditional-fields-validations}}
Deze functionaliteit zit dus niet standaard in \st{}.
Met de nieuwe \code{validate} methode kan een \code{validator} aan een validatieregel worden toegevoegd.
Dit is een functie die de programmeur zelf bepaalt en \code{true} of \code{false} teruggeeft bij het al dan niet slagen van een conditie.

Het opbouwen van een foutenboodschap kan door te itereren over de fouten die na validtie werden teruggevonden.
Een specifieke foutenboodschap kan aan elke validatieregel worden toegekend.

Invalide formulierelementen aanduiden met een rode rand wordt niet door \st{} ondersteund.
Hiervoor moet CSS worden gebruikt.
Foutief ingevulde formulierelementen moeten na valiatie met een CSS-klasse worden aangevuld.

\paragraph{\kendo}
%TODO verwijs naar niet support voor HTML5 validatie..
Het \kendo{} raamwerk ondersteunt de validaties zoals aangeboden binnen HTML5:
\begin{itemize}
  \item [required] verzekert dat een het veld een waarde heeft.
  \item [pattern] verzekert dat de waarde van een veld voldoet aan een opgegeven reguliere expressie.
  \item [min/max] verzekert dat de waarde van een veld groter en/of kleiner is dan een opgegeven waarde.
  \item [data types] verzekert dat de waarde van een veld gelijk is aan het opgegeven type (e-mail, url, number, enz.)
\end{itemize}
Deze validaties moeten binnen het data-attribuut van het formulierelement worden aangebracht.

De \kendo{} \code{validator} is compatibel met deze HTML5-validaties.
Een \code{validator} moet in \js worden aangemaakt met volgend commando:  \code{\$("\#myform").kendoValidator().data("kendoValidator")}.
Hierbij kan de jQuery selector eender welk element uit het DOM aanduiden.
De \code{validator} zal geselecteerde invoerelementen controleren op validatieregels.

Eigen condities kunnen als validatieregels worden geformuleerd als \js-functie die \code{true} teruggeeft als de validatie slaagt.
Deze functie kan aan de set van regels van een \code{validator} worden toegevoegd.
De validatiecontrole starten kan door de \code{validate} methode op de \code{validator} op te roepen.
Bij het controleren van invoerelementen worden altijd eerst de standaard validatieregels gecontoleerd,  daarna de eigen validatieregels.
De volgorde waarin de controles worden uitgevoerd ligt vast en zal stoppen zodra één controle mislukt.

%TODO mijn tricky implementatie van other -> remkars validatie vermelden?

Validatieberichten kunnen voor standaard validaties door het raamwerk zelf worden opgebouwd.
Deze kunnen worden overschreven door zelf een data-attribuut \code{validationMessage} aan het invoerelement toe te kennen.
Bij eigen validatieregels kan een validatiebericht per regel worden gespecificeerd.

Invalide formulierelementen aanduiden met een rode rand wordt niet door \kendo{} ondersteund.
De standaard implementatie voorziet een \code{tooltip} per invalied veld.
Deze zal het validatiebericht naast het invalide formulierelement plaatsen. 

Een venster tonen waarbij alle foutenboodschappen zijn samengevat is ook niet standaard aanwezig.
De \code{errors} methode van een \code{validator} geeft een rij van foutenboodschappen terug.
De volledige foutenboodschap moet vervolgens worden geconstrueerd door alle foutenboodschappen te concateneren.
Hoe een dialoogvenster gemaakt wordt zal in \uit{dialoog} worden besproken.

\paragraph{\jqm}
Validatie is niet standaard aanwezig in jQuery Mobile. 
Eerst werd geprobeerd om de verplichte velden te voorzien van het \code{required}-attribuut in HTML5. 
Dit werd niet gedaan om twee redenen.
Enerzijds is hiervoor geen ondersteuning voor mobiele browsers~\cite{Deveria2013}. 
Anderzijds is het ook nodig om de velden te valideren op hun waarde.
Als oplossing werd de plug-in van Jörn Zaefferer gebruikt~\cite{Zaefferer2013}. 
Deze lost beide problemen op.
De plug-in zelf kan op twee manieren gebruikt worden: enerzijds annoteren van de formuliervelden met speciale CSS-klassen in de HTML-code ofwel anderzijds door programmatie met \js{}. 
Beide aanpakken werden getest en slaagden. 

De plug-in bevat de volgende ingebakken validatieregels die nodig waren: \code{required}, \code{number}, \code{email} en \code{date}.
Daarnaast was het nodig dat een veld verplicht was enkel indien een bepaalde optie aangevinkt was.
Zo een afhankelijkheidsrelatie is standaard aanwezig in de plug-in.

De plug-in toont standaard een foutboodschap onder het foute formulierveld.
Door de uitgebreide API van de plug-in die ook uitvoerig gedocumenteerd is, konden alle foutboodschappen samen in een dialoogvenster worden weergegeven.

Een specifiek mobiel probleem was dat bij het tonen van het dialoogvenster, de plug-in op de achtergrond de cursor op het eerste veld zette. 
Hierdoor verscheen het toetsenbord op het scherm van het mobiele apparaat wanneer het dialoogvenster tevoorschijn kwam, wat niet de bedoeling is. 
Dit werd opgelost door \code{focusInvalid:false} in te stellen in de plug-in.

De plug-in annoteert de foute velden met de CSS-klasse \code{error}.
Hierdoor kon de rode rond in CSS worden geprogrammeerd. 
Dit ging voor \code{input} en \code{textarea}, maar gaf problemen voor \code{select} en \code{fieldset}.
Door de extra code die \jqm{} genereert rond deze velden, moest via de DOM de omringende code geannoteerd worden om de rode rand te bekomen. 
Deze functie kon aangehaakt worden op de \code{highlight} en \code{unhighlight} functies van de plug-in.

\paragraph{\lungo}
Validatie is niet aanwezig in \lungo{} en er kon ook geen plug-in voor QuoJS gevonden worden~\cite{Ameye2013}.
Er werd geprobeerd om bestaande plug-ins voor andere \js{}-bibliotheken om te vormen en deze te laten werken met QuoJS.
Aangezien deze manier niet direct een oplossing bracht en er geen beroep kon worden gedaan op HTML5-validatie (zie \jqm{}), werd alle validatie manueel geprogrammeerd. 
Bij wijze van voorbeeld werd enkel validatie op het loginscherm geprogrammeerd.
Validatie op de rest van de formulieren doorheen de POC is volgens dezelfde werkwijze mogelijk, maar werd niet geïmplementeerd.
Dit verandert namelijk niets aan de score.

Het tonen van foutboodschappen alsook het tonen van een rode rand rond de foute velden werd ook zelf geprogrammeerd.
Bij een foutief gevalideerd veld werd een CSS-klasse toegevoegd die zorgde voor een rode rand.

%%%%%%%%%%%%%

\subsection{\uit{handtekening}}
\label{sec:evaluatie-gebruik-handtekening}

In tabel \ref{tabel:evaluatie-gebruik-handtekening} worden de resultaten getoond van de deeluitdaging van \uit{handtekening}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/handtekening.csv}
\caption{Gebruik van \uit{handtekening} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-handtekening}
\end{table}

\paragraph{\st}
Het tekenen van een handtekening steunt op een plug-in van SimFla~\cite{SimFla2011} en is in de Sencha Market te vinden op \exturl{market.sencha.com/extensions/signature-pad-field}.
Een plug-in aan het raamwerk toevoegen kan door het \js-bestand in de touch/src/ux folder te plaatsen.
Vervolgens moet de plug-in worden geladen bij het initialiseren van de applicatie.

De plug-in maakt een nieuw xtype \code{signaturefield} beschikbaar dat als veld in een formulier kan worden gebruikt.

De plug-in maakt gebruikt van het HTML5-canvas en retourneert de handtekening als geëncodeerde base64-tekst.

\paragraph{\kendo}
Aangezien \kendo{} steunt op de jQuery bibliotheek is \kendo{} ook perfect compatibel met jQuery plug-ins.
Net zoals bij \jqm{} werd ook de jSignature handtekening van Willow Systems~\cite{Systems2013} geïmplementeerd.

\paragraph{\jqm}
Er werd gezocht naar een plug-in om deze functionaliteit te bekomen, doordat \jqm{} dit niet standaard aanbiedt. 
Eerst werd gewerkt met Signature Pad van Thomas Bradley~\cite{Bradley2013}. 
Door de lange tijd die werd besteed aan het aanpassen van de lay-out, werd overgestapt naar jSignature van Willow Systems~\cite{Systems2013}. 
Deze laatste gaf ook het voordeel dat de breedte van het gebied om te handtekening in te zetten, zich automatisch naar 100\% schaalde. 
De plug-in maakt gebruik van het HTML5 \code{canvas}-element en de \code{.toDataURL()} methode.
Hierdoor kan de base64-string bekomen worden die nodig is om door te sturen naar de server.

\paragraph{\lungo}
Het maken van een handtekening is niet standaard aanwezig en daarenboven kon ook geen plug-in worden gevonden.
Er kan echter worden gebruik gemaakt van plug-ins die op andere \js{}-bibliotheken dan QuoJS steunen, maar de auteurs besloten om deze niet te beschouwen.
Daarenboven zouden er dan ook twee \js{}-bibliotheken aanwezig zijn in de applicatie.


%%%%%%%%%%%%%

\subsection{\uit{ajax}}
\label{sec:evaluatie-gebruik-ajax}

In tabel \ref{tabel:evaluatie-gebruik-ajax} worden de resultaten getoond van de vier deeluitdagingen van \uit{ajax}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/ajax.csv}
\caption{Gebruik van \uit{ajax} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-ajax}
\end{table}

\paragraph{\st}
AJAX-verzoeken kunnen zowel expliciet via een directe oproep met \code{Ext.Ajax.request} als impliciet via \code{stores} worden uitgevoerd.
De expliciete oproep is gelijkaardig aan de \code{\$.ajax} methode van jQuery.
Een enige uitzondering is te vinden bij kruis-domein AJAX-verzoeken.
Om aan de CORS-standaarden (Cross-Origin Resource Sharing) te voldoen moet de eigenschap \code{useDefaultXhrHeader} op \code{false} worden gezet.
%TODO referentie cors + opzoeken options request

De tweede,  impliciete,  methode voor AJAX-verzoeken is via \code{stores}.
Een \code{store} wordt voorzien van een \code{proxy}.  
Deze kan data aan de klant of server zijde opslaan.  
Een \code{proxy} voor opslag aan client zijde kan zowel in het RAM-geheugen als in de \term{local storage} en \term{session storage} van de browser opslaan.  
Een \code{proxy} voor server opslag kan data verzenden via AJAX (zelfde domein) of JSONP (verschillende domeinen).  
Een \code{proxy} kan ook geconfigureerd worden met \code{readers} en \code{writers} om data van de server te lezen of naar de server te schrijven.

Het verzenden van een JSON-\term{payload} moet via een expliciet AJAX-verzoek gebeuren.
Data kan via \code{Ext.encode} naar JSON worden geëncodeerd en via de \code{jsonData} eigenschap aan het verzoek worden gekoppeld.

\paragraph{\kendo}
Om asynchrone verzoeken naar de \term{backend} te implementeren, moet een \code{DataSource} worden gebruikt.
Zoals reeds besproken in de vorige uitdaging biedt dit object CRUD operaties.
Dit kan zowel op lokale (\js-objecten en \js-rijen) als externe data (XML, JSON, JSONP).
De \code{transport} eigenschap kan de configuraties bevatten om data te creëren (\code{create} eigenschap),  lezen (\code{read} eigenschap),  verwijderen (\code{destroy} eigenschap) en op te waarderen (\code{update} eigenschap).
Deze vier eigenschappen moeten geconfigureerd worden zoals de \code{\$.ajax} methode van jQuery.

Hoe data moet worden geparset, staat gedefinieerd in de \code{schema} eigenschap van de \code{DataSource}.
Zowel JSON als XML wordt ondersteund.
Aan een \code{schema} kan een \code{model} worden toegekend.
Er onderscheiden zich twee gevallen:  een bestaand \code{viewModel} kan met data worden geladen of nieuwe instanties van een \code{model} kunnen worden aangemaakt.
Het eerste geval zal de velden van één \code{viewModel} wijzigen als CRUD-operaties worden uitgevoerd.
De eigenschap moet dan aan het \code{viewModel} worden gelijkgesteld.
Het tweede geval zal het aantal instanties van een \code{model} wijzigen als CRUD-operaties worden uitgevoerd.
De eigenschap kan aan een reeds gedefinieerd \code{Model} worden gelijkgesteld of een model kan lokaal worden gedefinieerd.

\paragraph{\jqm}
Het maken van oproepen via AJAX gebeurt door jQuery. 
Dit gebeurt met de functie \code{\$.ajax} waar onder andere kan ingesteld worden wat het te verwachten antwoord is (zoals tekst, JSON of XML). 
Bij het succesvol uitvoeren van de oproep wordt de \code{succes}-functie opgeroepen, bij faling de \code{error}-functie waarna een relevante foutboodschap wordt getoond.

In jQuery is de functie \code{parseJSON} aanwezig, maar aangezien in de AJAX-oproep ingesteld wordt dat JSON wordt verwacht, parst jQuery al automatisch het antwoord. 
Hierdoor is de functie \code{parseJSON} niet nodig en kunnen direct worden omgaan met het antwoord.

Net zoals bij JSON het geval was, is het ook niet nodig om expliciet de \code{parseXML}-functie te gebruiken. 
Het doorlopen en opvragen van gegevens uit het XML-bestand vraagt meer werk. 
Waar er bij JSON direct kon worden omgegaan met de data, moet bij XML dat gebeuren aan de hand van selectoren.

Het versturen van JSON is gelijkaardig met het versturen van andere data.
Eerst zal de JSON-data moeten worden omgezet naar een string, wat gebeurt door \code{JSON.stringify}.
Daarna zal in de AJAX-oproep moeten worden aangegeven  dat de inhoud JSON is.
Dit gebeurt door \code{contentType:"{}application/json"} te schrijven.

\paragraph{\lungo}
Standaard biedt \lungo{} functies aan voor het ophalen en versturen van data via AJAX.
Deze functies zullen intern de functies van QuoJS oproepen.
De URL, de data, de callback en het type dienen hierbij te worden opgegeven.
De laatstgenoemde kan \code{text}, \code{json}, \code{xml} of \code{html} zijn.
Met \code{text}, \code{json} kan onmiddellijk worden omgegeven.
Voor \code{xml} dient er gebruik te worden gemaakt van de selectoren in QuoJS om de gevraagde data op te zoeken.

Bij het versturen van JSON-data konden de functies van \lungo{} zelf niet worden gebruikt.
Deze hadden te weinig opties om aan te geven dat de verstuurde data JSON was.
Hierdoor werden de functies van QuoJS gebruikt, die meer opties hadden.
Toch bleef er een probleem bij het versturen van JSON-data.
Na lang zoekwerk hoe QuoJS met deze oproep omging, bleek uiteindelijk dat de bibliotheek altijd de parameters wilde serialiseren.
Dit is uiteraard niet nodig als ruwe data, zoals JSON, wordt meegegeven.
Aangezien dit een fout was in de bibliotheek zelf werd om het probleem zo snel mogelijk te verhelpen het \js-bestand zelf aangepast.

%%%%%%%%%%%%%

\subsection{\uit{lijsten}}
\label{sec:evaluatie-gebruik-lijsten}

In tabel \ref{tabel:evaluatie-gebruik-lijsten} worden de resultaten getoond van de drie deeluitdagingen van \uit{lijsten}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/lijsten.csv}
\caption{Gebruik van \uit{lijsten} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-lijsten}
\end{table}

\paragraph{\st}
Zoals besproken in de vorige uitdaging kan een lijst voorzien worden van een sjabloon.
Dit sjabloon kan HTML-code of een instantie van de \code{Ext.XTemplate} klasse zijn.
De eerste definieert met HTML-tags de lay-out van de lijstelementen,  de tweede is geavanceerder.
De functionaliteiten van \code{Ext.XTemplate} zijn:
\begin{itemize}
  \item Doorlopen van een rij.
  \item Conditionele processen met de basis operatoren.
  \item Ondersteuning voor basis wiskundige operaties.
  \item Uitvoeren van willekeurige \js-code.
  \item Eigen functies in het sjabloon oproepen.
\end{itemize}
Het formateren van een datum kan door de \code{date} methode van \code{Ext.util.Format} op te roepen in het sjabloon.

Zoals reeds besproken bij \uit{vullen}, kan een formulier worden ingevuld met een \code{navigationview}.
Deze \code{view} heeft een \code{push} en \code{pop} methode om een \code{view} op een \code{stack} te plaatsen of af te halen.
Om een \code{view} te tonen die hoort bij een lijstelement wordt gebruik gemaakt van deze \code{navigationview} en de \code{push} methode.
De lijst wordt in een \code{navigationview} ingesloten.
Het aanklikken van een lijstelement veroorzaakt een \code{disclosure} gebeurtenis.
Een \code{controller} kan deze gebeurtenis opvangen en de \code{push} methode op de \code{navigationview} oproepen.
De methode kan geparameteriseerd worden met een modelinstantie, analoog als de \code{setRecord} methode van een formulierpaneel.

Het sorteren van een lijst kan automatisch met een \code{store}.
Een \code{store} kan aan een lijst worden gekoppeld zodat alle modelinstanties van de \code{store} in de lijst worden weergegeven.
De \code{store} moet dan voorzien worden van een \code{sorter}.
Deze kan modelinstanties van een \code{store} sorteren op basis van eigenschappen van het bijhorende model.
Ook kan de richting van sorteren worden geconfigureerd.
Meerdere \code{sorters} definiëren is mogelijk voor het geval er gelijkheden op vorige niveau's optreden.
Een \code{store} sorteren kan ook expliciet door de \code{sort} methode op de \code{store} op te roepen.

\paragraph{\kendo}
Lijsten worden met een \code{listview} als \code{data-role} weergegeven.
Wanneer lijsten met een \code{DataSource} gebonden worden zullen alle instanties van de \code{DataSource} als element in de lijst verschijnen.
%todo binding tussen js lijst en listview
De opmaak van lijsten kan met \kendo{} \code{Templates} worden uitgedrukt.
Deze sjablonen zijn apparte scripts van het type \code{text/x-kendo-template} en moeten in een HTML-bestand worden geschreven.
De sjablonen hebben toegang tot de velden van de modelinstanties die aan de lijst zijn toegekend.
Hiervoor moet de veldnaam tussen \term{hashtags} worden gebruikt.
Binnen de scripts is ook mogelijk om \js-functies op te roepen door de functie ook binnen \term{hashtags} te schrijven.

De link van elk lijstelement moet in het sjabloon worden gedefinieerd.
Om de elementen uit het uitgavenoverzicht te linken, werd gebruik gaakt van een geparameteriseerde \code{view}.
Dit laat toe om parameters in de link naar de \code{view} op te geven,  analoog aan HTTP GET-verzoeken.
De parameter die wordt doorgegeven is de id van de uitgave.
Wanneer naar de \code{view} wordt genavigeerd, zal een functie met opgegeven parameter worden uitgevoerd.
De functie zal een \code{ObservableObject} laden met data van de uitgave die hoort bij de meegekregen id.
Het \code{ObservableObject} is gekoppeld aan een formulier dat automatisch zal worden ingevuld zodra het object wordt geïnitialiseerd.

Het sorteren van een lijst kan door de \code{DataSource} die aan de lijst is gekoppeld van een sorteereigenschap te voorzien.
Deze sorteereigenschap bepaalt het veld waarop gesorteerd moet worden en eventueel een sorteerrichting.

\paragraph{\jqm}
Het laden van data in een lijst dient zelf geprogrammeerd te worden.
Hiervoor wordt gebruik gemaakt van de \code{.each()}-functie van jQuery om ieder data-item te overlopen.
Per item moet een \code{append} gebeuren van een lijstitem op de lijst.
In dit item wordt de template van de lijst geschreven.
Na alle elementen te hebben overlopen, moet de lijst ververst worden zodat \jqm{} de correcte lay-out toepast op de volledige lijst

Het klikbaar maken van de gegenereerde lijstitems gebeurt bij het genereren van de items zelf.
Er kunnen hiervoor twee manieren gekozen worden.
Enerzijds kan worden gebruik gemaakt van de \code{<a>}-tags in HTML.
Anderzijds kan ieder lijstitem een \code{id} krijgen, waarna een \code{click}-\term{event}  wordt gebonden aan al deze elementen.
Op basis van de \code{id} kan de uit te voeren actie bepaald worden.

Het sorteren van data werd geïmplementeerd door eerst in \js{} een vergelijkingsfunctie te schrijven.
Daarna wordt deze functie meegegeven aan de sorteerfunctie die ook in \js{} aanwezig is.
Er komt dus geen functionaliteit van het raamwerk om data te sorteren.

\paragraph{\lungo}
Het laden van data in een lijst dient zelf geprogrammeerd te worden.
Hiervoor wordt gebruik gemaakt van de functie \code{\$\$.each} van QuoJS om ieder element van de array te overlopen.
Per element gebeurt een \code{append} op de lijst waar de data dient geladen te worden.
Het toegevoegde lijstitem bepaalt de template van de lijst.

Het klikbaar maken van de gegenereerde lijstitems gebeurt bij het genereren van de items zelf.
Er kunnen hiervoor twee manieren gekozen worden (zie ook \jqm{}).
Enerzijds kan worden gebruik gemaakt van de \code{<a>}-tags in HTML.
Anderzijds kan ieder lijstitem een \code{id} krijgen, waarna een \code{click}-\term{event}  wordt gebonden aan al deze elementen.
Op basis van de \code{id} kan de uit te voeren actie bepaald worden.

Het sorteren van data gebeurt door de aangeboden functies van het raamwerk zelf.
De functie \code{Lungo.Core.orderByProperty} maakt het mogelijk om te sorteren volgens een bepaalde eigenschap, zowel oplopend als aflopend.


%%%%%%%%%%%%%

\subsection{\uit{pdf}}
\label{sec:evaluatie-gebruik-pdf}

In tabel \ref{tabel:evaluatie-gebruik-pdf} worden de resultaten getoond van de twee deeluitdagingen van \uit{pdf}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/pdf.csv}
\caption{Gebruik van \uit{pdf} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-pdf}
\end{table}

\paragraph{\st}
Het tonen van een PDF steunt op een plug-in van Fiedler~\cite{Fiedler2012} en kan op de Sencha Market gevonden worden op \exturl{market.sencha.com/extensions/pdf-viewer-panel}.
Het tonen van een PDF-bestand kan door de huidige \code{view} te wijzigen naar een \code{Ext.ux.PDF view}.
Deze \code{view} bestaat uit een paneel met een hoofdtekst.
Het paneel toont één pagina van het PDF-bestand,  de hoofdtekst bevat de navigatie naar andere pagina's.

Om de plug-in in de POC in te passen waren echter twee aanpassingen noodzakelijk.
Het PDF-bestand moet via een POST verzoek worden opgehaald waarbij parameters het exacte PDF-bestand aanduiden.
Ook moest er een terugknop in de hoofdtekst van het paneel worden aangebracht om terug naar het overzicht van doorgestuurde formulieren te gaan.
Beide aanpassingen moesten in het \js-bestand van de plug-in worden aangebracht.

\paragraph{\kendo}
De implementatie voor het tonen van het PDF-bestand is analoog als de implementatie met \jqm{}.
%TODO terug aanhalen? Aan elk lijstelement in het overzicht van uitgavenformulieren wordt een functie gebonden.

\paragraph{\jqm}
AJAX is bedoeld om tekst op te halen, maar geen ruwe data zoals een PDF~\cite{Scott2009}. 
Hierdoor werd gebruik gemaakt van een verborgen formulier met de nodige parameters die de PDF ophaalt bij de backend. 
Bij het klikken op een lijstitem in het overzicht, wordt dit verborgen formulier opgestuurd naar de \term{backend} die dan een PDF teruggeeft in de browser. 
Het weergeven van de PDF wordt overgelaten aan het mobiel apparaat dat de correcte applicatie hiervoor opstart.

\paragraph{\lungo}
Om dezelfde reden als \jqm{} werd ook hier geen gebruik gemaakt van AJAX om de PDF op te vragen.
Een verborgen formulier, net zoals dat voor \jqm{} het geval was, werd gebruikt om de PDF op te halen.
Het weergeven van de PDF wordt overgelaten aan het mobiel apparaat dat de correcte applicatie hiervoor opstart.

%%%%%%%%%%%%%

\subsection{\uit{offline}}
\label{sec:evaluatie-gebruik-offline}

In tabel \ref{tabel:evaluatie-gebruik-offline} worden de resultaten getoond van de twee deeluitdagingen van \uit{offline}.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.8cm} p{0.3cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,Max,ST(abs),Kendo(abs),jQM(abs),Lungo(abs)},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},
  columns/Max/.style={column name=\textbf{Max}, column type={l}},    
  columns/jQM(abs)/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST(abs)/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo(abs)/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo(abs)/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/offline.csv}
\caption{Gebruik van \uit{offline} voor \st{}~(\sta), \kendo{}~(\kendoa), \jqm{}~(\jqma) en \lungo{}~(\lungoa).}
\label{tabel:evaluatie-gebruik-offline}
\end{table}

\paragraph{\st}
Zoals besproken bij \uit{ajax} kan een \code{store} voozien worden van een \code{proxy} die data opslaat aan klantzijde.
Deze \code{store} maakt gebruik van de HTML5-localStorage API.
Om inlog gegevens en onverzonden onkosten lokaal te bewaren moeten twee \code{stores} met deze \code{proxy} worden gedefinieerd.
Een belangrijke opmerking is dat geen twee \code{proxies} aan een \code{store} kunnen worden toegevoegd.
Gegevens van een gebruiker moeten van de server worden opgehaald - met een AJAX-\code{proxy} - en lokaal worden opgeslagen - met een \term{local storage} \code{proxy}.
Hiervoor zijn twee verschillende \code{store} instanties nodig die gesynchronizeerd moeten worden!
Bij het laden van de applicatie zal de \code{store} die gebruikers lokaal opslaat, op data worden gecontroleerd.
Indien er data wordt gevonden,  was de gebruiker reeds ingelogd.
De applicatie zal dan meteen naar het startscherm navigeren.

Om onverzonden uitgaven lokaal op te slaan, moeten de uitgaven ook aan een \code{store} met lokale \code{proxy} worden toegevoegd.
Deze worden dan automatisch naar de \term{local storage} weggeschreven.
De controle op onverzonde uitgaven wordt herleid tot het controleren van data in de \code{store}.
Het verwijderen van onverzonden lokale uitgaven kan door de data in de \code{store} te wissen.

De applicatie offline beschikbaar maken wordt ondersteund door Sencha Cmd~\cite{Sencha2012}.

Een applicatie,  zoals geinitialiseerd door Sencha Cmd,  moet alle benodigde \js-, en CSS-bestanden in een JSON-bestand onderbrengen.
Een \code{microloader} zal de afhankelijke bestanden automatisch laden bij het opstarten van de applicatie.

Het bouwen en uitrollen van een applicatie kan op vier niveaus:
\begin{description}
  \item [testing] maakt een testapplicatie om de kwaliteit te testen.  \js- en CSS-bestanden worden samengevoegd maar niet verkleind om makkelijk te debuggen
  \item [package] maakt een zelfstandige applicatie die verspreidbaar is en vanop een bestandensyteem,  zonder web server,  kan lopen.
  \item [production] maakt een applicatie die op een webserver beschikbaar wordt gemaakt waarvan de \js-, en CSS- bestanden zijn samengevoegd en verkleind.  Het maakt de applicatie ook offline beschikbaar door gebruik te maken van de HTML5-applicatie cache.  Ook is het mogelijk de applicatie op te waarderen naar een nieuwe versie.
  \item [native] maakt een \term{native} applicatie die op het Android of iOS besturingssysteem kan lopen.
\end{description}
Om de applicatie offline beschikbaar te maken moet de applicatie gebouwd worden voor productie.
De tool zal automatisch een manifest bestand aanmaken die alle vereiste bestanden bevat.

\paragraph{\kendo}
%user opslaan => jqm (check bij employeedatasource)
Vanuit het raamwerk komt er standaard geen ondersteuning om gegevens offline te bewaren.
Hiervoor werd gebruik gemaakt van \code{localStorage}, wat gespecificeerd is in HTML5.
Het controleren of \code{localStorage} al dan niet wordt ondersteund, gebeurd door Modernizr~\cite{Modernizr2012}.

Na het aanmelden zullen alle gegevens van de werknemer geserialiseerd worden opgeslagen.
Deze gegevens zitten in een \code{OservableObject} en kunnen met de \code{toJSON} methode als JSON-object worden verkregen.
Het serialiseren zelf kan via de \code{JSON.stringify} methode.
Wanneer het aanmeldscherm wordt getoond zal gecontroleerd worden of er gegevens van een werknemer lokaal beschikbaar zijn.
Indien dit het geval is, wordt automatisch naar naar het startscherm genavigeerd.

Wanneer een uitgave wordt toegevoegd zal deze aan een \code{DataSource} en in de \code{localStorage} worden toegevoegd.
De controle op reeds bestaande uitgaven zoekt naar reeds bestaande uitgaven in de \code{localStorage}.
Nadat een uitgaveformulier is verzonden worden de uitgaven uit de \code{localStorage} verwijderd.

    
%expense opslaan => add Expense toevoegen aan localstorage

Het offline beschikbaar maken van de applicatie wordt vanuit \kendo{} zelf niet ondersteund.
De HTML5 Application Cache kan zelf worden aangemaakt.
Om het proces te vergemakkelijken werd het \code{.appcache}-bestand dat een lijst is van alle offline-bestanden, gegenereerd aan de hand van Yeoman~\cite{Yeoman2013}.

\paragraph{\jqm}
Vanuit het raamwerk komt er standaard geen ondersteuning om gegevens offline te bewaren.
Hiervoor werd gebruik gemaakt van \code{localStorage}, wat gespecificeerd is in HTML5.
Omdat het kan voorkomen dat \code{localStorage} niet wordt ondersteund, werd zelf een fallback geschreven die de data bijhoudt als \js{}-variabelen.
Natuurlijk wordt bij het vernieuwen van de applicatie deze data gewist, maar kan de applicatie wel in eenzelfde browsersessie volledig worden gebruikt.
Het controleren of \code{localStorage} al dan niet wordt ondersteund, gebeurd door Modernizr~\cite{Modernizr2012}.


Het startscherm werd als eerste scherm gekozen, omdat \jqm{} altijd het eerste scherm in de HTML-code in inlaadt.
Indien gemerkt wordt dat de gebruiker niet aangemeld was, dan wordt hij doorverwezen naar het inlogscherm.
Hierdoor zal, als de applicatie offline is, de gebruiker kunnen navigeren doorheen de applicatie doordat zijn gebruikersgegevens werden bewaard.

Het offline beschikbaar maken van de applicatie wordt vanuit \jqm{} zelf niet ondersteund, omdat van de HTML5 Application Cache kan worden gebruik gemaakt.
Om het proces te vergemakkelijken werd het \code{.appcache}-bestand dat een lijst is van alle offline-bestanden, gegenereerd aan de hand van Yeoman~\cite{Yeoman2013}.

\paragraph{\lungo}
Het raamwerk biedt zelf functies aan om data op te slaan.
Intern zal het gebruik maken van \code{localStorage}, wat gespecificeerd is in HTML5.
Indien het niet ondersteund wordt op het apparaat, zal het raamwerk zelf een fallback voorzien.

Het offline beschikbaar maken van de applicatie wordt vanuit \lungo{} zelf niet ondersteund, omdat van de HTML5 Application Cache kan worden gebruik gemaakt.
Om het proces te vergemakkelijken werd het \code{.appcache}-bestand dat een lijst is van alle offline-bestanden, gegenereerd aan de hand van Yeoman~\cite{Yeoman2013}.