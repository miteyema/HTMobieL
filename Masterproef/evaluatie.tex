\chapter{Evaluatie}
\label{chap:evaluatie}

In dit hoofdstuk voeren we de vergelijking uit en bekijken we de bekomen resultaten.
Enerzijds vergelijken we in \ref{sec:evaluatie-poc} de implementatie van de POC in de verschillende raamwerken.
Anderzijds vergelijken we in \ref{sec:evaluatie-criteria} de raamwerken op basis van de vergelijkscriteria opgesteld in hoofdstuk \ref{chap:vergelijking}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{POC}
\label{sec:evaluatie-poc}
In deze sectie bekijken we de problemen die we hebben tegengekomen bij het implementeren van de POC in de verschillende raamwerken.
Er wordt een onderscheid gemaakt tussen enerzijds de functionele vereisten als anderzijds vereisten met betrekking tot lay-out.

\subsection{Functionele vereisten}
Hieronder bespreken we de functionele vereisten van de POC.

\subsubsection{Formulieren}

\paragraph{jQuery Mobile} 
Voor het toevoegen van \term{placeholders} in de formuliervelden kon beroep worden gedaan op het \code{placeholder} attribuut in HTML5. 
Er dienden geen labels te worden gezet voor de velden. 
Deze labels zijn echter wel verplicht in jQuery Mobile, maar kunnen onzichtbaar worden gemaakt met de \code{ui-hide-label} CSS klasse~\cite{JQuery2013}. 
Wat wel opmerkelijk is wanneer men een formulier invult, daarna verstuurt en dan terugkeert, het formulier nog alle waarden bevat. 
Men moet na het formulier te hebben verstuurd, zelf het formulier altijd leegmaken. 
Dit kan met behulp van JavaScript via de \code{reset()}-functie op het formulier.

Voor de types van de formuliervelden werd beroep gedaan op de volgende types: \code{text}, \code{number} en \code{email}. 
Deze zorgen ervoor dat op de mobiele apparaten aangepaste toetsenborden te voorschijn komen. 
Het \code{date} type werd echter niet gebruikt. 
Enerzijds was hiervoor een slechte ondersteuning naar mobiele browsers toe~\cite{Deveria2013b}. 
Dit betekende onder andere dat Android 2.3 dit niet ondersteunde. 
Een ander probleem was het ontbreken van een \term{placeholder} in het veld op iOS 6 en Android 4.2. 
Hierdoor weet de gebruiker in eerste instantie niet wat hij hier moet invullen, omdat er ook geen labels aanwezig moesten zijn. 
Daarnaast is een \code{placeholder} instellen onmogelijk voor een \code{date} type~\cite{Berjon2012}. 
Anderzijds moest het ook mogelijk zijn om de gebruiker maar een bepaald bereik van data op te leggen, wat met het \code{date} type onmogelijk is. 
Hierdoor werd gebruik gemaakt van de Date \& Time Picker van Mobiscroll~\cite{Mobiscroll2013} die ook aangepaste lay-out heeft conform met die van jQuery Mobile. 
Het veld heeft dan het type \code{text}. 
Het is dus in principe mogelijk om iets anders dan een datum in te geven. 
Dit wordt belet door ook nog eens een datum validatie te doen op dit tekstveld mocht de plugin het al niet afgedwongen hebben.

Het was ook nodig om enkel de maand en jaar in te geven. 
Ook hier kon niet het \code{date} type gebruikt worden, omdat daar ook een dag voor nodig is. 
Daardoor werden de maanden handmatig geprogrammeerd als vaste lijstitems. 
De jaren zijn dynamisch en zijn telkens dit jaar, het volgende en het vorige jaar. 
Deze functionaliteit had ook met de Mobiscroll plugin kunnen worden verwezenlijkt.

\subsubsection{Validatie}

\paragraph{jQuery Mobile} 
Sommige formuliervelden waren verplicht in te vullen, terwijl andere niet. 
Hiervoor werd eerst gedacht om het \code{required} attribuut in HTML5 te gebruiken. 
Het probleem is echter dat er geen ondersteuning is voor mobiele browsers~\cite{Deveria2013}. 
Daarnaast was het ook nodig om de velden te valideren op hun waarde. 
Validatie is echter niet standaard aanwezig in jQuery Mobile. 
Als oplossing werd de plugin van Jörn Zaefferer gebruikt~\cite{Zaefferer2013}. 
Deze plugin loste ook het probleem met de verplichte velden op. 
Deze plugin kan op twee manieren gebruikt worden: enerzijds annoteren van de formuliervelden met speciale CSS klassen ofwel anderzijds door programmatie met JavaScript. 
Beide aanpakken werden getest doorheen de POC. 

De plugin bevatte de volgende ingebakken validatieregels nodig in de POC: \code{required}, \code{number}, \code{email} en \code{date}.
Daarnaast was het nodig dat een veld verplicht was enkel indien een bepaalde optie aangevinkt was.
Zo'n afhankelijkheidsrelatie is standaard aanwezig in de plugin.

Bij fouten tegen validatie moest een dialoogvenster worden weergegeven met daarin een beschrijving van alle foute velden.
Aangezien de plugin standaard onder het foute formulierveld een foutboodschap toont, diende de plugin  te worden aangepast.
Door de uitgebreide API van de plugin die ook uitvoerig gedocumenteerd is, konden alle foutboodschappen samen in een dialoogvenster worden weergegeven.

Een specifiek mobiel probleem was bij het tonen van het dialoogvenster, waarbij de plugin op de achtergrond de cursor op het eerste veld zette. 
Hierdoor verscheen het toetsenbord op het scherm van het mobiele apparaat wanneer het dialoogvenster tevoorschijn kwam, wat niet de bedoeling is. 
Dit werd opgelost door \code{focusInvalid:false} in te stellen in de plugin.

Bij het sluiten van het dialoogvenster dienden de foute velden met een rode rand te worden gemarkeerd.
Aangezien de validatie plugin de foute velden annoteert met de \code{error} CSS klasse, kon de rode rand in CSS worden geprogrammeerd. 
Dit ging voor \code{input} en \code{textarea}, maar gaf problemen voor \code{select} en \code{fieldset}.
Door de extra code die jQuery Mobile genereert rond deze velden, moest via de DOM de omringende code geannoteerd worden om de rode rand te bekomen. 
Deze functie kon aangehaakt worden op de \code{highlight} en \code{unhighlight} functies van de plugin.

\subsubsection{Opladen van bewijs}

\paragraph{jQuery Mobile} 
Het opladen van een bestand kan gebeuren door \code{file} als invoertype van het formulierveld te gebruiken. 
In versie 1.2 wordt dit veld nog niet opgemaakt met lay-out, maar dit gebeurt wel in versie 1.3~\cite{JQuery2013d}. 
Voor het kan worden doorgestuurd naar de backend, moet het bewijs eerst lokaal worden omgevormd naar base64. 
Dit werd geïmplementeerd met de FileReaderAPI en het canvas, wat beide HTML5 specificaties zijn. 
Het aangeklikte bestand wordt gelezen door middel van de FileReaderAPI, waarna het als afbeelding wordt opgeslagen en geïmporteerd wordt op het canvas. 
Eenmaal geïmporteerd, kan men de \code{.toDataURL()} oproepen op het canvas om de geïmporteerde afbeelding om te vormen naar base64. 
Deze aanpak werkt correct op recente mobiele apparaten. 
De FileReaderAPI wordt echter niet ondersteund op Android versies 2.3 en lager of iOS versies lager dan 6.0~\cite{Deveria2013a} waardoor het opladen van een bewijs niet werkt.

Het voorvertonen van het geüploade bestand hangt af van het mobiele besturingssysteem.
Zo wordt op iOS 6 een miniatuurafbeelding getoond, terwijl op Android de bestandsnaam wordt getoond.
Het is natuurlijk ook mogelijk om de preview na conversie zelf te tonen op het scherm.
Bij iOS zouden er dan twee voorvertoningen te zien zijn op hetzelfde scherm.

\subsubsection{Handtekening}

\paragraph{jQuery Mobile} 
Er werd gezocht naar een plugin om deze functionaliteit te bekomen, doordat jQuery Mobile dit niet standaard aanbiedt. 
Eerst werd gewerkt met Signature Pad van Thomas Bradley~\cite{Bradley2013}. 
Door de lange tijd die werd besteed aan het aanpassen van layout, werd overgestapt naar jSignature van Willow Systems~\cite{Systems2013}. 
Deze laatste gaf ook het voordeel dat de breedte van het gebied om te handtekening in te zetten, zich automatisch naar 100\% schaalde. 
De plugin maakt gebruik van het HTML5 canvas element en de \code{.toDataURL()} methode.
Deze wordt echter niet ondersteund op Android versies 2.3 en lager~\cite{Systems2013} waardoor de functionaliteit op die toestellen niet werkt.

\subsubsection{AJAX}

\paragraph{jQuery Mobile} 
Het maken van oproepen via AJAX gebeurt via de jQuery bibliotheek waar jQuery Mobile op steunt. 
Dit gebeurt met de functie \code{\$.ajax} waar onder andere kan ingesteld worden wat het te verwachten antwoord is (zoals tekst, HTML, JSON of XML). 
Bij het succesvol uitvoeren van de oproep wordt de \code{succes} functie opgeroepen, bij faling de \code{error} functie waarna een relevante foutboodschap wordt getoond.
Het afmelden zonder antwoord, het aanmelden voor het bekomen van het token (HTML), het ophalen van de gebruikersgegevens (JSON), het ophalen van de uitgaveformulieren (XML) en het ophalen van de omwisselingskoersen (XML) ging zonder enig probleem.

\subsubsection{JSON}

\paragraph{jQuery Mobile} 
In jQuery is er de functie \code{parseJSON} aanwezig, maar aangezien we in de AJAX oproep instellen dat we JSON verwachten, parst jQuery al automatisch het antwoord. 
Hierdoor hebben we \code{parseJSON} niet nodig en kunnen we direct omgaan met het antwoord.

Het is ook nodig om JSON te versturen als oproep naar de backend. 
Dit wordt gedaan vanuit JavaScript zonder een jQuery nodig te hebben. 
Eerst wordt een object met de nodige inhoud aangemaakt, waarop daarna de functie \code{JSON.stringify} opgeroepen wordt die het object in een string omzet.
Deze is daarna klaar om te worden verstuurd als data via een AJAX oproep met behulp van jQuery.

\subsubsection{XML}

\paragraph{jQuery Mobile} 
Net zoals bij JSON het geval was, was het ook niet nodig om expliciet de \code{parseXML} functie te gebruiken. Het doorlopen en opvragen van gegevens uit het XML-bestand vraagt meer werk. Waar je bij JSON direct aan de data kon, moet je bij XML de data ophalen net zoals je dat zou doen uit een HTML-pagina. Dit betekent dus met selectoren aan de hand van de jQuery bibliotheek.

\subsubsection{PDF}

\paragraph{jQuery Mobile} 
Het is niet aangeraden om ruwe data, zoals een PDF, op te halen via AJAX. 
Hierdoor werd gebruik gemaakt van een verborgen formulier met de nodige parameters die de PDF ophaalt bij de backend. 
Bij het klikken op een lijstitem in het overzicht, wordt dit verborgen formulier opgestuurd naar de backend die dan een PDF teruggeeft in de browser. 
Het weergeven van de PDF wordt overgelaten aan het mobiel apparaat dat de correcte applicatie hiervoor opstart.

\subsubsection{Automatische aanvulling}

\paragraph{jQuery Mobile} 
Hoewel versie 1.3 automatische aanvulling ter beschikking heeft~\cite{JQuery2013c}, werd tijdens de implementatie gebruik gemaakt van versie 1.2 die dit niet had. 
Daarom werd de plugin van Andy Matthews gebruikt~\cite{Matthews2013}. 
Dit is een zeer gemakkelijk te integreren plugin die zowel met lokale data als data op afstand kan werken. 
Daarnaast dienden enkel vijf suggesties te worden getoond. 
Deze functionaliteit zat niet in de plugin, maar werd geïmplementeerd met de JavaScript \code{slice} functie.

\subsubsection{Tabbalk}

\paragraph{jQuery Mobile} 
Standaard is er een tabbalk aanwezig in jQuery Mobile, maar de POC impliceerde een tabbalk die niet de volledige breedte innam.
Daarom werd gekozen voor \code{fieldset} met twee opties.

\subsubsection{Inlogscherm indien niet aangemeld}

\paragraph{jQuery Mobile} 
Indien men een applicatie maakt met meerdere schermen op eenzelfde pagina, laadt jQuery Mobile altijd het eerste scherm in de code in.
Het startscherm werd als eerste scherm gekozen.
Indien gemerkt wordt dat de gebruiker niet aangemeld was, dan wordt hij doorverwezen naar het inlogscherm.

\subsubsection{Detail van toegevoegde uitgave}

\paragraph{jQuery Mobile} 
Na het toevoegen van een uitgave, is het mogelijk om deze opnieuw te bekijken (maar niet aan te passen).
Hiervoor wordt hetzelfde formulier (dat om een uitgave toe te voegen wordt gebruikt) gekopieerd, waarna alle elementen op enkel lezen worden gezet.
Dit was geen probleem voor velden van het type \code{input} en \code{textarea}. 
Dit kon echter niet  bij \code{fieldset}. 
Daar moesten via \code{disabled} de andere opties onmogelijk worden gemaakt.
Eenzelfde probleem gold voor het \code{select} formuliertype bij een buitenlandse uitgave.
Daar werd enkel de geselecteerde optie in het lijstje getoond en alle andere opties eruit verwijderd.

Het invullen van het formulier zelf werd bekomen door de \code{id}'s van de velden op te vragen en hun waarde in te stellen volgens de JSON voorstelling van die uitgave. 
Er is met andere woorden geen automatische mapping van de JSON data naar de formuliervelden. 

\subsubsection{Laadscherm}

\paragraph{jQuery Mobile} 
Het standaard laadscherm is enkel een \term{spinner} die niet opvallend aanwezig is en ook zonder een tekst eronder ronddraait.
Door de opties in de API te gebruiken, komt de \term{spinner} duidelijk naar voor en staat er ook een tekst onder.

\subsubsection{Dialoogvenster}

\paragraph{jQuery Mobile} 
Eerst werd gebruik gemaakt van DateBox \cite{Sage2013} als plugin om op een gemakkelijke manier een dialoogvenster te tonen.
Uiteindelijk bleek de plugin niet zo gemakkelijk aanpasbaar en daarenboven zijn dialoogvensters standaard in jQuery Mobile aanwezig.
Het is dan ook helemaal niet nodig om hiervoor een plugin te gebruiken.
Door zelf de dialoogvenster met jQuery Mobile aan te maken, kon de layout minimier aangepast worden.

\subsubsection{Omvormen van valuta}

\paragraph{jQuery Mobile} 
De omvorming bij een buitenlandse uitgave dient automatisch te gebeuren bij het ingeven van bedrag en munteenheid.
Hiervoor wordt aangehaakt op het veranderingsevenement \code{.change} dat jQuery aanbiedt, waarna na omvorming het bedrag direct getoond wordt aan de gebruiker.

\subsubsection{Sorteren}

\paragraph{jQuery Mobile} 
Het sorteren van data werd geïmplementeerd door eerst in JavaScript een vergelijkingsfunctie te schrijven.
Daarna wordt deze functie meegegeven aan de sorteerfunctie die ook in JavaScript aanwezig is.
Er komt dus geen functionaliteit van het raamwerk om data te sorteren.

\subsubsection{Offline} 
TODO

%%%%%%%

\subsection{Lay-out}
Hieronder bespreken we de vereisten met betrekking tot lay-out.

\subsubsection{Tablet en smartphone}

\paragraph{jQuery Mobile} 
In jQuery Mobile is er standaard geen splitview aanwezig om een menu te tonen voor tablets, maar niet voor smartphones. 
Eerst werd hiervoor gezocht naar plugins aan de hand van~\cite{Deering2012}, wat leidde tot: Splitview~\cite{Rahman2013}, SimpleSplitView~\cite{Yared2013} en Multiview~\cite{Franck2012}. 
Deze drie mogelijke kanshebbers hadden elk hun tekorten. 
Zo was de eerste destructief ten opzichte van het raamwerk. 
Dit betekent dat de bestanden van het raamwerk zelf werden aangepast, wat het moeilijker maakt als men wil updaten naar een nieuwe versie. 
De tweede plugin werkte enkel tot versie 1.0.1 van jQuery Mobile. 
De laatste plugin had moeite met het zich aanpassen aan veranderende afmetingen van de browser. 

Uiteindelijk werd van een plugin afgestapt door \cite{Hadlock2012} waarbij werd aangetoond hoe men via CSS3 media queries hetzelfde kan bereiken. 
Daarnaast gebruikt de documentatie van jQuery Mobile~1.2 een gelijkaardige layout~\cite{JQuery2012b}. 
De uiteindelijke oplossing voor het probleem kwam uit te combinatie van deze twee voorgaande oplossingen.
Ook uit de documentatie van versie 1.3 \cite{JQuery2013e} blijkt dat dit de correcte manier is om hiermee om te gaan.

Navigatie op een smartphone gebeurt door te klikken op de extra titel onder de koptekst. 
Hierdoor ga je naar een smartphone vriendelijk menu om naar andere stappen te gaan.

\subsubsection{Koptekst en voettekst}

\paragraph{jQuery Mobile}
Het toevoegen van een koptekst en voettekst ging zonder enig probleem door gebruik te maken van \code{data-role="header"} en \code{data-role="footer"}. 
Wel moest dezelfde code op ieder scherm worden herhaald. 
Dit kan worden vermeden door gebruik te maken van eenzelfde \code{data-id} attribuut. 
Daarnaast werd de voettekst gefixeerd aan de onderkant van het scherm en de bijhorende logo's links en rechts uitgelijnd. 
Voor dit laatste werd gebruik gemaakt van de zogenaamde \term{grid} die jQuery Mobile aanbiedt. 
Deze voettekst wordt niet getoond op een smartphone, wat wordt bekomen door gebruik te maken van de CSS3 media queries.

Bij het toevoegen van een uitgave dient er een extra titel onder de koptekst te komen. 
Eerst werd geprobeerd om bovenaan een lijstdeler te plaatsen, maar dan schoof de inhoud van de pagina niet mee naar onder. 
De uiteindelijke oplossing kwam vanuit de documentatie \cite{JQuery2013b} om dit met behulp van de \code{ui-bar} CSS klasse te implementeren. 
Deze extra titel wordt ook gebruikt om op de smartphone naar de speciale smartphone navigatie te gaan (zie ook vorige sectie).

\subsubsection{Knoppen}

\paragraph{jQuery Mobile} 
De kleur van de knoppen aanpassen kan op twee manieren. 
Ofwel schrijft men zelf de CSS-code ofwel gebruikt men ThemeRoller~\cite{JQuery2012c}. 
Deze laatste manier werd gebruikt om de knoppen groen te maken. 
Men sleept dan eenvoudigweg in die webinterface de groene kleur op de knop en daarna kan de bijhorende CSS-code worden gedownload. 
Door daarna de knop te annoteren met het \code{data-theme} attribuut activeert men het betreffende thema. 
Om de knop blauw te maken was er geen nood aan een aanpassing, doordat blauw al één van de standaard thema's was en men die direct kan gebruiken.

Knoppen toevoegen aan de koptekst gaat ook op een zeer eenvoudige manier.
% TODO: verder schrijven

\subsubsection{Lijsten}

\paragraph{jQuery Mobile} 
Het aanmaken van lijsten gebeurt met de \term{listview} widget.
% TODO: verder schrijven

\subsubsection{Lijsten}

\paragraph{jQuery Mobile} 
% TODO: verder schrijven

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Vergelijkscriteria}
\label{sec:evaluatie-criteria}