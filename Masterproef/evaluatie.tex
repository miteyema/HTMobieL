\chapter{Evaluatie}
\label{chap:evaluatie}

In dit hoofdstuk wordt de vergelijking uitgevoerd op basis van de vijf vergelijkingscriteria uit hoofdstuk \ref{chap:vergelijking}, namelijk gemeenschap~(\ref{sec:evaluatie-gemeenschap}), productiviteit~(\ref{sec:evaluatie-productiviteit}), gebruik~(\ref{sec:evaluatie-gebruik}), ondersteuning~(\ref{sec:evaluatie-ondersteuning}) en performantie~(\ref{sec:evaluatie-performantie}). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Gemeenschap}
\label{sec:evaluatie-gemeenschap}

% jQM
% Met 7.400 volgers op GitHub~\cite{GitHub2012} en 11.200 volgers op Twitter~\cite{Twitter2012} komt de grote kracht van jQuery Mobile van zijn community . Dit heeft grotendeels te maken met het feit dat jQuery Mobile geniet van het succes van jQuery, dat ook zeer populair is~\cite{Hales2012}.
%TODO Sander: dit komt in de vergelijkingscriteria

% ST
% We kunnen vaststellen dat Sencha over een grote community beschikt.  Met meer dan 2 miljoen ontwikkelaars wereldwijd is Sencha de grootste provider van een open-source web applicatie~\cite{Inc.}.  

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  col sep=comma,
  string type,
  header=true,
  columns={Gemeenschap,jQM,ST,Kendo,Lungo},
  columns/Gemeenschap/.style={column name=\textbf{Gemeenschap}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqm}, column type={c}},
  columns/ST/.style={column name=\textbf{\st}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendo}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungo}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
    after row=\bottomrule}
]{tabellen/gemeenschap.csv}
\caption{Samenvattende tabel voor gemeenschapscriterium}
\label{tabel:evaluatie-gemeenschap}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Productiviteit}
\label{sec:evaluatie-productiviteit}

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  col sep=comma,
  string type,
  header=true,
  columns={Productiviteit,jQM,ST,Kendo,Lungo},
  columns/Productiviteit/.style={column name=\textbf{Productiviteit}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqm}, column type={c}},
  columns/ST/.style={column name=\textbf{\st}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendo}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungo}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
    after row=\bottomrule}
]{tabellen/productiviteit.csv}
\caption{Samenvattende tabel voor productiviteitscriterium}
\label{tabel:evaluatie-productiviteit}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Gebruik}
\label{sec:evaluatie-gebruik}
Het gebruik van de vier raamwerken wordt samengevat in tabel \ref{tabel:evaluatie-gebruik}.
Het wordt opgedeeld per uitdaging en vervolgens zal het per sectie uitvoerig worden besproken per raamwerk.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik.csv}
\caption{Samenvattende tabel voor gebruik}
\label{tabel:evaluatie-gebruik}
\end{table}

%%%%%%%%%%%%%

\subsection{U1: Formulieren}
In tabel \ref{tabel:evaluatie-gebruik-u1} worden de resultaten getoond van de vijf deeluitdaging van U1: Formulieren.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  skip coltypes=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u1.csv}
\caption{Gebruik voor U1: Formulieren}
\label{tabel:evaluatie-gebruik-u1}
\end{table}


\paragraph{\jqm} 
Voor het toevoegen van \term{placeholders} in de formuliervelden kon beroep worden gedaan op het \code{placeholder}-attribuut in HTML5. 
Labels zijn verplicht in \jqm{}, maar kunnen onzichtbaar worden gemaakt met de CSS-klasse \code{ui-hide-label}~\cite{JQuery2013}. 
Wat wel opmerkelijk is wanneer men een formulier invult, daarna verstuurt en dan terugkeert, het formulier nog alle waarden bevat. 
Men moet na het formulier te hebben verstuurd, zelf het formulier altijd leegmaken. 
Dit kan met behulp van \js{} via de \code{reset()}-functie op het formulier.
 
Voor de types van de formuliervelden werd beroep gedaan op de volgende types: \code{text}, \code{number} en \code{email}. 
%Deze zorgen ervoor dat op de mobiele apparaten aangepaste toetsenborden te voorschijn komen. 
Het \code{date} type werd echter niet gebruikt om wille van twee redenen.
Ten eerste was hiervoor een slechte ondersteuning naar mobiele browsers toe~\cite{Deveria2013b}.
Android~2.3 ondersteunt dit niet en de \term{placeholder}-tekst in het veld ontbrak op iOS~6 en Android~4.2.
Hierdoor weet de gebruiker in eerste instantie niet wat hij hier moet invullen. 
Zelf een \term{placeholder} instellen is onmogelijk voor een \code{date}-type~\cite{Berjon2012}. 
Een tweede probleem was het opleggen van het bereik van datums, wat met het \code{date}-type onmogelijk is. 
Beide problemen werden opgelost door gebruik te maken van de Date \& Time Picker van Mobiscroll~\cite{Mobiscroll2013} die ook aangepaste lay-out heeft conform met die van \jqm{}. 
Het veld heeft dan wel het type \code{text}.
Het is dus in principe mogelijk om iets anders dan een datum in te geven. 
Dit wordt belet door ook nog eens een datumvalidatie (zie \ref{sec:evaluatie-gebruik-u3}) te doen op dit tekstveld mocht de plug-in het niet hebben afgedwongen.
 
Het was ook nodig om enkel de maand en jaar in te geven als datum, dus zonder dag.
Ook hier kon niet het \code{date}-type gebruikt worden, omdat daar ook een dag voor nodig is. 
Daardoor werden de maanden handmatig geprogrammeerd als vaste lijstitems. 
De jaren zijn dynamisch en zijn telkens dit jaar, het volgende en het vorige jaar. 
Deze functionaliteit kon ook met de plug-in van Mobiscroll worden verwezenlijkt.

\paragraph{\st} 
% Placeholders, text, email and number fields are supported by the framework and can be easily created.  
% Labels can be avoided by not defining them.  
% Creating custom datepickers is not supported.  
% It is impossible to ignore the days field and only years can be delimited.  
% Clearing the form after it was send, has to be programmed manually.
Een formulier wordt in \st{} \code{fielset} genoemd.
Een \code{view} van een formulier voorzien kan door in de rij van elementen een object met \code{xtype} \code{fieldset} te maken.
Dit object kan op zijn beurt voorzien worden van een rij van elementen.
Volgende velden worden aangeboden in \st{}:
\begin{itemize}
  \item \code{textfield}        Ext.field.Text
  \item \code{numberfield}      Ext.field.Number
  \item \code{emailfield}	 Ext.field.Email			
  \item \code{textareafield}    Ext.field.TextArea
  \item \code{hiddenfield}      Ext.field.Hidden
  \item \code{radiofield}       Ext.field.Radio
  \item \code{checkboxfield}    Ext.field.Checkbox
  \item \code{selectfield}      Ext.field.Select	
  \item \code{togglefield}      Ext.field.Toggle
  \item \code{fieldset}         Ext.form.FieldSet
\end{itemize}

Tekst-, email en nummervelden worden bij het renderen tot HTML5-invoertypes omgevormd en bijgevolg worden op mobiele toestellen bijhorende virtuele toetsenborden weergegeven.
Een placeholder toevoegen kan door een veld met \code{placeholder} eigenschap te voorzien en de waarde aan de gewenste placeholder gelijk te stellen. 
Een label toevoegen verloopt analoog,  deze weglaten zal geen label renderen.

Een aangepaste \term{datepicker} maken is niet standaard voorzien.
Een standaard \term{datepicker} is echter wel voorzien met \code{datepicker} als xtype.
Deze kan enkel geconfigureerd worden door een begin- en eindjaar in te stellen.
Een \term{datepicker} maken waarbij het bereik kleiner is dan een jaar, is niet mogelijk.
Ook is het onmogelijk om enkel een maand- en jaarveld te tonen.

%TODO challenge bekijken (enkel reset oproepen normaal ok )
Het leegmaken van een formulier gebeurt niet automatisch wanneer het verzonden wordt.
Hiervoor moet de \code{reset} methode op het bijhorende \code{formpanel} worden opgeroepen.

\paragraph{\kendo}
 Formulierelementen definiëren kan via data-attributen door gebruik te maken van de opmaakgedreven aanpak van \kendo.
 Deze methodologie volgt dus sterk de HTML5-standaard.
 Het placeholder attribuut kan een placeholder definiëren,  het vermijden van een label zal geen labels genereren.
 Het type van het formulierelement moet met het type attribuut worden weergegeven.
 Volgende types worden door \kendo{} ondersteund:
 \begin{itemize}
  \item \code{text}
  \item \code{password}
  \item \code{search}
  \item \code{url}
  \item \code{email}
  \item \code{number}
  \item \code{tel}
  \item \code{file} (niet in iOS)
  \item \code{date}
  \item \code{timemonth} 
  \item \code{datetime}
 \end{itemize}

 \term{Datepickers} worden als widget aangeboden in het Web luik van \kendo{}.
 Het raamwerk zal een invoerelement omvormen naar een \code{kendoDatePicker}.
 Het invoerelement ziet er als volgt uit: \code{<input id=\"datepicker\"\/>}.  
 Vervolgens moet het element worden geïnitialiseerd met \code{\$("\#datePicker").kendoDatePicker()}.
 De datepicker is aanpasbaar zoals gevraagd in de POC.
 Het bereik van de data selectie kan worden ingeperkt door de \code{min} en \code{max} eigenschap van de \code{kendoDatePicker} te zetten.
 Deze eigenschappen worden bij initialisatie van het object meegegeven.
 Enkel maand- en jaarvelden tonen kan door de diepte van de \term{datepicker} in te stellen.
 Hiervoor moet de eigenschap \code{depth} aan \code{year} worden gelijkgesteld.
 
 Het wissen van formulieren steunt op de MVVM-architectuur.
 Een fomulier is gebonden aan een \code{(view)model}:  de inhoud van elk formulierelement komt overeen met de waarde van een eigenschap van een \code{(view)model} met dezelfde naam.
 Wanneer een uitgave wordt verzonden, zal de huidige waarde van het \code{(view)model} in een \js-object worden opgeslagen en wordt het \code{(view)model} gereset.
 Door de dubbele binding tussen formulier en \code{(view)model} zal ook de inhoud van de formulierelementen worden gewist.
 
 
\paragraph{\lungo} 
Het toevoegen van \term{placeholders} in de formuliervelden gebeurt met het HTML5-atttribuut \code{placeholder}.
In \lungo{} zijn labels niet verplicht.
Indien deze niet gewenst zijn, kunnen deze gewoon uit de HMTL5-code weggelaten worden.

De types \code{text}, \code{number} en \code{email} voor formuliervelden worden verwezenlijkt door deze als type voor de \code{input}-tags mee te geven in het formulier.
Gelijkaardig met de twee aangehaalde problemen voor \jqm{}, werd niet gekozen voor het \code{date}-type, maar een plug-in om de functionaliteit met datums op te lossen.
De \code{date-picker} werd gebruikt van de plug-in pagina van Lungo zelf~\cite{TapQuo2013b}.
Bij deze plug-in is al voorbeeldcode aanwezig die nodig is om automatisch een \term{datepicker} te openen en de aangeklikte datum in het formulierveld te zetten.
De plug-in laat echter niet toe om een bereik op te geven.
De datum met enkel een maand en jaar diende handmatig geprogrammeerd te worden omdat de aangeboden plug-in hiervoor geen ondersteuning bood.

Het legen van een formulier gebeurt in Lungo door de \code{reset}-functie in \js{} op te roepen op dat formulier.

%%%%%%%%%%%%%

\subsection{U2: Invullen van formulier}
In tabel \ref{tabel:evaluatie-gebruik-u2} worden de resultaten getoond van de twee deeluitdaging van U2: Invullen van formulier.
Onder de tabel wordt per raamwerk verklaard waarom dat resultaat werd behaald.

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u2.csv}
\caption{Gebruik voor U2: Invullen van formulier}
\label{tabel:evaluatie-gebruik-u2}
\end{table}

\paragraph{\jqm}
Om een formulierveld in te vullen met data, dient eerst het formulierveld gezocht te worden en daarna zijn waarde gezet te worden.
Dit gebeurt typisch voor tekstvelden volgens de volgende code: \code{\$("\#form-veld").val("waarde")}.
Bij het \code{select}-type voor een veld kan deze code niet worden gebruik.
Hier moet de waarde worden gezocht in de lijst en dan aan de gevonden waarde het \code{selected}-attribuut worden toegevoegd.
Een gelijkaardige manier dient gevolgd te worden voor het \code{radio}-type voor een veld.
Ook hier moet eerst de waarde worden gezocht, waarna aan de gevonden waarde het \code{checked}-attribuut wordt toegevoegd.
Het vullen van formuliervelden wordt niet door \jqm{} geautomatiseerd, wat betekent dat dit dus voor iedere formulierveld dient te gebeuren.

Het \term{read-only} maken van velden gebeurt via het HTML-attribuut \code{readonly}.
Dit geld voor alle types van velden, behalve voor \code{radio}-elementen en \code{select}-items waar \code{disabled} wordt gebruikt.
Voor \code{select}-items moeten de andere niet-benodigde lijstitems verwijderd worden, want deze kunnen nog steeds aangeklikt worden.

\paragraph{\st}
Het invullen van een formulier wordt ondersteund door de MVC-architectuur.
Twee verschillende methoden worden in de POC gebruikt.
Een eerste maakt gebruik van de \code{setRecord} methode van een \code{formpanel}.
De modelinstantie die het formulier zal invullen als parameter worden meegeven.
\st{} zal automatisch de velden invullen waarbij de naam gelijk is aan de eigenschap van het model.
Zo kan tekst op tekstvelden worden gemapt,  nummers op numerieke velden en \code{booleans} op \code{togglefields}.
Een opmerking over het invullen van een \code{radiofield} moet worden gemaakt.
Een model kan worden voorzien met eigenschappen met volgende types:
\begin{itemize}
  \item auto (Default, implies no conversion)
  \item string
  \item int
  \item float
  \item boolean
  \item date
\end{itemize}
Er bestaat dus geen vlekkeloze mapping tussen een eigenschap van een model en een \code{radiofield}.
Hetzelfde geldt voor een \code{checkboxfield}.
Om deze in te vullen moet de \code{setGroupValue} van het veld worden aangesproken.


%TODO u13 lijsten en click invullen van formulier,  hier ook...
De tweede methode voor het invullen van formulieren maakt gebruikt van een \code{navigationview} en wordt in U13: Lijsten besproken.

Velden read-only maken kan door objecten te voozien van de \code{readOnly} eigenschap en de waarde op \code{true} te zetten.
Bij \code{radiofields} en \code{checkboxfields} heet deze eigenschap \code{disabled}.


\paragraph{\kendo}
Het invullen van een formulier steunt ook op de MVVM-architectuur en is gelijkaardig aan het resetten van een formulier.
De dubbele binding tussen een formulier en \code{(view)model} wordt met de HTML-tag \code{data-model} aangegeven.
Een \code{viewmodel} wordt in \kendo{} \code{ObservableObject} genoemd.
Een \code{model} heet \code{Model} en erft over van een \code{ObservableObject}.
Deze laatste breidt een \code{ObservableObject} uit met de mogelijkheid om schema's,  velden en methoden te definiëren.  
In wat volgt zal aangenomen worden dat een \code{ObservableObject} wordt gebruikt in plaats van een \code{Model},  tenzij anders vermeld.
Om een formulier met data te vullen is het de taak van de programmeur de velden van het \code{ObservableObject} van de correct waarden te voorzien.
De gebonden formulierelementen zullen vervolgens automatisch worden ingevuld.


Read-only velden moeten in het data-attribuut van het formulierelement worden gespecificeerd.
Alle invoer types buiten radio- en selectknoppen gebruiken hiervoor het \code{readOnly} sleutelwoord.
Radio- en selectknoppen worden onbeschikbaar met het \code{disabled} sleutelwoord.

\paragraph{\lungo}
Velden vullen met data dient handmatig te gebeuren door eerst het formulierveld op te zoeken en daarna de waarde te zetten.
Dit gebeurt typisch volgens de volgende code: \code{\$\$("\#form-veld").val("waarde")}.
Deze functie kan ook gebruikt worden voor \code{select}-types.
Geoptimaliseerde mobiele lay-out voor \code{radio}-types is niet aanwezig in \lungo.
Een opmerking dient wel gemaakt te worden dat de waarde altijd een \code{string} moet zijn.
Dit betekent dus voor getallen dat deze altijd eerst moeten worden omgevormd met de \js{}-functie \code{toString()}. 

Het \term{read-only} maken van velden gebeurt via het HTML-attribuut \code{readonly}.
Dit gaat voor alle types van velden, behalve voor \code{select}-types.
Daar worden de niet-benodigde lijstitems verwijderd en wordt de \code{select} zelf \code{disabled} gemaakt.


\subsection{U3: Formuliervalidatie}
\label{sec:evaluatie-gebruik-u3}

\paragraph{\jqm}
% Sommige formuliervelden waren verplicht in te vullen, terwijl andere niet. 
% Hiervoor werd eerst gedacht om het \code{required} attribuut in HTML5 te gebruiken. 
% Het probleem is echter dat er geen ondersteuning is voor mobiele browsers~\cite{Deveria2013}. 
% Daarnaast was het ook nodig om de velden te valideren op hun waarde. 
% Validatie is echter niet standaard aanwezig in jQuery Mobile. 
% Als oplossing werd de plug-in van Jörn Zaefferer gebruikt~\cite{Zaefferer2013}. 
% Deze plug-in loste ook het probleem met de verplichte velden op. 
% Deze plug-in kan op twee manieren gebruikt worden: enerzijds annoteren van de formuliervelden met speciale CSS klassen ofwel anderzijds door programmatie met JavaScript. 
% Beide aanpakken werden getest doorheen de POC. 
% 
% De plug-in bevatte de volgende ingebakken validatieregels nodig in de POC: \code{required}, \code{number}, \code{email} en \code{date}.
% Daarnaast was het nodig dat een veld verplicht was enkel indien een bepaalde optie aangevinkt was.
% Zo'n afhankelijkheidsrelatie is standaard aanwezig in de plug-in.
% 
% Bij fouten tegen validatie moest een dialoogvenster worden weergegeven met daarin een beschrijving van alle foute velden.
% Aangezien de plug-in standaard onder het foute formulierveld een foutboodschap toont, diende de plug-in  te worden aangepast.
% Door de uitgebreide API van de plug-in die ook uitvoerig gedocumenteerd is, konden alle foutboodschappen samen in een dialoogvenster worden weergegeven.
% 
% Een specifiek mobiel probleem was bij het tonen van het dialoogvenster, waarbij de plug-in op de achtergrond de cursor op het eerste veld zette. 
% Hierdoor verscheen het toetsenbord op het scherm van het mobiele apparaat wanneer het dialoogvenster tevoorschijn kwam, wat niet de bedoeling is. 
% Dit werd opgelost door \code{focusInvalid:false} in te stellen in de plug-in.
% 
% Bij het sluiten van het dialoogvenster dienden de foute velden met een rode rand te worden gemarkeerd.
% Aangezien de validatie plug-in de foute velden annoteert met de \code{error} CSS klasse, kon de rode rand in CSS worden geprogrammeerd. 
% Dit ging voor \code{input} en \code{textarea}, maar gaf problemen voor \code{select} en \code{fieldset}.
% Door de extra code die jQuery Mobile genereert rond deze velden, moest via de DOM de omringende code geannoteerd worden om de rode rand te bekomen. 
% Deze functie kon aangehaakt worden op de \code{highlight} en \code{unhighlight} functies van de plug-in.

\paragraph{\st}
Een model kan worden voorzien van validatieregels.
Deze regels worden als objecten in een rij aan de \code{validations} eigenschap van een model toegekend.
Volgende validatieregels zijn ingebouwd:
\begin{description}
  \item [presence] verzekert dat het het veld een waarde heeft waarbij nul als geldig wordt beschouwd,  lege tekst niet.
  \item [length] verzekert dat een text een minimale en/of maximale waarde heeft.
  \item [format] verzekert dat een text voldoet aan een opgegeven reguliere expressie.
  \item [inclusion] verzekert dat de waarde van een veld gelijk is aan een element van een gespecifieerde set.
  \item [exclusion] verzekert dat de waarde van een veld zeker niet gelijk is aan een element van een gespecifieerde set.
\end{description}
De controle of een opgegeven waarde een nummer is kan met de \code{format} regel en de \code{/\d+/} reguliere expressie.
Om een bepaalde modelinstantie te valideren moet de \code{validate} methode op de instantie worden opgeroepen.
Om eigen validatieregels toe te laten moet de implementatie van deze methode worden overschreven. \footnote{Informatie gevonden op \exturl{www.sencha.com/forum/showthread.php?122680-Conditional-fields-validations}}
Deze functionaliteit zit dus niet standaard in \st{}.
Met de nieuwe \code{validate} methode kan een \code{validator} aan een validatieregel worden toegevoegd.
Dit is een functie die de programmeur zelf bepaalt en \code{true} of \code{false} teruggeeft bij het al dan niet slagen van een conditie.

Het opbouwen van een foutenboodschap kan door te itereren over de fouten die na validtie werden teruggevonden.
Een specifieke foutenboodschap kan aan elke validatieregel worden toegekend.

Invalide formulierelementen aanduiden met een rode rand wordt niet door \st{} ondersteund.
Hiervoor moet CSS worden gebruikt.
Foutief ingevulde formulierelementen moeten na valiatie met een CSS-klasse worden aangevuld.

\paragraph{\kendo}
Het \kendo{} raamwerk ondersteunt de validaties zoals aangeboden binnen HTML5:
\begin{itemize}
  \item [required] verzekert dat een het veld een waarde heeft.
  \item [pattern] verzekert dat de waarde van een veld voldoet aan een opgegeven reguliere expressie.
  \item [min/max] verzekert dat de waarde van een veld groter en/of kleiner is dan een opgegeven waarde.
  \item [data types] verzekert dat de waarde van een veld gelijk is aan het opgegeven type (e-mail, url, number, enz.)
\end{itemize}
Deze validaties moeten binnen het data-attribuut van het formulierelement worden aangebracht.

De \kendo{} \code{validator} is compatibel met deze HTML5-validaties.
Een \code{validator} moet in \js worden aangemaakt met volgend commando:  \code{\$("\#myform").kendoValidator().data("kendoValidator")}.
Hierbij kan de jQuery selector eender welk element uit het DOM aanduiden.
De \code{validator} zal geselecteerde invoerelementen controleren op validatieregels.

Eigen condities kunnen als validatieregels worden geformuleerd als \js-functie die \code{true} teruggeeft als de validatie slaagt.
Deze functie kan aan de set van regels van een \code{validator} worden toegevoegd.
De validatiecontrole starten kan door de \code{validate} methode op de \code{validator} op te roepen.
Bij het controleren van invoerelementen worden altijd eerst de standaard validatieregels gecontoleerd,  daarna de eigen validatieregels.
De volgorde waarin de controles worden uitgevoerd ligt vast en zal stoppen zodra één controle mislukt.

%TODO mijn tricky implementatie van other -> remkars validatie vermelden?

Validatieberichten kunnen voor standaard validaties door het raamwerk zelf worden opgebouwd.
Deze kunnen worden overschreven door zelf een data-attribuut \code{validationMessage} aan het invoerelement toe te kennen.
Bij eigen validatieregels kan een validatiebericht per regel worden gespecificeerd.

Invalide formulierelementen aanduiden met een rode rand wordt niet door \kendo{} ondersteund.
De standaard implementatie voorziet een \code{tooltip} per invalied veld.
Deze zal het validatiebericht naast het invalide formulierelement plaatsen. 

Een venster tonen waarbij alle foutenboodschappen zijn samengevat is ook niet standaard aanwezig.
De \code{errors} methode van een \code{validator} geeft een rij van foutenboodschappen terug.
De volledige foutenboodschap moet vervolgens worden geconstrueerd door alle foutenboodschappen te concateneren.
Hoe een dialoogvenster gemaakt wordt zal in U11.2 Toon dialoog worden besproken.

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  ignore chars={\"},
  verb string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u3.csv}
\caption{Scores voor U3: Formuliervalidatie}
\label{tabel:evaluatie-gebruik-u3}
\end{table}

\subsection{U4: Handtekening}

\paragraph{\jqm}
% Er werd gezocht naar een plug-in om deze functionaliteit te bekomen, doordat jQuery Mobile dit niet standaard aanbiedt. 
% Eerst werd gewerkt met Signature Pad van Thomas Bradley~\cite{Bradley2013}. 
% Door de lange tijd die werd besteed aan het aanpassen van layout, werd overgestapt naar jSignature van Willow Systems~\cite{Systems2013}. 
% Deze laatste gaf ook het voordeel dat de breedte van het gebied om te handtekening in te zetten, zich automatisch naar 100\% schaalde. 
% De plug-in maakt gebruik van het HTML5 canvas element en de \code{.toDataURL()} methode.
% Deze wordt echter niet ondersteund op Android versies 2.3 en lager~\cite{Systems2013} waardoor de functionaliteit op die toestellen niet werkt.

\paragraph{\st}
Het tekenen van een handtekening steunt op een plug-in van SimFla~\cite{SimFla2011} en is in de Sencha Market te vinden op \exturl{market.sencha.com/extensions/signature-pad-field}.
Een plug-in aan het raamwerk toevoegen kan door het \js-bestand in de touch/src/ux folder te plaatsen.
Vervolgens moet de plug-in worden geladen bij het initialiseren van de applicatie.

De plug-in maakt een nieuw xtype \code{signaturefield} beschikbaar dat als veld in een formulier kan worden gebruikt.

De plug-in maakt gebruikt van het HTML5-canvas en retourneert de handtekening als geëncodeerde base64 text.


\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u4.csv}
\caption{Scores voor U4: Handtekening}
\label{tabel:evaluatie-gebruik-u4}
\end{table}

\subsection{U5: Toon PDF}

\paragraph{\jqm}
% Het is niet aangeraden om ruwe data, zoals een PDF, op te halen via AJAX. 
% Hierdoor werd gebruik gemaakt van een verborgen formulier met de nodige parameters die de PDF ophaalt bij de backend. 
% Bij het klikken op een lijstitem in het overzicht, wordt dit verborgen formulier opgestuurd naar de backend die dan een PDF teruggeeft in de browser. 
% Het weergeven van de PDF wordt overgelaten aan het mobiel apparaat dat de correcte applicatie hiervoor opstart.

\paragraph{\st}
Het tonen van een PDF steunt op een plug-in van Fiedler~\cite{Fiedler2012} en kan op de Sencha Market gevonden worden op \exturl{market.sencha.com/extensions/pdf-viewer-panel}.
Het tonen van een PDF-bestand kan door de huidige \code{view} te wijzigen naar een \code{Ext.ux.PDF view}.
Deze \code{view} bestaat uit een paneel met een hoofdtekst.
Het paneel toont één pagina van het PDF-bestand,  de hoofdtekst bevat de navigatie naar andere pagina's.

Om de plug-in in de POC in te passen waren echter twee aanpassingen noodzakelijk.
Het PDF-bestand moet via een POST verzoek worden opgehaald waarbij parameters het exacte PDF-bestand aanduiden.
Ook moest er een terugknop in de hoofdtekst van het paneel worden aangebracht om terug naar het overzicht van doorgestuurde formulieren te gaan.
Beide aanpassingen moesten in het \js-bestand van de plug-in worden aangebracht.

\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u5.csv}
\caption{Scores voor U5: Toon PDF}
\label{tabel:evaluatie-gebruik-u5}
\end{table}

\subsection{U6: Toevoegen van afbeelding}

\paragraph{\jqm}
% Het opladen van een bestand kan gebeuren door \code{file} als invoertype van het formulierveld te gebruiken. 
% In versie 1.2 wordt dit veld nog niet opgemaakt met lay-out, maar dit gebeurt wel in versie 1.3~\cite{JQuery2013d}. 
% Voor het kan worden doorgestuurd naar de backend, moet het bewijs eerst lokaal worden omgevormd naar base64. 
% Dit werd geïmplementeerd met de FileReaderAPI en het canvas, wat beide HTML5 specificaties zijn. 
% Het aangeklikte bestand wordt gelezen door middel van de FileReaderAPI, waarna het als afbeelding wordt opgeslagen en geïmporteerd wordt op het canvas. 
% Eenmaal geïmporteerd, kan men de \code{.toDataURL()} oproepen op het canvas om de geïmporteerde afbeelding om te vormen naar base64. 
% Deze aanpak werkt correct op recente mobiele apparaten. 
% De FileReaderAPI wordt echter niet ondersteund op Android versies 2.3 en lager of iOS versies lager dan 6.0~\cite{Deveria2013a} waardoor het opladen van een bewijs niet werkt.
% 
% Het voorvertonen van het geüploade bestand hangt af van het mobiele besturingssysteem.
% Zo wordt op iOS 6 een miniatuurafbeelding getoond, terwijl op Android de bestandsnaam wordt getoond.
% Het is natuurlijk ook mogelijk om de preview na conversie zelf te tonen op het scherm.
% Bij iOS zouden er dan twee voorvertoningen te zien zijn op hetzelfde scherm.

\paragraph{\st}
Het opladen van een afbeelding steunt op een plug-in van Smirnov~\cite{Smirnov2012} en kan in de Sencha Market gevonden worden op \exturl{market.sencha.com/extensions/file-uploading-component-for-sencha-touch}.
De plug-in is generiek voor het opladen van elk type bestand,  niet uitsluitend afbeeldingen.
Het \js-bestand moet in de touch/src/ux folder worden geplaatst en de \code{Ext.ux.Fileup} klasse moet worden geïnitialiseerd.
Het xtype \code{img} wordt dan beschikbaar voor \st{} componenten.

De plug-in voorziet twee modes voor het opladen van bestanden: lokale als base64 of extern naar een server.
De eerste laat toe afbeeldingen in het DOM of \term{local storage} te laden.
Dit laatste is een aspect van de POC.

Nadat een bestand is opgeladen kunnen twee gebeurtenissen zich voordoen:  \code{loadsuccess} of \code{loadfailure}.
Het is de taak van een \code{controller} om deze gebeurtenissen op te vangen en een bijhorende methode te definiëren.
De succes functie krijgt de base64 text mee en kan een voorbeeld van de afbeelding laten weergeven.

\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u6.csv}
\caption{Scores voor U6: Toevoegen van afbeelding}
\label{tabel:evaluatie-gebruik-u6}
\end{table}

\subsection{U7: Auto-aanvullen}

\paragraph{\jqm}

% Hoewel versie 1.3 automatische aanvulling ter beschikking heeft~\cite{JQuery2013c}, werd tijdens de implementatie gebruik gemaakt van versie 1.2 die dit niet had. 
% Daarom werd de plug-in van Andy Matthews gebruikt~\cite{Matthews2013}. 
% Dit is een zeer gemakkelijk te integreren plug-in die zowel met lokale data als data op afstand kan werken. 
% Daarnaast dienden enkel vijf suggesties te worden getoond. 
% Deze functionaliteit zat niet in de plug-in, maar werd geïmplementeerd met de JavaScript \code{slice} functie.

\paragraph{\st}
Het automatisch aanvullen van een formulierelement steunt op een plug-in van Tajur~\cite{Tajur2012}.
Deze plug-in is niet op de Sencha Market terug te vinden.
Door het \js-bestand toe te voegen wordt het xtype \code{autocompletefield} beschikbaar.
Een object met dit xtype kan een \code{proxy} definiëren die de server kan aanspreken om suggesties asynchroon op te halen.
Ook is het mogelijk het maximaal aantal suggesties vast te leggen.

De \term{backend} server die bij de POC hoort geeft bij een bepaald sleutelwoord suggesties in een JSON-rij terug.
De rij is voorzien van een sleutel maar alle elementen van de rij hebben geen sleutel.
\st{} voorziet vier methoden om de resultaten van een \code{proxy} te parsen naar modelinstanties:
\begin{description}
 \item [\code{JsonReader}] parst JSON-sleutels naar model velden.
 \item [\code{XmlReader}] parst XML-tags naar model velden.
 \item [\code{ArrayReader}] mapt elementen van een rij op velden van een model.
\end{description}
Geen van voorgaande methoden was in staat de rij met suggesties te parsen van rij-element naar modelinstantie.
Hierdoor kon geen klikbare dropdownmenu worden getoond.

\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u7.csv}
\caption{Scores voor U7: Auto-aanvullen}
\label{tabel:evaluatie-gebruik-u7}
\end{table}

\subsection{U8: AJAX}

\paragraph{\jqm}

% Het maken van oproepen via AJAX gebeurt via de jQuery bibliotheek waar jQuery Mobile op steunt. 
% Dit gebeurt met de functie \code{\$.ajax} waar onder andere kan ingesteld worden wat het te verwachten antwoord is (zoals tekst, JSON of XML). 
% Bij het succesvol uitvoeren van de oproep wordt de \code{succes} functie opgeroepen, bij faling de \code{error} functie waarna een relevante foutboodschap wordt getoond.
% Het afmelden zonder antwoord, het aanmelden voor het bekomen van het token (tekst), het ophalen van de gebruikersgegevens (JSON), het ophalen van de uitgaveformulieren (XML) en het ophalen van de omwisselingskoersen (XML) ging zonder enig probleem.

% In jQuery is er de functie \code{parseJSON} aanwezig, maar aangezien we in de AJAX oproep instellen dat we JSON verwachten, parst jQuery al automatisch het antwoord. 
% Hierdoor hebben we \code{parseJSON} niet nodig en kunnen we direct omgaan met het antwoord.
% 
% Het is ook nodig om JSON te versturen als oproep naar de backend. 
% Dit wordt gedaan vanuit JavaScript zonder een jQuery nodig te hebben. 
% Eerst wordt een object met de nodige inhoud aangemaakt, waarop daarna de functie \code{JSON.stringify} opgeroepen wordt die het object in een string omzet.
% Deze is daarna klaar om te worden verstuurd als data via een AJAX oproep met behulp van jQuery.

% Net zoals bij JSON het geval was, was het ook niet nodig om expliciet de \code{parseXML} functie te gebruiken. 
%Het doorlopen en opvragen van gegevens uit het XML-bestand vraagt meer werk. 
%Waar je bij JSON direct aan de data kon, moet je bij XML de data ophalen net zoals je dat zou doen uit een HTML-pagina. 
%Dit betekent dus met selectoren aan de hand van de jQuery bibliotheek.

\paragraph{\st}
AJAX-verzoeken kunnen zowel expliciet via een directe oproep met \code{Ext.Ajax.request} als impliciet via \code{stores} worden uitgevoerd.
De expliciete oproep is gelijkaardig aan de \code{\$.ajax} methode van jQuery.
Een enige uitzondering is te vinden bij kruis-domein AJAX-verzoeken.
Om aan de CORS-standaarden (Cross-Origin Resource Sharing) te voldoen moet de eigenschap \code{useDefaultXhrHeader} op \code{false} worden gezet.
%TODO referentie cors + opzoeken options request

De tweede,  impliciete,  methode voor AJAX-verzoeken is via \code{stores}.
Een \code{store} wordt voorzien van een \code{proxy}.  
Deze kan data aan de klant of server zijde opslaan.  
Een \code{proxy} voor opslag aan client zijde kan zowel in het RAM-geheugen als in de \term{local storage} en \term{session storage} van de browser opslaan.  
Een \code{proxy} voor server opslag kan data verzenden via AJAX (zelfde domein) of JSONP (verschillende domeinen).  
Een \code{proxy} kan ook geconfigureerd worden met \code{readers} en \code{writers} om data van de server te lezen of naar de server te schrijven.

Het verzenden van een JSON-\term{payload} moet via een expliciet AJAX-verzoek gebeuren.
Data kan via \code{Ext.encode} naar JSON worden geëncodeerd en via de \code{jsonData} eigenschap aan het verzoek worden gekoppeld.

\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u8.csv}
\caption{Scores voor U8: AJAX}
\label{tabel:evaluatie-gebruik-u8}
\end{table}

\subsection{U9: Toestelspecifieke lay-out}

\paragraph{\jqm}
TODO

\paragraph{\st}
\st{} ondersteunt het herkennen van de context waarin de applicatie wordt gebruikt.
\st{} kan zowel besturingssysteem, browser als ondersteunde (HTML5-)kenmerken opvragen en herkennen.
Het besturingssysteem kan bevraagd worden via \code{Ext.os.name}.
Deze methode herkent onder andere Android, iOS, Windows en BlackBerry.
Er kan ook gebruik worden gemaakt van de \term{singleton} klasse \code{Ext.os.is}.
Zo geeft \code{Ext.os.is.Android} terug of Android het gebruikte besturingssysteem is of niet.
Het opvragen en herkennen van browser en (HTML5-)kenmerken gebeurt op een analoge manier.


\st{} voorziet vijf lay-outs die aan een component kunnen worden toegekend:
\begin{description}
 \item [\code{HBox}] plaatst de componenten horizontaal naast elkaar.
 \item [\code{VBox}] plaatst de componenten verticaal onder elkaar.
 \item [\code{Card}] plaatst de componenten boven elkaar.
 \item [\code{Fit}] maakt de component passend voor zijn ouder container.
 \item [\code{Docking}] maakt het plaatsen van extra componenten mogelijk in de top-, rechter-, bodem- of linkerrand van zijn ouder container.
\end{description}
De creatie van de tablet lay-out steunt op de \code{HBox} lay-out.
De \code{flex} eigenschap van deze lay-out definieert de ratio van de groottes van beide componenten.
De creatie van de smartphone lay-out maakt het menu in de linkse component van de lay-out onzichtbaar.
Om naar het menu terug te keren moet een extra knop in de hoofdtekst worden toegevoegd die naar het menu navigeert.
\st{} ondersteund geen klikbare hoofdteksten die deze functionaliteit toelaten.

\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u9.csv}
\caption{Scores voor U9: Toestelspecifieke lay-out}
\label{tabel:evaluatie-gebruik-u9}
\end{table}

\subsection{U10: Offline}

\paragraph{\jqm}
TODO

\paragraph{\st}
% U10.1 Bewaar login gegevens
Zoals besproken bij U8: AJAX kan een \code{store} voozien worden van een \code{proxy} die data opslaat aan klantzijde.
Deze \code{store} maakt gebruik van de HTML5-localStorage API.
Om inlog gegevens en onverzonden onkosten lokaal te bewaren moeten twee \code{stores} met deze \code{proxy} worden gedefinieerd.
Een belangrijke opmerking is dat geen twee \code{proxies} aan een \code{store} kunnen worden toegevoegd.
Gegevens van een gebruiker moeten van de server worden opgehaald - met een AJAX-\code{proxy} - en lokaal worden opgeslagen - met een \term{local storage} \code{proxy}.
Hiervoor zijn twee verschillende \code{store} instanties nodig die gesynchronizeerd moeten worden!
Bij het laden van de applicatie zal de \code{store} die gebruikers lokaal opslaat, op data worden gecontroleerd.
Indien er data wordt gevonden,  was de gebruiker reeds ingelogd.
De applicatie zal dan meteen naar het startscherm navigeren.

Om onverzonden uitgaven lokaal op te slaan, moeten de uitgaven ook aan een \code{store} met lokale \code{proxy} worden toegevoegd.
Deze worden dan automatisch naar de \term{local storage} weggeschreven.
De controle op onverzonde uitgaven wordt herleid tot het controleren van data in de \code{store}.
Het verwijderen van onverzonden lokale uitgaven kan door de data in de \code{store} te wissen.

% U10.3 Maak de applicatie offline beschikbaar
De applicatie offline beschikbaar maken wordt ondersteund door Sencha Cmd~\cite{Sencha2012}.

Deze tool kan de initiële applicaties opzetten,  bestanden toevoegen en de applicatie bouwen en deployen.
Een applicatie,  zoals geinitialiseerd door Sencha Cmd,  moet alle benodigde \js-, en CSS-bestanden in een JSON-bestand onderbrengen.
Een \code{microloader} zal de afhankelijke bestanden automatisch laden bij het opstarten van de applicatie.

Het bouwen en deployen van een applicatie kan op vier niveaus:
\begin{description}
  \item [testing] maakt een testapplicatie om de kwaliteit te testen.  \js- en CSS-bestanden worden samengevoegd maar niet verkleind om makkelijk te debuggen
  \item [package] maakt een zelfstandige applicatie die verspreidbaar is en vanop een bestandensyteem,  zonder web server,  kan lopen.
  \item [production] maakt een applicatie die op een webserver beschikbaar wordt gemaakt waarvan de \js-, en CSS- bestanden zijn samengevoegd en verkleind.  Het maakt de applicatie ook offline beschikbaar door gebruik te maken van de HTML5-applicatie cache.  Ook is het mogelijk de applicatie op te waarderen naar een nieuwe versie.
  \item [native] maakt een \term{native} applicatie die op het Android of iOS besturingssysteem kan lopen.
\end{description}
Om de applicatie offline beschikbaar te maken moet de applicatie gebouwd worden voor productie.
De tool zal automatisch een manifest bestand aanmaken die alle vereiste bestanden bevat.

\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u10.csv}
\caption{Scores voor U10: Offline}
\label{tabel:evaluatie-gebruik-u10}
\end{table}

\subsection{U11: Laadscherm en dialoogvenster} 

\paragraph{\jqm}

% Het standaard laadscherm is enkel een \term{spinner} die niet opvallend aanwezig is en ook zonder een tekst eronder ronddraait.
% Door de opties in de API te gebruiken, komt de \term{spinner} duidelijk naar voor en staat er ook een tekst onder.

% Eerst werd gebruik gemaakt van DateBox \cite{Sage2013} als plug-in om op een gemakkelijke manier een dialoogvenster te tonen.
% Uiteindelijk bleek de plug-in niet zo gemakkelijk aanpasbaar en daarenboven zijn dialoogvensters standaard in jQuery Mobile aanwezig.
% Het is dan ook helemaal niet nodig om hiervoor een plug-in te gebruiken.
% Door zelf de dialoogvenster met jQuery Mobile aan te maken, kon de layout minimier aangepast worden.

\paragraph{\st}
Een laadscherm tonen kan door een masker met xtype \code{loadmask} op de huidige \code{view} te plaatsen.
Een object van dit xtype kan een bericht bevatten wat de laadtekst voorstelt.
Het toten van een masker kan door de \code{setMasked} methode op een \code{view} op te roepen.
Een courante aanpak is te werken met de \term{singleton} klasse \code{Ext.Viewport} die de huidige zichtbare \code{view} voorsteld.
Hierop de \code{setMasked} methode oproepen verzekert dat het laadscherm bovenop alle andere schermen wordt geplaatst.

De \code{Ext.Msg} \term{singleton} klasse bevat alle methoden om dialogen weer te geven.
\st{} biedt drie standaarden van dialogen aan: \code{alert}, \code{promt} en \code{confirm}.
De eerste laat de gebruiker een bericht zien,  de tweede vraagt de gebruiker om invoer en de laatste vraagt bevestiging aan de gebruiker.
Deze drie standaarden zijn als methode in \code{Ext.Msg} beschikbaar.
Parameters van de methoden kunnen de titel, tekst en functie van de knoppen bepalen.
Een meer generieke aanpak is het oproepen van de \code{show} methode van \code{Ext.Msg}.
Intern roepen de standaard dialogen deze methode ook op.

\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u11.csv}
\caption{Scores voor U11: Laadscherm en dialoogvenster}
\label{tabel:evaluatie-gebruik-u11}
\end{table}

\subsection{U12: Dataconversie}

\paragraph{\jqm}
TODO

\paragraph{\st}
%TODO score? verplaatsten met lijsten
De omzetting van \code{identifiers} en munteenheden vindt plaats in de overzichtslijsten.  
Lijsten kunnen voorzien worden van een sjabloon om de elementen in de lijst op te maken.
Hierop wordt verder ingegaan in de volgende uitdaging.
In de lijst van uitgaven moet elke uitgave getoond worden met het bedrag in euro.
In het sjabloon voor deze lijst kan een \js-methode worden geplaatst die het bedrag van de uitgave eerst naar euro zal omzetten.
De progammeur heeft toegang tot alle eigenschappen van een model waarvan modelinstanties de lijstelementen zullen bepalen.
De methode die de munteenheid tot euro omvormt, kan dus ook deze eigenschappen gebruiken.
De methode moet echter wel zelf worden geschreven.
Op een analoge manier verloopt de conversie van \code{identifier} naar tekstuele vorm.

%TODO alternatief data geconverteerd opslagen en bij versturen/tonen als detailexpense terug omvormen.

\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u12.csv}
\caption{Scores voor U12: Dataconversie}
\label{tabel:evaluatie-gebruik-u12}
\end{table}

\subsection{U13: Lijsten}

\paragraph{\jqm}
% Het aanmaken van lijsten gebeurt met de \term{listview} widget.

\paragraph{\st}
Zoals besproken in de vorige uitdaging kan een lijst voorzien worden van een sjabloon.
Dit sjabloon kan HTML-code of een instantie van de \code{Ext.XTemplate} klasse zijn.
De eerste definieert met HTML-tags de lay-out van de lijstelementen,  de tweede is geavanceerder.
De functionaliteiten van \code{Ext.XTemplate} zijn:
\begin{itemize}
  \item Doorlopen van een rij.
  \item Conditionele processen met de basis operatoren.
  \item Ondersteuning voor basis wiskundige operaties.
  \item Uitvoeren van willekeurige \js-code.
  \item Eigen functies in het sjabloon oproepen.
\end{itemize}
Het formateren van een datum kan door de \code{date} methode van \code{Ext.util.Format} op te roepen in het sjabloon.

Zoals reeds besproken bij uitdaging U2.1 Vul formulierelementen met data, kan een formulier worden ingevuld met een \code{navigationview}.
Deze \code{view} heeft een \code{push} en \code{pop} methode om een \code{view} op een \code{stack} te plaatsen of af te halen.
Om een \code{view} te tonen die hoort bij een lijstelement wordt gebruik gemaakt van deze \code{navigationview} en de \code{push} methode.
De lijst wordt in een \code{navigationview} ingesloten.
Het aanklikken van een lijstelement veroorzaakt een \code{disclosure} gebeurtenis.
Een \code{controller} kan deze gebeurtenis opvangen en de \code{push} methode op de \code{navigationview} oproepen.
De methode kan geparameteriseerd worden met een modelinstantie, analoog als de \code{setRecord} methode van een formulierpaneel.

Het sorteren van een lijst kan automatisch met een \code{store}.
Een \code{store} kan aan een lijst worden gekoppeld zodat alle modelinstanties van de \code{store} in de lijst worden weergegeven.
De \code{store} moet dan voorzien worden van een \code{sorter}.
Deze kan modelinstanties van een \code{store} sorteren op basis van eigenschappen van het bijhorende model.
Ook kan de richting van sorteren worden geconfigureerd.
Meerdere \code{sorters} definiëren is mogelijk voor het geval er gelijkheden op vorige niveau's optreden.
Een \code{store} sorteren kan ook expliciet door de \code{sort} methode op de \code{store} op te roepen.

\paragraph{\kendo}
TODO

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u13.csv}
\caption{Scores voor U13: Lijsten}
\label{tabel:evaluatie-gebruik-u13}
\end{table}

\subsection{U14: Anatomie van pagina}

\paragraph{\jqm}
TODO

\paragraph{\st}
TODO

\paragraph{\kendo}
Het opbouwen van een \code{view} in \st{} gebeurt hiërarchisch met containers.
Een component die aan een container kan worden toegevoegd is de \code{toolbar}.
Een \code{toolbar} kan zowel bovenaan als onderaan een container worden vastgezet.
Dit kan dan dienstdoen als hoofdtekst en voettekst.
Een cascade van hoofdteksten is door de hiërarchische opbouw van containers mogelijk en laat zo onderkopteksten toe.
Een \code{toolbar} kan voorzien worden van een titel door de \code{title} eigenschap in te vullen.
Knoppen aan een \code{toolbar} toevoegen kan door een lijst van \code{buttons} aan de \code{items} eigenschap toe te voegen.

Het toevoegen van een tabbar verloopt analoog door een \code{tabpanel} toe te voegen.
De \code{items} eigenschap bevat dan een lijst van \code{views} met een titel waarbij de \code{view} zichtbaar wordt als op de titel wordt gedrukt.

Knoppen van kleur veranderen kan door de \code{style} van een knop te zetten.
Deze eigenschap laat toe om CSS-eigenschappen als tekst of object aan de knop toe te voegen.

\paragraph{\lungo}
TODO

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{8cm} p{1cm} p{1cm} p{1cm} p{1cm}},
  end table=\end{tabular},
  skip coltypes=true,
  col sep=comma,
  string type,
  header=true,
  columns={Uitdaging,jQM,ST,Kendo,Lungo},
  columns/Uitdaging/.style={column name=\textbf{Uitdaging}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\midrule,
    after row=\bottomrule}
]{tabellen/gebruik/u14.csv}
\caption{Scores voor U14: Anatomie van pagina}
\label{tabel:evaluatie-gebruik-u14}
\end{table}

\section{Ondersteuning}
\label{sec:evaluatie-ondersteuning}

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  col sep=comma,
  string type,
  header=true,
  columns={Apparaat,jQM,ST,Kendo,Lungo},
  columns/Apparaat/.style={column name=\textbf{Apparaat}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqma}, column type={c}},
  columns/ST/.style={column name=\textbf{\sta}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendoa}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungoa}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
  	before row=\toprule,
 	after row=\bottomrule}
]{tabellen/ondersteuning.csv}
\caption{Samenvattende tabel voor ondersteuningscriterium}
\label{tabel:evaluatie-ondersteuning}
\end{table}

\section{Performantie}
\label{sec:evaluatie-performantie}

\begin{table}[H]
\centering
\pgfplotstabletypeset[
  col sep=comma,
  string type,
  header=true,
  columns={Performantie,jQM,ST,Kendo,Lungo},
  columns/Performantie/.style={column name=\textbf{Performantie}, column type={l}},  
  columns/jQM/.style={column name=\textbf{\jqm}, column type={c}},
  columns/ST/.style={column name=\textbf{\st}, column type={c}},
  columns/Kendo/.style={column name=\textbf{\kendo}, column type={c}},
  columns/Lungo/.style={column name=\textbf{\lungo}, column type={c}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
    after row=\bottomrule}
]{tabellen/performantie.csv}
\caption{Samenvattende tabel voor performantiecriterium}
\label{tabel:evaluatie-performantie}
\end{table}



% TODO Tim: opruimen hieronder
% \subsubsection{Tabbalk}
% 
% \paragraph{jQuery Mobile} 
% Standaard is er een tabbalk aanwezig in jQuery Mobile, maar de POC impliceerde een tabbalk die niet de volledige breedte innam.
% Daarom werd gekozen voor \code{fieldset} met twee opties.
% 
% \subsubsection{Inlogscherm indien niet aangemeld}
% 
% \paragraph{jQuery Mobile} 
% Indien men een applicatie maakt met meerdere schermen op eenzelfde pagina, laadt jQuery Mobile altijd het eerste scherm in de code in.
% Het startscherm werd als eerste scherm gekozen.
% Indien gemerkt wordt dat de gebruiker niet aangemeld was, dan wordt hij doorverwezen naar het inlogscherm.
% 
% \subsubsection{Detail van toegevoegde uitgave}
% 
% \paragraph{jQuery Mobile} 
% Na het toevoegen van een uitgave, is het mogelijk om deze opnieuw te bekijken (maar niet aan te passen).
% Hiervoor wordt hetzelfde formulier (dat om een uitgave toe te voegen wordt gebruikt) gekopieerd, waarna alle elementen op enkel lezen worden gezet.
% Dit was geen probleem voor velden van het type \code{input} en \code{textarea}. 
% Dit kon echter niet  bij \code{fieldset}. 
% Daar moesten via \code{disabled} de andere opties onmogelijk worden gemaakt.
% Eenzelfde probleem gold voor het \code{select} formuliertype bij een buitenlandse uitgave.
% Daar werd enkel de geselecteerde optie in het lijstje getoond en alle andere opties eruit verwijderd.
% 
% Het invullen van het formulier zelf werd bekomen door de \code{id}'s van de velden op te vragen en hun waarde in te stellen volgens de JSON voorstelling van die uitgave. 
% Er is met andere woorden geen automatische mapping van de JSON data naar de formuliervelden. 
% 
% 
% \subsubsection{Omvormen van valuta}
% 
% \paragraph{jQuery Mobile} 
% De omvorming bij een buitenlandse uitgave dient automatisch te gebeuren bij het ingeven van bedrag en munteenheid.
% Hiervoor wordt aangehaakt op het veranderingsevenement \code{.change} dat jQuery aanbiedt, waarna na omvorming het bedrag direct getoond wordt aan de gebruiker.
% 
% \subsubsection{Sorteren}
% 
% \paragraph{jQuery Mobile} 
% Het sorteren van data werd geïmplementeerd door eerst in JavaScript een vergelijkingsfunctie te schrijven.
% Daarna wordt deze functie meegegeven aan de sorteerfunctie die ook in JavaScript aanwezig is.
% Er komt dus geen functionaliteit van het raamwerk om data te sorteren.
% 
% \subsubsection{Offline} 
% TODO
% 
% %%%%%%%
% 
% \subsubsection{Tablet en smartphone}
% 
% \paragraph{jQuery Mobile} 
% In jQuery Mobile is er standaard geen splitview aanwezig om een menu te tonen voor tablets, maar niet voor smartphones. 
% Eerst werd hiervoor gezocht naar plug-ins aan de hand van~\cite{Deering2012}, wat leidde tot: Splitview~\cite{Rahman2013}, SimpleSplitView~\cite{Yared2013} en Multiview~\cite{Franck2012}. 
% Deze drie mogelijke kanshebbers hadden elk hun tekorten. 
% Zo was de eerste destructief ten opzichte van het raamwerk. 
% Dit betekent dat de bestanden van het raamwerk zelf werden aangepast, wat het moeilijker maakt als men wil updaten naar een nieuwe versie. 
% De tweede plug-in werkte enkel tot versie 1.0.1 van jQuery Mobile. 
% De laatste plug-in had moeite met het zich aanpassen aan veranderende afmetingen van de browser. 
% 
% Uiteindelijk werd van een plug-in afgestapt door \cite{Hadlock2012} waarbij werd aangetoond hoe men via CSS3 media queries hetzelfde kan bereiken. 
% Daarnaast gebruikt de documentatie van jQuery Mobile~1.2 een gelijkaardige layout~\cite{JQuery2012b}. 
% De uiteindelijke oplossing voor het probleem kwam uit te combinatie van deze twee voorgaande oplossingen.
% Ook uit de documentatie van versie 1.3 \cite{JQuery2013e} blijkt dat dit de correcte manier is om hiermee om te gaan.
% 
% Navigatie op een smartphone gebeurt door te klikken op de extra titel onder de koptekst. 
% Hierdoor ga je naar een smartphone vriendelijk menu om naar andere stappen te gaan.
% 
% \subsubsection{Koptekst en voettekst}
% 
% \paragraph{jQuery Mobile}
% Het toevoegen van een koptekst en voettekst ging zonder enig probleem door gebruik te maken van \code{data-role="header"} en \code{data-role="footer"}. 
% Wel moest dezelfde code op ieder scherm worden herhaald. 
% Dit kan worden vermeden door gebruik te maken van eenzelfde \code{data-id} attribuut. 
% Daarnaast werd de voettekst gefixeerd aan de onderkant van het scherm en de bijhorende logo's links en rechts uitgelijnd. 
% Voor dit laatste werd gebruik gemaakt van de zogenaamde \term{grid} die jQuery Mobile aanbiedt. 
% Deze voettekst wordt niet getoond op een smartphone, wat wordt bekomen door gebruik te maken van de CSS3 media queries.
% 
% Bij het toevoegen van een uitgave dient er een extra titel onder de koptekst te komen. 
% Eerst werd geprobeerd om bovenaan een lijstdeler te plaatsen, maar dan schoof de inhoud van de pagina niet mee naar onder. 
% De uiteindelijke oplossing kwam vanuit de documentatie \cite{JQuery2013b} om dit met behulp van de \code{ui-bar} CSS klasse te implementeren. 
% Deze extra titel wordt ook gebruikt om op de smartphone naar de speciale smartphone navigatie te gaan (zie ook vorige sectie).
% 
% \subsubsection{Knoppen}
% 
% \paragraph{jQuery Mobile} 
% De kleur van de knoppen aanpassen kan op twee manieren. 
% Ofwel schrijft men zelf de CSS-code ofwel gebruikt men ThemeRoller~\cite{JQuery2012c}. 
% Deze laatste manier werd gebruikt om de knoppen groen te maken. 
% Men sleept dan eenvoudigweg in die webinterface de groene kleur op de knop en daarna kan de bijhorende CSS-code worden gedownload. 
% Door daarna de knop te annoteren met het \code{data-theme} attribuut activeert men het betreffende thema. 
% Om de knop blauw te maken was er geen nood aan een aanpassing, doordat blauw al één van de standaard thema's was en men die direct kan gebruiken.
% 
% Knoppen toevoegen aan de koptekst gaat ook op een zeer eenvoudige manier.
% % TODO: verder schrijven