\chapter{Mobiele HTML5-raamwerken}
\label{chap:raamwerken}

% TODO Tim: Waar zetten we WAAROM we deze raamwerken gekozen hebben en niet de andere?

In dit hoofdstuk wordt ingezoomd op de mobiele HTML5-raamwerken die dit werk vergelijkt, namelijk \jqm{}~(\ref{sec:raamwerk-jqm}), \st{}~(\ref{sec:raamwerk-st}), \kendo{}~(\ref{sec:raamwerk-kendo}) en \lungo{}~(\ref{sec:raamwerk-lungo}).
In de laatste sectie (\ref{sec:raamwerken-tabel}) wordt een tabel weergegeven, waarin deze gegevens worden vergeleken.

\section{\jqm}
\label{sec:raamwerk-jqm}
\jqm{} is een mobiel HTML5-raamwerk dat werd aangekondigd in 2010 en hoofdzakelijk gebruikersinterface-elementen (GI-elementen) aanbiedt~\cite{Resig2010}.
In november 2011 werd versie~1.0 uitgebracht~\cite{Parker2011} en een jaar later werd in oktober versie~1.2 uitgebracht~\cite{Parker2012}. 
Op het moment van schrijven zit \jqm{} aan versie~1.3.1~\cite{Parker2013b}. 
Het raamwerk wordt beheerd door het jQuery Project dat onder andere jQuery Core beheert en waar \jqm{} afhankelijk van is~\cite{JQuery2012}. 
\jqm{} wordt door onder andere Adobe, BlackBerry en Mozilla gesponsord~\cite{JQuery2012a}.

\subsection{Omkadering}
\paragraph{Programmeertaal}
Om met \jqm{} aan de slag te kunnen, is niets meer nodig dan kennis over HTML, CSS en JavaScript. 
Alle GI-elementen worden geschreven in HTML en aangeduid met \code{data-}* attributen.

\paragraph{Tools}
Een standaard teksteditor voldoet om met \jqm{} aan de slag te kunnen. 
Natuurlijk kan het gemakkelijk zijn om van \term{integrated development environments}~(IDE's) zoals Aptana Studio~\cite{Aptana2012} of WebStorm~\cite{JetBrains2012} gebruik te maken, waardoor handige kenmerken zoals automatische code-aanvulling beschikbaar zijn.

Het is ook mogelijk om gebruik te maken van Codiqua om de GI-elementen op het scherm te slepen en neer te zetten. 
Codiqua zal automatisch op de achtergrond de HTML-code voorzien~\cite{Sperry2012}.

\paragraph{Documentatie}
Documentatie is te vinden op \exturl{www.jquerymobile.com/demos/1.2.0} voor versie~1.2. 
Hierop is een catalogus te vinden van alle mogelijke elementen waarover \jqm{} beschikt. 
Door de broncode van een voorbeeld te bekijken, kan worden gekeken welke code moet worden geschreven om tot dat resultaat te komen.

Naast de GI-elementen is er ook documentatie over de API. 
Deze gaat over initiële configuraties, \term{events} en methodes die kunnen worden gebruikt.

\paragraph{Marktadoptatie}
Op de website van \jqm{} wordt een reeks applicaties getoond die gemaakt zijn met hun raamwerk. 
Enkele voorbeelden zijn webapplicaties voor Ikea, Disney World, Stanford University en Moulin Rouge~\cite{JQuery2012a}. 

\paragraph{Licenties}
Sinds september 2012 is het enkel nog mogelijk om \jqm{} onder de Massachusetts Institute of Technology (MIT) licentie te verkrijgen~\cite{Dmethvin2012}. 
Dit betekent dat de code wordt vrijgegeven als \term{open-source} en dat deze tegelijkertijd kan worden gebruikt in propriëtaire projecten en applicaties~\cite{PhilDutson2012}.

\subsection{Code en ontwikkeling}
Zoals werd aangehaald, wordt voornamelijk HTML5-code geschreven voorzien van \code{data-}* attributen. 
Daarna zal het raamwerk door middel van \term{progressive enhancement} allerhande code toevoegen om de beoogde GI-elementen correct te tonen in de browser. 
Dit wordt verder uitgelegd in de sectie browserondersteuning (zie \ref{sec:jqm-browser-support}).

Er zijn drie strategieën om webapplicaties te maken in \jqm{}~\cite{Broulik2012}. 
Een eerste is om de volledige applicatie in één webpagina te schrijven. 
De vele schermen van de webapplicatie zijn dan allemaal samengebracht op eenzelfde webpagina. 
Het voordeel bij deze aanpak is dat er initieel minder verzoeken zijn naar de server omdat alles in één bestand wordt opgehaald. 
Dit geldt ook zo voor de geïmporteerde CSS- en JavaScript-bestanden. 

Een tweede strategie is om voor ieder scherm een aparte webpagina aan te maken. 
Het voordeel hierbij is dat de eerste pagina waar de gebruiker op terecht komt, sneller wordt gedownload. 
Bij iedere navigatie naar een ander scherm, moet dit scherm via AJAX worden opgehaald, waardoor dit vertragend kan werken. 

Een laatste strategie is om een mix tussen beide te maken. 
Men kan bijvoorbeeld alle schermen die de gebruiker vaak nodig heeft op één webpagina plaatsen. 
De schermen die de gebruiker zelden nodig heeft, worden op aparte webpagina's geplaatst.   

\subsection{Functionele kenmerken}
\jqm{} is een raamwerk dat voornamelijk GI-elementen aanbiedt, met name pagina's en dialoogvensters, werkbalken, knoppen, inhoud vormgeven, elementen voor formulieren en lijsten~\cite{JQuery2012b}.
Deze kenmerken zijn gebaseerd op versie~1.2.

\paragraph{Pagina's en dialoogvensters}
De basisstructuur van een pagina bestaat uit een koptekst, inhoud en voettekst. 
Bij het overgaan naar een andere pagina wordt gekozezn uit tien overgangseffecten. 
Voordat deze overgang gebeurt, zal \jqm{} altijd eerst die pagina ophalen via AJAX en inladen in het DOM. 
Zo kan een soepel overgangseffect worden getoond aan de gebruiker. 
Daarnaast is het ook mogelijk om gelinkte pagina's op voorhand op te halen. 
Als laatste biedt \jqm{} ook dialoogvensters en pop-ups aan. 

\paragraph{Werkbalken}
Het is mogelijk om zowel knoppen bij de koptekst als bij de voettekst te plaatsen. 
Bij deze laatste kunnen typisch meer knoppen geplaatst worden, bij de koptekst slechts twee. 
Daarnaast is het ook mogelijk om navigatiebalken te maken. 
Aan zowel de werk- als navigatiebalken kunnen iconen worden toegevoegd.

\paragraph{Knoppen}
Het is ook mogelijk om knoppen te plaatsen in het inhoud gedeelde. 
Ook hier is er terug een variëteit aan mogelijkheden: grote of kleine, met iconen of zonder, gegroepeerd of niet. 

\paragraph{Inhoud vormgeven}
De inhoud van de pagina kan worden vormgegeven door gebruik te maken van een rooster. 
\jqm{} laat roosters tot vijf kolommen toe. 
Daarnaast zijn er ook nog opklapbare blokken ter beschikking. 
Als laatste kunnen deze blokken ook samengevoegd worden tot een accordeon. 

\paragraph{Elementen voor formulieren}
\jqm{} biedt alle gangbare elementen voor formulieren aan zoals tekstinvoer, een selectie uit een lijst, een zoekveld, een \term{slider} en een \term{switch}. 
Het raamwerk verplicht zelfs om de \code{<label>}-tag te gebruiken. 
Zo wordt de applicatie toegankelijker gemaakt voor bijvoorbeeld mensen met een \term{e-reader}.

\paragraph{Lijsten}
Een laatste categorie GI-elementen die \jqm{} aanbiedt, zijn lijsten. 
Deze gaan van standaard ongeordende lijsten tot lijsten met alle soorten decoraties als iconen, afbeeldingen, telbubbels en verdelers. 
Ook is het mogelijk om in deze lijsten te zoeken. 
Hiervoor dient de gebruiker enkel één data attribuut toe te voegen, waarna het raamwerk de implementatie voorziet. 

\subsection{Niet-functionele kenmerken}
\paragraph{Performantie}
Zoals gezegd schrijft de ontwikkelaar HTML5-code met specifieke data attributen en zal het raamwerk daarna de code verder aanvullen. 
Dit gebeurt enkel op de pagina die de gebruiker op dat moment bekijkt. 
Dit gaat dus ook op voor een webapplicatie waarbij alle schermen op één webpagina zijn geschreven. 
Deze webpagina bevat allemaal \code{<div>}-verpakkingen voor ieder scherm. 
\jqm{} zal enkel die \code{<div>} verder aanvullen die op dat moment getoond wordt aan de gebruiker. 

\paragraph{Aanpasbaarheid}
Als \jqm{} \term{out-of-the-box} wordt gebruikt, zit alles al goed qua kleur en design. 
Er is keuze uit vijf kleurenthema's die kunnen worden toegepast op de gehele applicatie of enkel op bepaalde elementen. 
Om een applicatie echt te laten onderscheiden van de andere, is een eigen kleurthema noodzakelijk. 
Hier is \jqm{} op voorzien door hun \term{stylesheet} op te delen in twee delen: thema's en structuur. 
Een ontwikkelaar kan ook enkel de structuur downloaden en zelf het thema in CSS schrijven. 
Doordat dit laatste heel wat inspanning vraagt, hebben de ontwikkelaars van \jqm{} ook een tool ter beschikking gesteld, namelijk ThemeRoller~\cite{JQuery2012c}. 
Hiermee worden de kleuren naar een voorbeeldapplicatie gesleept, waarna de overeenkomstige \term{stylesheet} kan worden gedownload.

\paragraph{Programmeerbaarheid}
Bij het programmeren in \jqm{} wordt geen enkel ontwerppatroon afgedwongen. 
De code voor de GI-elementen wordt tenslotte als HTML5-code geschreven. 
Voor de echte functionaliteit wordt beroep gedaan op JavaScript en meer bepaald op de jQuery Core bibliotheek. 
Ook deze dwingt geen ontwerppatroon af.

\paragraph{Browserondersteuning}
\label{sec:jqm-browser-support}

% TODO Tim: verser uitwerken browser support

\jqm{} deelt browsers op in drie verschillende klassen: A, B en C~\cite{JQuery2012d}. 
Hierbij ondersteunt een klasse A browser alles, terwijl een klasse C browser enkel de basis HTML ondersteunt (en dus bijvoorbeeld geen hippe CCS3 overgangen).
\jqm{} maakt gebruikt van \emph{progressive enhancement} (zie \ref{par:progressive-enhancement}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\st}
\label{sec:raamwerk-st}

% TODO Tim: Ik zou die eerste zin weglaten
\st{} is een relatief verschillend raamwerk in vergelijking met \jqm{}.  
Het wordt ontwikkeld door Sencha,  een bedrijf dat in 2010 is ontstaan als een samensmelting van Ext JS,  jQuery Touch en Raphaël.  
Ext JS is een JavaScript raamwerk voor de ontwikkeling van webapplicaties. 
jQuery Touch is een jQuery plug-in voor mobiele webontwikkeling.  
Het steunt op WebKit en voegt \term{touch events} toe aan jQuery.  
Raphaël,  ten slotte,  is een JavaScript bibliotheek voor vectortekeningen. 
Op het moment van schrijven is \st{} aan versie 2.1.1~\cite{Inc.}.  

\subsection{Omkadering}
\paragraph{Programmeertaal}
\st{} is JavaScript gedreven, dus alle functionaliteit wordt in JavaScript geïmplementeerd. 
%TODO Tim: Ik weet niet of dit nodig is. Misschien meer algemener voor ieder raamwerk, want includen moet je bij ieder raamwerk doen dacht ik?
Het aanroepen van het raamwerk gebeurt door het invoeren van de \st{} bibliotheek binnen \code{<script>}-elementen.  
Alle HTML-code wordt bij het bekijken van de pagina gegenereerd.  

\paragraph{Tools}
Naast \st{} levert Sencha nog producten die \st{} uitbreiden of het leven van de ontwikkelaar makkelijker maken.  
Deze worden hieronder opgelijst~\cite{Inc.}.  

\subparagraph{Sencha Animator}
Dit is een desktopapplicatie om CSS3-animaties te ontwerpen.  
Deze animaties worden enkel in WebKit browsers ondersteund.

\subparagraph{Sencha Architect}
Dit is een andere desktopapplicatie voor de ontwikkeling van een GUI met behulp van \term{drag-and-drop} commando's.  

\subparagraph{Sencha GXT}
Sencha GXT is een uitbreiding op Google Web Toolkit (GWT).  
De compiler van GWT laat toe applicaties in Java te schrijven en ze te compileren naar geoptimaliseerde,  \term{cross-browser} HTML5 en JavaScript.  
Sencha GXT voegt grafieken,  \term{widgets}, etc. toe aan GWT.

\subparagraph{Sencha.IO}
Deze uitbreiding zorgt voor \term{cloud services} binnen mobiele applicaties.  

\paragraph{Documentatie}
Alle documentatie voor \st{}~2.1.1 is te vinden op \exturl{docs.sencha.com/touch/2-0}.  
Een zoekfunctie voor objecten,  eigenschappen en methoden is aanwezig om snel zaken op te zoeken.  
De meeste functionaliteiten zijn voorzien van codevoorbeelden samen met het resultaat hoe de browser de code rendert.  
Verder biedt de Sencha website ook een groot aanbod om Sencha te leren gebruiken \exturl{www.sencha.com/learn/touch/}.  
Hier staan handleidingen,  introductie video etc..

%Door de snelle ontwikkeling van Sencha blijft de documentatie niet altijd up-to-date.  Zo zijn vele methoden verouderd maar staat er geen alternatief vermeld. 
%TODO dit is misschien eerer subjectief?
%TODO Tim: raadslagwerk? wij zijn de enige op google die deze term gebruiken. bedoelde je raadplegen of naslagwerk?
Een ander handig raadslagwerk is de Kitchen Sink~\cite{Inc.2013}.  
Dit is een webapplicatie,  geschreven in \st{},  die de belangrijkste functionaliteiten bevat samen met de bijhorende code.  

\paragraph{Marktadoptatie}
Volgens de Sencha website is 50\% van de Fortune~100 - een lijst van de grootste Amerikaanse bedrijven gerangschikt op jaaromzet - een Sencha klant~\cite{Inc.}.  
Enkele van hun grootste klanten zijn CNN,  Samsung,  Cisco en  Visa.

\paragraph{Licenties}
\st{} is gratis binnen een commerciële context waarbij het bedrijf in kwestie de broncode niet deelt voor zijn gebruikers.  
De gratis \term{open-source} versie van \st{} laat dit wel toe.  
Deze komt met een GNU GPL v3 \term{open-source} licentie wat wil zeggen dat de vrijheid bestaat om aanpassingen aan de broncode te maken en te verspreiden,  zolang de code maar gratis verspreid wordt voor alle gebruikers.
  
Voor de ontwikkeling van eigen raamwerken of SDKs wordt een \term{original equipment manufacturer} (OEM) licentie voorzien.  
Dit wil zeggen dat bedrijven hun producten gaan verkopen onder hun eigen merk en naam, maar gebruik maken van Sencha.  
Omdat het gebruik hiervan per gebruiker verschilt,  worden OEM-licenties op maat gemaakt~\cite{Inc.}.

\subsection{Code en ontwikkeling}
%TODO Tim: … reeds vermeld… … dus… da klinkt alsof we het verveeld vinden om het nog eens te vermelden precies
Zoals reeds vermeld moet alle code in JavaScript worden geschreven en dient één HTML-bestand slechts als container om de bestanden in te laden.  
Sencha valt dus onder JavaScript gebaseerde raamwerken.  
De keuze voor deze aanpak heeft twee belangrijke motivaties.  
Enerzijds is \st{} gebouwd op Ext JS,  wat op zich een JavaScript raamwerk is.  
Anderzijds zorgt het voor een betere ondersteuning voor toestellen met verschillende resoluties.  
Samen met SASS en Compass kan Sencha lay-outs definiëren per apparaat (zie sectie \ref{sec:sencha-aanpasbaarheid}).  
De \code{Ext.env.Browser} en \code{Ext.env.OS} eigenschappen en \code{Ext.Viewport.getOrientation} en \code{Ext.feature.has} methoden kunnen de vereisten bepalen en de juiste lay-out kiezen~\cite{JohnEClark2012}.

Om het de ontwikkelaars makkelijker te maken biedt Sencha ook SDK tools aan.  
Momenteel bevinden deze zich nog in bèta.  
Concreet zijn deze tools commando's voor de terminal die onder andere nieuwe projecten kunnen aanmaken, JavaScript bestanden kunnen optimaliseren maar vooral de webapplicatie kunnen omzetten naar native applicaties voor iOS en Android.

\paragraph{Debugging}
Het debuggen van code gebeurt voornamelijk in de browser zelf.  
Tools als de Safari Web Inspector,  Chrome Developer Tools of Firebug moeten de fouten kunnen opsporen.  
De broncode van \st{} kan ook ingeladen worden met \code{sencha-touch-debug.js} als bibliotheek.  
Deze versie is niet gecomprimeerd en bevat commentaar en documentatie om makkelijker te zoeken waar in de code de fout zich juist bevond.

\subsection{Functionele kenmerken}
Net zoals \jqm{} heeft \st{} ook een hele hoop functionaliteiten om eenvoudig GI-elementen te genereren.  
\st{} bevat alle elementen van de GI als JavaScript objecten.  
Net zoals alle objectgerichte programmeertalen maken deze objecten gebruik van een klassensysteem,  iets wat slechts vanaf \st{} 2 werd ingevoerd.  
Op die manier kunnen klassen worden gedefinieerd (\code{Ext.define}) en aangemaakt (\code{Ext.create}).  
Hierbij is ook overerving mogelijk.  
De basisklasse van alle objecten is \code{Ext.Component}.  
Componenten kunnen gerenderd worden, zichzelf tonen of verbergen,  centreren op het scherm en zichzelf aan- of uitzetten.   
Het aanmaken van componenten kan compacter door het gewenste component als \code{xtype} te definiëren.  

Een andere belangrijke component is \code{Ext.Container}.  
Containers kunnen subcomponenten bevatten en een lay-out specificeren.  
Alle componenten krijgen een naam die verwijst naar een \term{namespace}.  
Dit is handig om conflicten te vermijden tussen eigen objecten en standaard objecten van het raamwerk.  

Voor een opsomming van alle componenten verwijzen we naar de documentatie~\cite{Inc.2013a}.

%jQuery subsecties:
%Pagina's en dialoogvensters
%werkbalken
%knoppen
%inhoud vormgeven
%elementen voor formulieren
%lijsten

\paragraph{Model}
Data kan intern worden voorgesteld met \term{models}.  
Dit is iets wat hoort bij het MVC patroon (zie sectie \ref{sec:sencha-programeerbaarheid}).  
Een model specificeert een lijst van velden die bij het model horen waarbij een veld een naam en een type heeft.  
Optioneel kunnen validaties bij de velden worden toegevoegd om data consistent te houden.  

\paragraph{Store}
\code{Ext.data.Store} is de klasse om instanties van een model op te slaan.  
Een \term{store} wordt voorzien van een \term{proxy}.  
Deze kan data aan de client of server zijde opslaan.  
Een \term{proxy} voor opslag aan client zijde kan zowel in het RAM geheugen als in de \term{local storage} van de browser opslaan.  
Een \term{proxy} voor server opslag kan data verzenden via AJAX (zelfde domein) of JSONP (verschillende domeinen).  
Een \term{proxy} kan ook nog voorzien worden van een \term{reader} die aangeeft hoe de ontvangen data gelezen moet worden.

\paragraph{View}
Een \term{view} is de benaming voor objecten die aan de gebruiker kunnen worden getoond.  
Een voorbeeld hiervan zijn lijsten,  waar vaak de data van een \term{store} wordt in weergegeven.  
Zo'n lijst kan makkelijk gefilterd of gesorteerd worden op basis van velden uit het model.  
Hiervoor moeten \term{filters} of \term{sorters} aan de \term{store} worden toegevoegd. 
De lay-out van één lijstitem bepalen kan via een \code{XTemplate}.  
Het sjabloon bepaalt de HTML-structuur van elk item.  
Alle gedefinieerde velden van het model kunnen in de template worden opgeroepen of gemanipuleerd.

%TODO controllers?

\subsection{Niet-functionele kenmerken}
\paragraph{Performantie}
In vergelijking met versie~1.1 van \st{} is de performantie gestegen om wille van verschillende factoren.  
De introductie van het klasse systeem,  zoals besproken in de vorige sectie,  laat toe objecten dynamisch te laden. 
Het grote verschil tussen \code{Ext.define} en \code{Ext.create} is dat objecten enkel in het geheugen worden geladen na creatie.  
Het is dus de taak van de programmeur om objecten enkel te construeren wanneer ze nodig zijn.

Verder kwam versie~2.0 met een nieuwe lay-out \term{engine} die vooral het verwisselen van oriëntatie van het toestel versnelde.  
Ook een verbetering in performantie op Android toestellen,  voornamelijk bij scrollen en animaties,  werd ingevoerd~\cite{Inc.}.

Een benchmark voor deze verbeteringen zijn de opstarttijden van de Kitchen Sink applicatie.  
Het opstarten gebeurde met de verschillende \st{} versies en op verschillende toestellen.  
De resultaten zijn terug te vinden op figuur \ref{fig:sencha_performance}.  
Op bijna elk toestel blijkt \st{}~2.0 ongeveer één seconde sneller te werken~\cite{SenchaInc.2013}.

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{figuren/sencha-touch-startup-times.png}
  \caption{\st{} Kitchen Sink opstarttijden~\cite{SenchaInc.2013}.}
  \label{fig:sencha_performance}
\end{figure}

\paragraph{Aanpasbaarheid}
\label{sec:sencha-aanpasbaarheid}
Elke component binnen het raamwerk moet overerven van \code{Ext.Component}.  
Deze voorziet een attribuut \code{ui}.  
De waarde hiervan is een CSS-klasse die bepaald hoe de component er zal uitzien.  
Sencha heeft al twee CSS-klassen voorzien:  \code{light} en \code{dark}.  
Andere componenten kunnen deze lijst uitbreiden.  
Een knop kan bijvoorbeeld \code{normal},  \code{back},  \code{round},  \code{small},  \code{action} of \code{forward} als \code{ui} waarde hebben.

Het is ook mogelijk om eigen waarden voor \code{ui} te definiëren of de standaarden van Sencha aan te passen.  
SASS en Compass maken dit mogelijk door eigen CSS-bestanden aan te maken.  
SASS staat voor Syntactically Awesome Stylesheets en breidt CSS uit met variabelen,  geneste structuren, \term{mixins} en overerving~\cite{Eppstein2013}.  
\term{Mixins} groeperen enkele CSS-eigenschappen en kunnen worden hergebruikt.  
Compass is een raamwerk bovenop SASS en CSS.  
Het compileert SCSS (Sassy CSS) naar CSS-bestanden~\cite{Eppstein2013a}.        

Sencha thema's bestaan allemaal uit een set van \term{mixins}.  
Door zelf \term{mixins} te creëren of reeds bestaande te manipuleren kunnen eigen thema's gecreëerd worden en ze aan de \code{ui}-waarde van een component toegekend worden.

\paragraph{Programmeerbaarheid}
\label{sec:sencha-programeerbaarheid}
Zoals reeds aangehaald ondersteund \st{} het MVC-patroon.  
Dit patroon vermijdt lange JavaScript bestanden door ze logisch op te delen.  
Modellen groeperen velden tot een beschrijving van data-objecten, views definiëren de weergave van componenten en controllers verbinden beide op basis van \term{events}.

In theorie zou het verschil tussen mobiele websites en applicaties enkel in de \code{views} terug te vinden zijn.  
Echter,  dit wordt nog niet volledig ondersteund en worden aparte projecten voor deze functionaliteit gepromoot.

\paragraph{Ondersteuning browser}
\st{} steunt op de WebKit browser \term{engine} dus moet de browser deze bevatten.  
Hoewel dit bij de meeste browsers geen probleem meer vormt, vallen toch enkele populaire browsers uit de boot.  
\st{} is bijvoorbeeld niet compatibel met FireFox Mobile en Opera Mobile~\cite{JohnEClark2012}.

Zoals reeds vermeld zijn er ook methoden voorzien om informatie op te vragen over de context die gehanteerd wordt (browser, OS, toestel, etc.).  
Verder kan \st{} ook vragen naar de ondersteuning van specifieke kenmerken (audio,  canvas,  CSS3, ...),  analoog als Modernizr.  

Op de Senplug-incha website zijn voor sommige browsers en bijhorend besturingssystemen scorecards voorzien om hun compatibiliteit met HTLM5 en \st{} te bespreken~\cite{Inc.}.


\section{\kendo}
\label{sec:raamwerk-kendo}
\kendo{} is een HTML5 raamwerk van de hand van Telerik.
Het bestaat uit drie luiken:  Web, Mobile en DataViz.  
\kendo{} Web eerste is gericht op de ontwikkeling van desktop en mobiele applicaties,  het tweede voegt een \term{native look-and-feel} toe aan mobiele applicaties en het laatste zorgt voor data visualisatie met HTML5 en JavaScript technologie.
\kendo{} is een JavaScript gedreven raamwerk met een MVVM-architectuur dat steunt op de jQuery bibliotheek.
Verder heeft de ontwikkelaar ook de mogelijkheid om eenvoudig de \term{backend} in integreren aan de klantzijde.
.NET,  PHP en JSP zij momenteel de ondersteunde \term{server side wrappers}.
Op het moment van schrijven is \kendo{} aan versie 2013 Q1~\cite{Telerik}. 

\subsection{Omkadering}
\label{sec:kendo-omkadering}

\paragraph{Programmeertaal}
\kendo{} kan zowel als JavaScript- en opmaakgedreven beschouwd worden.  
Het HTML-element dat moet omgevormd worden tot \kendo{} object moet in een HTML-bestand worden gedeclareerd en voorzien worden van een id.
Vervolgens kunnen data attributen in HTML-code het element associeren met \kendo{} of kan het overeenkomstige jQuery object in JavaScript het raamwerk oproepen.
Alle UI-elementen van \kendo{} Mobile kunnen met data-attributen worden opgebouwd.
Het is niet mogelijk elk UI-element in JavaScript te creëeren.
%TODO anders formuleren Het gebruik van widgets van \kendo{} Web vereist wel dat ze met JavaScript worden opgebouwd.

Het laden van het raamwerk kan door heel \kendo{} op te roepen of enkel \kendo{} Mobile met respectievelijk \code{kendo.all.js} en \code{kendo.mobile.js}.
Elk van de drie luiken - Web, Mobile en DataViz - kan op zichzelf functioneren door hun JavaScript-bestand in te laden.
Er kan wel slecht één van de drie script tegelijk gebruikt woren.  
Wanneer elementen uit verschillende luiken gebruikt worden, moet \code{kendo.all.js} worden gebruikt.
Een alternatieve oplossing is de keuze van het script van één luik en alle benodigede JavaScript-bestanden te genereren met de JavaScript Builder op \url{http://www.kendoui.com/custom-download.aspx}.
Hier kunnen de vereiste elemeten geselecteerd worden en wordt het vereiste script gegenereerd.
Op een analoge wijze als de JavaScript-bestanden, kan de programmeur kiezen tussen verschillende \term{stylesheets}:  \code{kendo.all.css} en \code{kendo.mobile.css}.

\paragraph{Tools}
Op de \kendo{} website staan drie webtools vermeld die Telerik aanbiedt om de programmeur te ondersteunen.
De eerste is \kendo{} Dojo~\cite{Telerika},  een interactieve leeromgeving om met \kendo{} vertrouwd te raken.
De gebruiker kan de basis van \kendo{} leren kennen met geleide handleidingen met en uitvoerbare voorbeelden.
De twee andere webapplicaties zijn tools om op een grafische manier CSS-bestanden te genereren voor zowel de mobiele als web applicaties.~\cite{Telerikb,Telerikc}.
Voor \kendo{} Mobile kan een verschillende layout bepaalt worden voor alle ondersteunde besturingssystemen.

\paragraph{Documentatie}
Alle documentatie kan gevonden worden op \url{http://docs.kendoui.com}~\cite{Telerikd}.
Twee belangrijke secties binnen de documentatie zijn de API en \term{Getting Started}.
Beide kunnen op elkaar gemapt worden omdat alle objecten van \kendo{} die in de API worden aangehaald ook in een pagina onder \term{Getting Started} worden besproken.
Deze laatste probeert met meer woorden en voorbeelden uit te leggen wat het object juist inhoudt.
Verder staan er bij de documentatie nog handleidingen die complexere functionaliteit uit de doeken doet.
Ook zijn er demo's die live voorbeelden tonen samen met de code die nodig is om het voorbeeld te maken.

\paragraph{Marktadoptatie}
Enkele van de populairste klanten van \kendo{} zijn Nikon,  Fujifilm en Symantec.

\paragraph{Licenties}
Een licentie voor \kendo{} Complete kost $\$699$ per ontwikkelaar.
Voor \term{backend} ondersteuning in PHP,  JSP of ASP.NET MVC moet $\$300$ meer betaald worden.
Hierbij zijn één jaar updates mogelijk en wordt professionele ondersteuning aangeboden met een responsetijd onder 48 uur.
Bij een licentie met \term{server side wrappers} is support zelfs gegarandeerd na 24 uur.
%TODO apart aankpen van web, mobile en dataviz

\subsection{Code en ontwikkeling}
%javascript en markup driven
%single page of multiple page (analoog jqm)
Zoals reeds vermeld moet de programmeur zowel JavaScript als HTML-code schrijven. 
De JavaScript en CSS-bestanden van het raamwerk moeten in projectfolder worden gekopieerd respectievelijk in een \term{js} en \term{styles} map.
\kendo{} steunt op de jQuery bibliotheek en deze moet ingeladen worden voor het \kendo{} raamwerk zelf wordt aangeroepen.
De initializatie van een applicatie moet via \code{var app = new kendo.mobile.Application()}.
Hier kunnen parameters meegegeven worden die bijvoorbeeld de stijl van één platform vastlegd voor alle toestellen of het initiële bepalen.

Net zoals bij \jqm{} zijn er drie strategieën om webapplicaties te maken:  volledige applicatie in één webpagina,  elk scherm in een aparte pagina of een combinatie van beide.
De navigatie naar een scherm gebeurt op basis van de id van dat scherm.
Standaard navigeert \kendo{} naar het eerste gedefinieerde scherm van een webpagina.
Een ander scherm kan in dezelfde pagina of in een ander bestand staan.
Een lokale navigatie wordt herkend door een \term{hashtag} die voor de id van het scherm wordt geplaatst als parameter van de \code{navigate}-methode.
Navigatie naar een ander bestand kan door de bestandsnaam als parameter op te geven.

\subsection{Functionele kenmerken}
\label{sec:kendo-functioneel}
%TODO klassensysteem
\kendo{} is zowel opmaak- als JavaScript-gedreven en steunt op de MVVM-architectuur.
Hierin ligt de kracht van het raamwerk,  het beïnvloedt dan ook sterk alle functionele kenmerken.

\paragraph{UI-elementen}
Formulieren volgen de sterk de HTML5 norm. 
Deze elementen zijn wel enkel functioneel op iOS 5.x+ en Android 4.x+.  
Het stylen van alle elementen op andere platformen zal werken, maar is beperkt tot  enkel tekst invoer~\cite{Telerike}.

Het toevoegen van knoppen kan zowel met de \code{button}-tag als met standaard hyperlinks (\code{<a>}).
Knoppen kunnen ook samengevoegd worden tot een \code{ButtonGroup}.
Dit maakt het mogelijk om gemeenschappelijke acties aan een groep van knoppen toe te kennen om bijvoorbeeld een menuutje te maken.
Een \code{TabStrip} is een alternatief waar tabs in de voettekst het scherm kunnen variëren.

\paragraph{View}
Schermen worden voorsteld met \code{views},  analoog als bij de MVC-architectuur (zie super).
Een \code{view} aanduiden gebeurt door het attribuut \code{data-role} aan \code{view}  gelijk te stellen.
\code{Views} kunnen met een \code{layout} worden voorzien met de \code{data-layout}-tag.
Een \code{layout} bepaalt de vormgeving van een \code{view} en kan hergebruikt worden.

Een \code{listview} is een specifieke \code{view} voor lijsten.
De \code{data-template} kan bij lijsten de id van een sjabloon bevatten die de opmaak van de lijstelementen definieerd.
Deze sjablonen zijn specifieke \kendo{} scriptjes die HTML-tags en JavaScript-code kunnen bevatten.
Ook kunnen ze verwijzen naar attributen van het model dat aan de lijst is toegekend (zie infra).

Twee andere instanties van \code{views} zijn \code{Splitview} en \code{Scrollview}.
De eerste kan het scherm in twee \code{views} splitsen,  vaak gebruikt bij tablet applicaties.
De tweede is definieert een verzameling van pagina's die met een swipe bewegingen gelinkt zijn.

\paragraph{View-Model}
Het \code{View-Model} behoort tot de kern van \kendo{} en wordt \code{ObservableObject} genoemd.
Dit is een JavaScript object dat kan gebonden worden aan abonnees.
Het ondersteunt het monitoren van wijzigingen en verwittigd elke abonnee wanneer een wijziging zich voordoet.
Een \code{ObservableObject} kan aan een \code{view} worden toegekend door het in de \code{data-model}-tag te vermelden.

Er zijn verschillende bindingen	 mogelijk tussen een \code{view} en \code{ObservableObject} en wordt aangegeven in de \code{data-bind}-tag.
\kendo{} ondersteunt een binding met volgende eigenschappen:  \code{attr,  checked, clicked, custom, disabled, enabled, events, html, invisible, source, style, text, value} en \code{visible}.
Als een gebonden eigenschap wijzigt - door gebruikersinvoer of programmatisch - zal het overeenkomstige veld in het \code{ObservableObject} ook wijzigen.


\paragraph{Model}
Het \code{Model} object erft over van \code{ObservableObject} en breidt het uit met de mogelijkheid om schema's,  velden en methoden te definiëren.  
Velden kunnen van het type \code{string, number, boolean} en \code{date} zijn.
Ook kunnen de velden verder beschreven worden door bijvoorbeeld een standaard waarde of validatie toe te voegen.
Een schema is een eigenschap van een \code{DataSource},  een \kendo{} object voor de opslag van lokale of externe data.  
Een \code{DataSource} ondersteunt alle CRUD (\term{Create, Read, Update en Delete}) operaties en het sorteren, pagineren, filteren, groeperen en aggregeren van data.
Het schema attribuut legt de structuur van de data in de \code{DataSource} vast.
Bij externe databronnen bepaalt het hoe binnenkomende data geparset moet worden om aan de opgelegde structuur te voldoen.
Een \code{Model} kan de waarde van een schema zijn.
Dit wil zeggen dat de bijhorende \code{DataSource} instanties zal bevatten van het toegekende \code{Model}.

\subsection{Niet-functionele kenmerken}
\label{sec:kendo-niet-functioneel}

\paragraph{Performantie}
De performantie van een \kendo{} applicatie wordt deels bepaald door de programmeur.
Deze moet er voor zorgen dat de data op het juiste moment geladen wordt.
Bij het weergeven van een \code{View} gaan drie gebeurtenissen vooraf,  respectievelijk \code{beforeShow,  init} en \code{show}.
De eerste wordt uitgevoerd voor een \code{View} zichtbaar wordt,  de tweede na initializatie en de laatste bij het tonen van een \code{View}.
Het initializeren van een \code{View} vindt maar één keer plaats nadat de volledige applicatie geladen is.
Bij de ontwikkeling van een \code{listView} met data van een externe databron kan best de \code{DataSource} geladen worden bij het initializeren van de applicatie,  de lijst gemaakt worden na de \code{init}-gebeurtenis van de \code{View} van de lijst en de lijst ververst worden wanneer deze getoond wordt (\code{show} gebeurtenis).


\paragraph{Aanpasbaarheid}
%native look-and-feel
%Customize mobile themes & widgets
\kendo{} probeert de \term{native look-and-feel} van verschillende besturingssystemen na te bootsen.
Op het moment van schrijven ondersteunt het iOS, Android, BlackBerry en WinPhone8.

Het \kendo{} pakket bevat ook tien extra thema's die een alternatieve layout bepalen.
Deze zijn elk nog persoonlijk aan te passen met de Mobile ThemeBuilder zoals beschreven in de sectie \ref{sec:kendo-omkadering}.

\paragraph{Programeerbaarheid}
%MVVM, jQuery core
\kendo{} is zowel JavaScipt- als opmaakgedreven.
Een kennis van zowel HTML als JavaScript is vereist om met dit raamwerk aan de slag te kunnen.
Het raamwerk is gebouwd op de jQuery Core en moeten vaak jQuery \term{selectors} gebruikt worden.
Ook kan een AJAX verzoek met jQuery syntax geformuleerd worden om externe data op te halen voor een \code{DataSource}.

\paragraph{Browserondersteuning}
%WinPhone8, iOS, Android, BlackBerry and beyond
Zoals reeds gezegd herkent \kendo{} het platform waarop de applicatie wordt uitgevoerd.
De layout van de applicatie zal de \term{native look-and-feel} van het besturingssysteem vervolgens nabootsen.
Ondersteunde systemen zijn iOS, Android, BlackBerry en WinPhone8.

Alle widgets zoals gebruikt in het raamwerk ondersteunen \term{progressive enhancement}.
Oudere browsers kunnen zo bestaande inhoud en functionaliteit raadplegen met \term{native} HTML types indien bepaalde elementen niet worden ondersteund.
Ook de HTML5 formulierelementen worden opgebouwd met \term{progressive enhancement}.

\section{\lungo}
\label{sec:raamwerk-lungo}

\subsection{Omkadering}
\subsection{Code en ontwikkeling}
\subsection{Functionele kenmerken}
\subsection{Niet-functionele kenmerken}

\section{Tabel}
\label{sec:raamwerken-tabel}
