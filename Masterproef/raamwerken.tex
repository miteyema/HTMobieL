\chapter{Mobiele HTML5-raamwerken}
\label{chap:raamwerken}

Dit hoofdstuk vergelijkt op een passieve manier de vier gekozen mobiele HTML5-raamwerken, namelijk \st{}, \kendo{}, \jqm{} en \lungo{}.
Dit is een vergelijking gebaseerd op informatie van de raamwerken die in de literatuur kon worden gevonden.
Omkadering, code en ontwikkeling, functionele kenmerken en niet-functionele kenmerken zullen voor ieder raamwerk worden besproken.

Het tijdsbudget liet toe om vier van de acht gepresteerde raamwerken (zie sectie \ref{sec:mobiele-html5-raamwerken}) te vergelijken.
In samenspraak met Capgemini werd gekozen om \jqm{}, \st{} en \kendo{} te onderzoeken.
De twee eerstgenoemde werden gekozen om hun enorme populariteit in de literatuur~\cite{Firtman2013,Hales2012,Oeflman2011,David2011}.
Bij interviews met een ontwikkelaar, architect en verkoopmanager van Capgemini kwamen ook deze twee raamwerken naar boven.
\kendo{} heeft het voordeel dat het de \term{native look-and-feel} kan nabootsen, wat ook een handig onderzoekspunt leek voor Capgemini.
Doordat \tmp{} een volledige make-over ondergaat in de zomer van 2013 leek het de auteurs niet nuttig om de huidige versie te onderzoeken.
\moobile{} werd ook uitgesloten door de nog zeer jonge versie van het raamwerk tijdens het onderzoek.
\jqt{} is slechts een plug-in voor \jqm{} en \st{} is hierop verder gebouwd.
Hierdoor werd niet voor \jqt{} gekozen.
Als laatste werd besloten om \davinci{} uit te sluiten door de gebrekkige Engelstalige documentatie van dit Koreaans raamwerk.
Het vierde en laatste onderzochte raamwerk werd daarom \lungo{}.

Zoals besproken in \ref{sec:mobiele-html5-raamwerken} kunnen raamwerken worden gecategoriseerd volgens twee aanpakken, namelijk opmaakgedreven en \js{}-gedreven~\cite{Oeflman2011}. 
Bij een opmaakgedreven aanpak zijn er drie strategieën om webapplicaties te maken~\cite{Broulik2012}. 
Een eerste is om de volledige applicatie in één webpagina te schrijven. 
De vele schermen van de webapplicatie zijn dan allemaal samengebracht op eenzelfde webpagina. 
Het voordeel bij deze aanpak is dat er initieel minder verzoeken zijn naar de server omdat alles in één bestand wordt opgehaald. 
Dit geldt ook zo voor de geïmporteerde CSS- en \js{}-bestanden. 
Een tweede strategie is om voor ieder scherm een aparte webpagina aan te maken. 
Het voordeel hierbij is dat de eerste pagina waar de gebruiker op terecht komt, sneller wordt gedownload. 
Bij iedere navigatie naar een ander scherm, moet dit scherm via Asynchronous \js{} and XML~(AJAX) worden opgehaald, waardoor dit vertragend kan werken. 
Een laatste strategie is om een mix tussen beide te maken. 
Men kan bijvoorbeeld alle schermen die de gebruiker vaak nodig heeft op één webpagina plaatsen. 
De schermen die de gebruiker zelden nodig heeft, worden op aparte webpagina's geplaatst.   


Eerst wordt gestart met het bespreken van een volledig \js{}-gedreven raamwerk, namelijk \st{}~(\ref{sec:raamwerk-st}).
Daarna volgt \kendo{}~(\ref{sec:raamwerk-kendo}) dat zowel \js{}- als opmaakgedreven is.
De laatste twee besproken raamwerken, \jqm{}~(\ref{sec:raamwerk-jqm}) en \lungo{}~(\ref{sec:raamwerk-lungo}), zijn beide opmaakgedreven.
In de laatste sectie (\ref{sec:raamwerken-tabel}) wordt een overzicht van deze passieve vergelijking weergegeven.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\st}
\label{sec:raamwerk-st}
\st{}~(\sta{}) wordt ontwikkeld door Sencha.
Dit bedrijf is in 2010 ontstaan als een samensmelting van Ext JS, jQuery Touch en Raphaël. 
Ext~JS is een \js{}-raamwerk voor de ontwikkeling van webapplicaties. 
jQuery Touch is een jQuery plug-in voor mobiele webontwikkeling.  
Het steunt op WebKit en voegt \term{touch events} toe aan jQuery.  
Raphaël,  ten slotte,  is een \js{}-bibliotheek voor vectortekeningen. 
Op het moment van schrijven is \st{} aan versie 2.2~\cite{Inc.}.  
De eerste stabiele versie werd in november 2010 voorgesteld.

\subsection{Omkadering}
\paragraph{Programmeertaal}
\st{} is \js{}-gedreven, dus alle functionaliteit wordt in \js{} geïmplementeerd. 
Alle HTML-code wordt bij het bekijken van de pagina gegenereerd.  

\paragraph{Tools}
Naast \st{} levert Sencha nog producten die het ontwikkelingsproces versnellen.
Deze worden hieronder opgelijst~\cite{Inc.}.  

\subparagraph{Sencha Architect}
Dit is een desktopapplicatie die het ontwikkelingsproces vergemakkelijkt met een GGI en \term{drag-and-drop}~\cite{Sencha2012a}.  
De applicatie kan worden gedownload voor Mac, Windows en Linux distributies.
Sencha Architect kan voor 30 dagen uitgeprobeerd worden,  daarna moet een licentie worden aangekocht.
De prijs voor één ontwikkelaar bedraagt $\$399$~\cite{Inc.}.

\subparagraph{Sencha Cmd}
Deze tool vergemakkelijkt de ontwikkeling van \st{} applicaties door middel van commando's die vanuit een \term{command-line interface} kunnen worden uitgevoerd~\cite{Sencha2012}.
Sencha Cmd is beschikbaar voor Mac, Windows en Linux distributies.
Het kan initiële applicaties opzetten,  bestanden toevoegen en de applicatie bouwen en uitrollen.
De applicatie kan ook omgevormd worden tot een \term{native} applicatie voor iOS en Android.
De tool is gratis op de Sencha website te downloaden~\cite{Inc.}.
Een applicatie,  zoals geïnitialiseerd door Sencha Cmd,  moet alle benodigde \js-, en CSS-bestanden in een JSON-bestand onderbrengen.
Een \code{microloader} zal de afhankelijke bestanden automatisch laden bij het opstarten van de applicatie.

Het bouwen en uitrollen van een applicatie kan op vier niveaus:
\begin{description}
  \item [\code{testing}] maakt een testapplicatie om de kwaliteit te testen.  \js- en CSS-bestanden worden samengevoegd maar niet verkleind om makkelijk te debuggen.
  \item [\code{package}] maakt een zelfstandige applicatie die verspreidbaar is en vanop een bestandensyteem,  zonder webserver,  kan lopen.
  \item [\code{production}] maakt een applicatie die op een webserver beschikbaar wordt gemaakt waarvan de \js- en CSS-bestanden zijn samengevoegd en verkleind.  Het maakt de applicatie ook offline beschikbaar door gebruik te maken van de Applicatie Cache van HTML5.  Ook is het mogelijk de applicatie op te waarderen naar een nieuwe versie via het Delta Update mechanisme. Dit mechanisme wil voorkomen dat bij een kleine aanpassing in de code, alle bestanden opnieuw moeten worden gedownload.
  \item [\code{native}] maakt een \term{native} applicatie die op het Android- of iOS-besturingssysteem kan lopen.
\end{description}

\subparagraph{Sencha Animator}
Dit is een desktopapplicatie om CSS3-animaties te ontwerpen~\cite{Sencha2012b}.  
De applicatie kan worden gedownload voor Mac, Windows en Linux distributies.
Deze animaties worden enkel in WebKit-browsers ondersteund.
De prijs voor één ontwikkelaar bedraagt $\$99$~\cite{Inc.}.

\paragraph{Documentatie}
%Alle documentatie voor \st{}~2.1.1 is te vinden op \exturl{docs.sencha.com/touch/2-0}.  
Een zoekfunctie voor objecten,  eigenschappen en methoden is in de documentatie aanwezig om snel zaken op te zoeken.  
De meeste functionaliteiten zijn voorzien van codevoorbeelden samen met het resultaat hoe de browser de code rendert.  
Alle plug-ins die Sencha aanbiedt, kunnen op de Sencha Market teruggevonden worden~\cite{Sencha2013}.
Verder biedt de Sencha website ook hulpmiddelen om \st{} te leren gebruiken zoals handleidingen, introductievideos, enz.

Een ander handig naslagwerk is de Kitchen Sink~\cite{Inc.2013}.  
Dit is een webapplicatie,  geschreven in \st{},  die de belangrijkste functionaliteiten bevat samen met de bijhorende code. 

\paragraph{Marktadoptatie}
Volgens de Sencha website is 50\% van de Fortune~100 - een lijst van de grootste Amerikaanse bedrijven gerangschikt op jaaromzet - een Sencha-klant~\cite{Inc.}.  
Enkele van hun grootste klanten zijn CNN,  Samsung,  Cisco en  Visa.

\paragraph{Licenties}
\st{} biedt een commerciële licentie waarbij het bedrijf in kwestie de broncode niet deelt voor zijn gebruikers.  
Ook een \term{open-source} licentie van \st{} bestaat.
Beide licenties zijn gratis.
De \term{open-source} licentie is voor applicaties die zelf een GNU~GPLv3 opleggen.
Dit wil zeggen dat de vrijheid bestaat om aanpassingen aan de broncode te maken en te verspreiden,  zolang de code ook maar gratis verspreid wordt voor alle gebruikers.
  
Voor de ontwikkeling van eigen raamwerken of SDKs wordt een \term{original equipment manufacturer} (OEM) licentie voorzien.  
Dit wil zeggen dat bedrijven hun producten gaan verkopen onder hun eigen merk en naam, maar gebruik maken van \st.  
Omdat het gebruik hiervan per gebruiker verschilt,  worden OEM-licenties op maat gemaakt~\cite{Inc.}.
Deze OEM-licentie is niet gratis.

\subsection{Code en ontwikkeling}
Alle code moet in \js{} worden geschreven.
Eén HTML-bestand dient slechts als container om de bestanden in te laden.  
\st{} valt dus onder \js{}-gebaseerde raamwerken net zoals Ext JS,  waarop \st{} is verdergebouwd.

Samen met SASS (Syntactically Awesome Stylesheets) en Compass kan \st{} lay-outs definiëren per apparaat.
SASS breidt CSS uit met variabelen,  geneste structuren, \term{mixins} en overerving~\cite{Eppstein2013}.    
De \code{Ext.env.Browser} en \code{Ext.env.OS}-eigenschappen en \code{Ext.Viewport.getOrientation}- en \code{Ext.feature.has}-methoden kunnen de context opvragen en de juiste lay-out kiezen~\cite{JohnEClark2012}.

%Zoals besproken biedt Sencha de terminal tool Sencha Cmd aan om het de ontwikkelingsproces te vergemakkelijken.  

\paragraph{Debugging}
De broncode van \st{} kan ingeladen worden met een uitgebreide bibliotheek.  
Deze versie is niet gecomprimeerd en bevat commentaar en documentatie om makkelijker uit te zoeken welke fout werd gemaakt.

\subsection{Functionele kenmerken}
%Net \st{} heeft functionaliteiten om eenvoudig GI-elementen te genereren.  
\st{} bevat alle elementen van de GI als \js{}-objecten.  
Net zoals alle objectgerichte programmeertalen maken deze objecten gebruik van een klassensysteem,  iets wat slechts vanaf \st{} 2 werd ingevoerd.  
Op die manier kunnen klassen worden gedefinieerd (\code{Ext.define}) en aangemaakt (\code{Ext.create}).  
Hierbij is ook overerving mogelijk.  
De basisklasse van alle objecten is \code{Ext.Component}.  
Componenten kunnen worden gerenderd, zichzelf tonen of verbergen,  centreren op het scherm en zichzelf aan- of uitzetten.   
Het aanmaken van componenten kan ook door de component als \code{xtype} te definiëren.  
Andere componenten kunnen deze \code{xtype} dan hergebruiken.

Een andere belangrijke component is \code{Ext.Container}.  
Containers kunnen subcomponenten bevatten en een lay-out specificeren.  
Alle componenten krijgen een naam die verwijst naar een \term{namespace}.  
Dit is handig om conflicten te vermijden tussen eigen objecten en standaard objecten van het raamwerk.  
Voor een opsomming van alle componenten wordt verwezen naar de documentatie~\cite{Inc.2013a}.

\paragraph{Model}
Data kan intern worden voorgesteld met \code{Models}.  
Dit is iets wat hoort bij het MVC-ontwerppatroon (zie sectie \ref{sec:sencha-programmeerbaarheid}).  
Een model specificeert een lijst van velden waarbij een veld een naam en een type heeft.  
Optioneel kunnen validaties bij de velden worden toegevoegd om validatieregels op de velden af te dwingen.  

\paragraph{Store}
\code{Ext.data.Store} is de klasse om instanties van een model op te slaan.  
Een \code{Store} wordt voorzien van een \code{Proxy}.  
Deze kan data aan de klant- of serverzijde opslaan.  
Een \code{Proxy} voor opslag aan klantzijde kan zowel in het RAM-geheugen als in lokale opslag van de browser opslaan.  
Een \code{Proxy} voor serveropslag kan data verzenden naar hetzelfde domein via AJAX of tussen verschillende domeinen via JSONP.  
JSONP staat voor JavaScript Object Notation with Padding en is een methode om data op een server in een ander domein op te vragen.
Een \code{Proxy} kan ook nog voorzien worden van een \code{Reader} of \code{Writer} die aangeeft hoe de ontvangen data gelezen of geschreven moet worden.

\paragraph{View}
\code{Views} zijn objecten die aan de gebruiker kunnen worden getoond.  
Een voorbeeld hiervan zijn lijsten,  waar instanties van een \code{Store} kunnen worden weergegeven.  
Zo een lijst kan gefilterd of gesorteerd worden op basis van velden uit het model.
Hiervoor moeten \code{Filters} of \code{Sorters} aan de \code{Store} worden toegevoegd. 
De lay-out van één lijstitem bepalen kan via een \code{XTemplate}.  
Het sjabloon bepaalt de HTML-structuur van elk item.  
Alle gedefinieerde velden van het model kunnen in het sjabloon worden opgeroepen of gemanipuleerd.

\paragraph{Controllers} 
De \code{Controllers} maken de binding tussen \code{Models} en \code{Views}.
Ze kunnen gebeurtenissen opvangen en bijhorende operaties uitvoeren.
Hierdoor is navigatie door de applicatie mogelijk en kunnen alle componenten gemanipuleerd worden.
\code{Controllers} worden ook gebruikt bij de initialisatie van de applicatie.

\subsection{Niet-functionele kenmerken}
\paragraph{Performantie}
In vergelijking met versie~1.1 van \st{} is de performantie gestegen omwille van verschillende factoren.  
De introductie van het klassensysteem,  zoals besproken in de vorige sectie,  laat toe objecten dynamisch te laden. 
Het grote verschil tussen \code{Ext.define} en \code{Ext.create} is dat objecten enkel in het geheugen worden geladen na creatie.  
Het is dus de taak van de programmeur om objecten enkel te construeren wanneer ze nodig zijn.

Verder kwam versie~2.0 met een nieuwe lay-out \term{engine} die vooral het verwisselen van oriëntatie van het toestel versnelde.  
Ook een verbetering in performantie op Android-toestellen,  voornamelijk bij scrollen en animaties,  werd ingevoerd~\cite{Inc.}.

\paragraph{Aanpasbaarheid}
\label{sec:sencha-aanpasbaarheid}
Elke component binnen het raamwerk moet overerven van \code{Ext.Component}, dat een \code{ui}-attribuut voorziet.  
De waarde hiervan is een CSS-klasse die bepaald hoe de component er zal uitzien.  
\st{} heeft al twee CSS-klassen voorzien:  \code{light} en \code{dark}.  
Andere componenten kunnen deze lijst uitbreiden.  
Een knop kan bijvoorbeeld \code{normal},  \code{back},  \code{round},  \code{small},  \code{action} of \code{forward} als \code{ui}-waarde hebben.

Het is ook mogelijk om eigen waarden voor \code{ui} te definiëren of de standaarden van \st{} aan te passen.  
SASS en Compass maken dit mogelijk door eigen CSS-bestanden aan te maken.  
\term{Mixins} groeperen enkele CSS-eigenschappen en kunnen worden hergebruikt.  
Compass is een raamwerk bovenop SASS en CSS.  
Het compileert SCSS (Sassy CSS) naar CSS-bestanden~\cite{Eppstein2013a}.        

Thema's van \st{} bestaan allemaal uit een set van \term{mixins}.  
Door zelf \term{mixins} te creëren of reeds bestaande te manipuleren kunnen eigen thema's gecreëerd worden en ze aan de \code{ui}-waarde van een component toegekend worden.

\paragraph{Programmeerbaarheid}
\label{sec:sencha-programmeerbaarheid}
Zoals reeds aangehaald ondersteunt \st{} het MVC-ontwerppatroon.  
Dit ontwerppatroon vermijdt lange \js{}-bestanden door ze logisch op te delen.  
Modellen groeperen velden tot een beschrijving van data-objecten, \code{Views} definiëren de weergave van componenten en \code{Controllers} verbinden beide op basis van gebeurtenissen.

In theorie zou het verschil tussen mobiele websites en applicaties enkel in de \code{Views} terug te vinden zijn.  
Echter,  dit wordt nog niet volledig ondersteund en daarom worden aparte projecten voor deze functionaliteit gepromoot.

\paragraph{Ondersteuning browser}
\st{} steunt op de WebKit-browser \term{engine} dus moet de browser deze bevatten.  
Hoewel dit bij de meeste browsers geen probleem meer vormt, vallen toch enkele populaire browsers uit de boot.  
\st{} is bijvoorbeeld niet compatibel met bijvoorbeeld Internet Explorer Mobile.

% Zoals reeds vermeld zijn er ook methoden voorzien om informatie op te vragen over de context die gehanteerd wordt (browser, besturingssysteem, toestel, etc.).  
% Verder kan \st{} ook vragen naar de ondersteuning van specifieke kenmerken (audio,  \code{canvas},  CSS3, ...)  analoog als Modernizr~\cite{Modernizr2012}.  

Op de website van Sencha zijn voor de belangrijkste browsers en besturingssystemen \term{scorecards} voorzien om hun compatibiliteit met HTLM5 en \st{} te bespreken~\cite{Inc.}.
Hoewel geen echte scores worden uitgedeeld, zijn alle belangrijkste kenmerken uitgelicht en uitvoerig besproken. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\kendo}
\label{sec:raamwerk-kendo}
\kendo{}~(\kendoa{}) is een raamwerk van het Duitse Telerik en in november 2011 gelanceerd.
Het vergemakkelijkt de ontwikkeling van webapplicaties en bestaat uit drie luiken.
\kendo{} Web is gericht op de ontwikkeling van desktop- en mobiele applicaties,  \kendo{} Mobile voegt een \term{native look-and-feel} toe aan mobiele applicaties en \kendo{} DataViz zorgt voor datavisualisatie met HTML5- en \js{}-technologie.
\kendo{} is zowel een \js{}- als opmaakgedreven raamwerk en heeft een Model-View-View Model (MVVM) ontwerppatroon dat steunt op de jQuery-bibliotheek.
Het raamwerk biedt \term{widgets} aan voor meer geavanceerde functionaliteit, die onderliggend een plug-in in jQuery voorstellen.
Verder heeft de ontwikkelaar ook de mogelijkheid om de \term{backend} te integreren met de klantzijde.
ASP.NET MVC,  PHP en JSP zijn momenteel de ondersteunde technologieën voor \term{backend} integratie.
Op het moment van schrijven is \kendo{} aan versie 2013 Q2~\cite{Telerike}. 

\subsection{Omkadering}
\label{sec:kendo-omkadering}

\paragraph{Programmeertaal}
\kendo{} is zowel \js{}- en opmaakgedreven. 
Data-attributen kunnen een HTML-element associëren met \kendo{}.
Ook kan een jQuery-selector in \js{} met \kendo{} worden gebonden.
Alle GI-elementen van \kendo{} Mobile kunnen met data-attributen worden opgebouwd.
\term{Widgets} van \kendo{} Web kunnen zowel met \js{} als data-attributen geïnitialiseerd worden.

Het laden van het raamwerk kan door \kendo{} in zijn geheel op te roepen of enkel \kendo{} Mobile met respectievelijk \code{kendo.all.js} of \code{kendo.mobile.js}.
Elk van de drie luiken - Web, Mobile en DataViz - kan op zichzelf functioneren door hun \js{}-bestand in te laden.
Er kan wel slecht één van de drie scripts gelijktijdig gebruikt worden.  
Wanneer elementen uit verschillende luiken gebruikt worden, moet \code{kendo.all.js} worden gebruikt.
Een alternatieve oplossing is het inladen van één luik en een \js{}-bestand met de benodigde componenten.
Dit bestand is te genereren met de \js{} Download Builder die te vinden is op de \kendo{} website~\cite{Telerike}.
Hier kunnen de vereiste elementen geselecteerd worden en wordt het \js{}-bestand gegenereerd.
Op een analoge wijze kan de programmeur kiezen tussen verschillende CSS-bestanden:  \code{kendo.all.css} en \code{kendo.mobile.css}.

\paragraph{Tools}
Op de \kendo{} website staan drie webapplicaties vermeld die Telerik aanbiedt om de programmeur te ondersteunen.
De eerste is \kendo{} Dojo~\cite{Telerika},  een interactieve leeromgeving om met \kendo{} vertrouwd te raken.
De gebruiker kan de basis van \kendo{} leren kennen met geleide handleidingen en uitvoerbare voorbeelden.
De twee andere webapplicaties zijn een ThemeBuilder voor Web en Mobile die op een grafische manier CSS-bestanden kunnen genereren~\cite{Telerikb,Telerikc}.
Voor \kendo{} Mobile kan een verschillende lay-out bepaald worden voor alle ondersteunde platformen.

\paragraph{Documentatie}
Twee belangrijke secties van de documentatie zijn de API en Getting Started~\cite{Telerikd}.
Beide kunnen op elkaar gemapt worden omdat alle objecten van \kendo{} die in de API worden aangehaald ook in een pagina onder Getting Started worden besproken.
Deze laatste probeert met meer woorden en voorbeelden uit te leggen wat het object juist inhoudt.
Verder staan er bij de documentatie nog handleidingen die complexere functionaliteit uit de doeken doen.
Ook zijn er demo's die live voorbeelden tonen samen met de code die nodig is om het voorbeeld te maken.

\paragraph{Marktadoptatie}
Enkele van de populairste klanten van \kendo{} zijn Nikon,  Fujifilm en Symantec~\cite{Telerike}.

\paragraph{Licenties}
Een licentie voor \kendo{} Complete kost $\$699$ per ontwikkelaar.
Voor \term{backend} ondersteuning in PHP,  JSP of ASP.NET MVC moet $\$300$ meer betaald worden.
Hierbij zijn één jaar updates mogelijk en wordt professionele ondersteuning aangeboden met een responsetijd onder de 48 uur.
Een licentie met \term{backend} integratie garandeert professionele ondersteuning binnen de 24 uur.
Voor \kendo{} Web,  Mobile en DataViz bestaan ook aparte licenties voor respectievelijk $\$399$,  $\$199$ en $\$399$~\cite{Telerike}.

\subsection{Code en ontwikkeling}
%Zoals reeds vermeld moet de programmeur zowel \js{}- als HTML-code schrijven. 
%De \js{}- en CSS-bestanden van het raamwerk moeten in de projectfolder worden gekopieerd respectievelijk in een \term{js}- en \term{styles}-map.
\kendo{} steunt op de jQuery-bibliotheek en deze moet ingeladen worden voor het \kendo{} raamwerk zelf wordt aangeroepen.
De initialisatie van een applicatie moet onderaan in de HTML-pagina gebeuren.	
Hier kunnen parameters meegegeven worden die bijvoorbeeld de stijl van één platform vastleggen of het initiële scherm bepalen.

De navigatie naar een scherm gebeurt op basis van de \term{identifier} van dat scherm.
Standaard navigeert \kendo{} naar het eerst gedefinieerde scherm in de pagina.
Een ander scherm kan in diezelfde pagina of in een ander bestand staan.
Een lokale navigatie wordt herkend door een \term{hashtag} die voor de \term{identifier} van het scherm wordt geplaatst als parameter van de \code{navigate}-methode.
Navigatie naar een ander bestand kan door de bestandsnaam als parameter op te geven.

\subsection{Functionele kenmerken}
\label{sec:kendo-functioneel}
\kendo{} steunt op het MVVM-ontwerppatroon,  wat de functionele kenmerken sterk beïnvloedt.
Alle objecten maken deel uit van een klassensysteem.

\paragraph{UI-elementen}
Formulieren volgen de HTML5-norm. 
Deze elementen zijn wel enkel functioneel vanaf iOS~5 en Android~4.  
De stijl van de elementen op andere platformen zal werken, maar is beperkt tot enkel tekstinvoer~\cite{Telerike}.

Het toevoegen van knoppen kan zowel met de \code{button}-tag als met standaard hyperlinks.
Knoppen kunnen ook samengevoegd worden tot een \code{ButtonGroup}.
Dit maakt het mogelijk om gemeenschappelijke acties aan een groep van knoppen toe te kennen om bijvoorbeeld een menu te maken.
Een \code{TabStrip} is een alternatief waar tabs in de voettekst het scherm kunnen laten variëren.

\paragraph{View}
Analoog als het MVC-ontwerppatroon,  worden schermen voorgesteld met \code{Views}.
Een \code{View} aanduiden gebeurt door het attribuut \code{data-role} aan \code{view} gelijk te stellen.
\code{Views} kunnen met een lay-out worden voorzien met de \code{data-layout}-tag.
Een \code{Layout} bepaalt de vormgeving van een \code{View} en kan hergebruikt worden.

Een \code{ListView} is een specifieke \code{View} voor lijsten.
De \code{data-template} kan bij lijsten de \term{identifier} van een sjabloon bevatten die de opmaak van de lijstelementen definieert.
Deze sjablonen zijn specifieke \kendo{}-scripts die HTML-tags en \js{}-code kunnen bevatten.
Ook kunnen ze verwijzen naar velden van het model dat aan de lijst is toegekend (zie infra).

Twee andere instanties van \code{Views} zijn \code{SplitView} en \code{ScrollView}.
De eerste kan het scherm in twee \code{Views} splitsen,  vaak gebruikt bij applicaties op de tablet.
De tweede definieert een verzameling van pagina's die met \term{swipe} bewegingen gelinkt zijn.

\paragraph{View Model}
Het View Model behoort tot de kern van \kendo{} en wordt \code{ObservableObject} genoemd.
Dit is een \js{}-object dat kan gebonden worden aan abonnees.
Het ondersteunt het monitoren van wijzigingen en verwittigt elke abonnee wanneer een wijziging zich voordoet.
Een \code{ObservableObject} kan aan een \code{View} worden toegekend door het in de \code{data-model}-tag te vermelden.

Er zijn verschillende bindingen	 mogelijk tussen een \code{View} en \code{ObservableObject}.
Deze wordt aangegeven in de \code{data-bind}-tag.
%\kendo{} ondersteunt een binding met volgende eigenschappen:  
%\begin{itemize}
%  \item \code{attr}
%  \item \code{checked}
%  \item \code{clicked}
%  \item \code{custom}
%  \item \code{disabled}
%  \item \code{enabled}
%  \item \code{events}
%  \item \code{html}
%  \item \code{invisible}
%  \item \code{source}
%  \item \code{style}
%  \item \code{text}
%  \item \code{value}
%  \item \code{visible}
%\end{itemize}
Als een gebonden eigenschap wijzigt - door gebruikersinvoer of programmatisch - zal het overeenkomstige veld in het \code{ObservableObject} ook wijzigen.

\paragraph{Model}
Het \code{Model} erft over van \code{ObservableObject} en breidt het uit met de mogelijkheid om schema's,  velden en methoden te definiëren.  
Velden kunnen van het type \code{string, number, boolean} of \code{date} zijn.
Ook kunnen de velden verder beschreven worden door bijvoorbeeld een standaard waarde of validatie toe te voegen.
De \code{DataSource} is een \kendo{}-object voor de opslag van lokale of externe data.  
Deze ondersteunt alle CRUD (\term{Create, Read, Update en Delete}) operaties en het sorteren, pagineren, filteren, groeperen en aggregeren van data.
Het \code{schema}-attribuut legt de structuur van de data in de \code{DataSource} vast.
Bij externe databronnen bepaalt het hoe binnenkomende data geparset moet worden om aan een opgelegde structuur te voldoen.
Een \code{schema} kan van een \code{Model} worden voorzien of zelf een \code{Model} beschrijven.
In het eerste geval zullen de waarde van het toegekende \code{Model} na CRUD-operaties worden aangepast.
In het andere geval zal de \code{DataSource} instanties van het beschreven \code{Model} bevatten en manipuleren.

\subsection{Niet-functionele kenmerken}
\label{sec:kendo-niet-functioneel}

\paragraph{Performantie}
De performantie van een \kendo{}-applicatie wordt deels bepaald door de programmeur.
Deze moet er voor zorgen dat de data op het juiste moment geladen wordt.
Bij het weergeven van een \code{View} gaan drie gebeurtenissen vooraf,  namelijk \code{beforeShow,  init} en \code{show}.
De eerste wordt uitgevoerd voor een \code{View} zichtbaar wordt,  de tweede na initialisatie en de laatste bij het tonen van een \code{View}.
Het initialiseren van een \code{View} vindt maar één keer plaats nadat de volledige applicatie geladen is.
Bij de ontwikkeling van een \code{ListView} met data van een externe databron kan  de \code{DataSource} geladen worden bij het initialiseren van de applicatie,  de lijst gemaakt worden bij de \code{init}-gebeurtenis en de lijst ververst worden bij een \code{show}-gebeurtenis.

\paragraph{Aanpasbaarheid}
\kendo{} probeert de \term{native look-and-feel} van verschillende besturingssystemen na te bootsen.
Het \kendo{}-pakket bevat ook tien extra thema's die een alternatieve lay-out bepalen.
Deze zijn elk nog persoonlijk aan te passen met de Mobile ThemeBuilder zoals beschreven in de sectie \ref{sec:kendo-omkadering}.

\paragraph{Programmeerbaarheid}
Een kennis van zowel HTML als \js{} is vereist om met dit raamwerk aan de slag te kunnen.
Het raamwerk is gebouwd op de jQuery-bibliotheek en maakt dus vaak van jQuery-\term{selectors} gebruik.
Ook kan een AJAX-verzoek met jQuery-syntax geformuleerd worden om externe data voor een \code{DataSource} op te halen.

\paragraph{Browserondersteuning}
Ondersteunde systemen zijn iOS, Android, Windows Phone~8 en BlackBerry~OS.
Alle \term{widgets}, zoals gebruikt in het raamwerk, ondersteunen \term{progressive enhancement}.
Oudere browsers kunnen zo bestaande inhoud en functionaliteit raadplegen met \term{native} HTML-types indien bepaalde elementen niet worden ondersteund.
Ook de HTML5-formulierelementen worden opgebouwd met \term{progressive enhancement}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\jqm}
\label{sec:raamwerk-jqm}
\jqm{}~(\jqma{}) is een opmaakgedreven raamwerk dat hoofdzakelijk GI-elementen aanbiedt.
Het werd aangekondigd in 2010~\cite{Resig2010} en in november 2011 werd versie~1.0 uitgebracht~\cite{Parker2011}.
Een jaar later werd in oktober versie~1.2 uitgebracht~\cite{Parker2012} en op het moment van schrijven zit \jqm{} aan versie~1.3.1~\cite{Parker2013b}. 
Het raamwerk is afhankelijk van jQuery dat een \js{}-bibliotheek is.
Beide worden beheerd door het jQuery Project~\cite{JQuery2012}. 
\jqm{} wordt door onder andere Adobe, BlackBerry en Mozilla gesponsord~\cite{JQuery2012a}.

\subsection{Omkadering}
\paragraph{Programmeertaal}
Om met \jqm{} aan de slag te kunnen, is er kennis nodig over HTML, CSS en \js{}. 
Alle GI-elementen worden geschreven in HTML en aangeduid met data-attributen.
Functionele vereisten kunnen worden geschreven in \js{}.

\paragraph{Tools}
Codiqa~\cite{Sperry2012} is een tool om snel de GGI van de applicatie op te zetten.
Door \term{drag-and-drop} worden de GI-elementen op het scherm gezet.
Codiqua zal automatisch op de achtergrond de HTML- en CSS-code voorzien.
Daarnaast biedt \jqm{} ook ThemeRoller~\cite{JQuery2012c} aan om het standaard kleurenthema aan te passen. 
Hiermee worden kleuren naar een voorbeeldapplicatie gesleept, waarna het overeenkomstige CSS-bestand kan worden gedownload.

\paragraph{Documentatie}
Op de documentatiesite van versie~1.2~\cite{JQuery2012b} is een catalogus te vinden van alle mogelijke elementen waarover \jqm{} beschikt. 
Door de broncode van een voorbeeld te bekijken, kan de code worden geschreven om tot dat resultaat te komen.

Naast de GI-elementen is er ook documentatie over de API.
Deze gaat over gebeurtenissen en methoden die kunnen worden gebruikt en het configureren van standaardwaarden.

\paragraph{Marktadoptatie}
Op de website van \jqm{} wordt een reeks applicaties getoond die gemaakt zijn met hun raamwerk. 
Enkele voorbeelden zijn webapplicaties voor Ikea, Disney World, Stanford University en Moulin Rouge~\cite{JQuery2012a}. 

\paragraph{Licenties}
Sinds september 2012 is het enkel nog mogelijk om \jqm{} onder de MIT-licentie te verkrijgen~\cite{Dmethvin2012}. 
Dit betekent dat de code wordt vrijgegeven als \term{open-source} en dat deze tegelijkertijd kan worden gebruikt in propriëtaire projecten en applicaties~\cite{PhilDutson2012}.

\subsection{Code en ontwikkeling}
Zoals werd aangehaald, wordt voornamelijk HTML5-code geschreven voorzien van data-attributen. 
Daarna zal het raamwerk door middel van \term{progressive enhancement} allerhande code toevoegen om de beoogde GI-elementen correct te tonen in de browser. 
Dit wordt verder uitgelegd in de sectie browserondersteuning (zie \ref{sec:jqm-browser-support}).

\subsection{Functionele kenmerken}
\jqm{} is een raamwerk dat voornamelijk GI-elementen aanbiedt, met name pagina's en dialoogvensters, werkbalken, knoppen, inhoud vormgeven, elementen voor formulieren en lijsten~\cite{JQuery2012b}.
Deze kenmerken zijn gebaseerd op versie~1.2.

\begin{enumerate}
\item \textbf{Pagina's en dialoogvensters}
De basisstructuur van een pagina bestaat uit een koptekst, inhoud en voettekst. 
Bij het overgaan naar een andere pagina wordt gekozen uit tien overgangseffecten. 
Voordat deze overgang gebeurt, zal \jqm{} altijd eerst die pagina ophalen via AJAX en inladen in het DOM. 
Zo kan een soepel overgangseffect worden getoond aan de gebruiker. 
Daarnaast is het ook mogelijk om gelinkte pagina's op voorhand op te halen. 
Als laatste biedt \jqm{} ook dialoogvensters en pop-ups aan. 

\item \textbf{Werkbalken}
Het is mogelijk om zowel knoppen bij de koptekst als bij de voettekst te plaatsen. 
Bij deze laatste kunnen typisch meer knoppen geplaatst worden, bij de koptekst slechts twee. 
Daarnaast is het ook mogelijk om navigatiebalken te maken. 
Aan zowel de werk- als navigatiebalken kunnen iconen worden toegevoegd.

\item \textbf{Knoppen}
Het is mogelijk om knoppen te plaatsen op het scherm. 
Ook hier is er terug een variëteit aan mogelijkheden: grote of kleine, met iconen of zonder, gegroepeerd of niet. 

\item \textbf{Inhoud vormgeven}
De inhoud van de pagina kan worden vormgegeven door gebruik te maken van een rooster. 
\jqm{} laat roosters tot vijf kolommen toe. 
Daarnaast zijn er ook nog opklapbare blokken ter beschikking. 
Als laatste kunnen deze blokken ook samengevoegd worden tot een accordeon. 

\item \textbf{Elementen voor formulieren}
\jqm{} biedt elementen voor formulieren aan zoals tekstinvoer, een dropdownmenu, een zoekveld, een \term{slider} en een schakelaar. 
Het raamwerk verplicht om de \code{label}-tag te gebruiken. 
Zo wordt de applicatie toegankelijker gemaakt voor bijvoorbeeld mensen met een schermlezer.

\item \textbf{Lijsten}
Een laatste categorie GI-elementen die \jqm{} aanbiedt, zijn lijsten. 
Deze gaan van standaard ongeordende lijsten tot lijsten met alle soorten decoraties als iconen, afbeeldingen, telbubbels en verdelers. 
Het is ook mogelijk om in deze lijsten te zoeken. 
Hiervoor dient de ontwikkelaar enkel één data-attribuut toe te voegen, waarna het raamwerk de implementatie voorziet. 
\end{enumerate}

\subsection{Niet-functionele kenmerken}
\paragraph{Performantie}
Zoals gezegd schrijft de ontwikkelaar HTML5-code met specifieke data-attributen en zal het raamwerk daarna de code verder aanvullen. 
Dit gebeurt enkel op de pagina die de gebruiker op dat moment bekijkt. 
Dit gaat dus ook op voor een webapplicatie waarbij alle schermen op één webpagina zijn geschreven. 
Deze webpagina bevat allemaal \code{div}-verpakkingen voor ieder scherm. 
\jqm{} zal enkel die \code{div} verder aanvullen die op dat moment getoond wordt aan de gebruiker. 

\paragraph{Aanpasbaarheid}
Er is keuze uit vijf kleurenthema's die kunnen worden toegepast op de gehele applicatie of enkel op bepaalde elementen. 
Een ontwikkelaar kan ook enkel de structuur downloaden en zelf het thema in CSS schrijven. 
Doordat dit laatste heel wat inspanning vraagt, kunnen ontwikkelaars hiervoor ThemeRoller~\cite{JQuery2012c} gebruiken. 

\paragraph{Programmeerbaarheid}
Bij het programmeren in \jqm{} wordt geen ontwerppatroon afgedwongen. 
De code voor de GI-elementen wordt tenslotte als HTML5-code geschreven.
Voor de echte functionaliteit wordt beroep gedaan op \js{} en meer bepaald op de jQuery-bibliotheek. 
Ook deze dwingt geen ontwerppatroon af.

\paragraph{Browserondersteuning}
\label{sec:jqm-browser-support}

\jqm{} maakt gebruikt van \emph{progressive enhancement} (zie \ref{par:progressive-enhancement}).
Hierdoor wordt in principe ieder apparaat ondersteunt door het raamwerk, maar zal de applicatie op een ouder apparaat minder functionaliteit krijgen dan diezelfde applicatie op een nieuwer apparaat.
Om dit te verduidelijken deelt \jqm{} browsers op in drie verschillende klassen: A, B en C~\cite{JQuery2012d}. 
Hierbij krijgt een klasse~A browser de volledige ervaring met AJAX-gebaseerde paginaovergangen.
Bij een browser van klasse~B wordt geen AJAX ondersteund.
Als laatste wordt bij een klasse~C browser enkel een basiservaring aangeboden die nog steeds functioneel is.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\lungo}
\label{sec:raamwerk-lungo}
\lungo{}~(\lungoa{}) is een opmaakgedreven raamwerk onderhouden door TapQuo dat een Spaans bedrijf is gespecialiseerd in mobiele gebruikerservaring~\cite{TapQuo2013a}.
Het raamwerk biedt vooral GI-elementen aan en is afhankelijk van een \js{}-bibliotheek, namelijk \quo{}~\cite{TapQuo2013}.
Versie~1.0 kwam uit in 2011~\cite{TapQuo2011} en op het moment van schrijven zit \lungo{} aan versie~2.1~\cite{TapQuo2013}.
%daarnaast zijn er ook \term{wrappers} voor cache, opslag en SQL beschikbaar.
%Er wordt geen programmeerstijl zoals MVC afgedwongen.

\subsection{Omkadering}
\paragraph{Programmeertaal}
Er is kennis nodig van HTML, CSS en \js{}.
De GI-elementen worden geschreven in HTML en aangeduid aan de hand van zowel CSS-klassen en data-attributen.
Functionele vereisten kunnen worden geschreven in \js{}.

\paragraph{Tools}
Er worden geen specifieke tools door TapQuo aangeboden om de ontwikkeling te versnellen.
% Wel kan er gebruik worden gemaakt van Twitter Bower~\cite{Twitter2013} die helpt om de bestanden van het \lungo{}-raamwerk tezamen met de \quo{}-bibliotheek te beheren.
% Dit komt door de aanwezigheid van het bestand \code{component.json} op \gh{} dat Bower gebruikt.

\paragraph{Documentatie}
Op de documentatiesite~\cite{Lungo2013} wordt eerst getoond hoe het structuur van een \lungo{}-applicatie er uitziet.
Vervolgens zijn er nog acht andere pagina's die de aangeboden GI-elementen en API uitleggen.
Op de documentatiepagina's is altijd eerst de broncode te zien.
Er kan dan boven de broncode op een knop geklikt worden, waarna een live voorbeeld wordt getoond.

\paragraph{Marktadoptatie}
Doordat geen informatie te vinden is op de site van \lungo{} werd een e-mail gestuurd met de vraag welke bedrijven \lungo{} gebruiken of in welke projecten van TapQuo zelf \lungo{} werd gebruikt.
De auteurs hebben tot op het moment van schrijven geen antwoord ontvangen.

\paragraph{Licenties}
Het raamwerk wordt onder de GNU GPLv3-licentie vrijgegeven.
Daarnaast is een commerciële versie ook mogelijk~\cite{TapQuo2013d}.

\subsection{Code en ontwikkeling}
Zoals gezegd wordt een \lungo{}-applicatie geprogrammeerd vanuit geannoteerde HTML-code door middel van CSS-klassen en data-attributen.
Er wordt geen ontwerppatroon zoals MVC afgedwongen.

Om de verschillende schermen te scheiden wordt gebruik gemaakt van \code{article}- en \code{section}-tags die specifiek zijn voor HTML5.
Analoog worden ook voor de kop- en voettekst de \code{header}- en \code{footer}-tags gebruikt.

Enerzijds kan de volledige applicatie op één webpagina worden geprogrammeerd.
Daarnaast biedt \lungo{} ook de mogelijkheid om de verschillende schermen op afzonderlijke pagina's op te slaan.
Hierbij moet enkel de code binnen de \code{body}-tag worden opgeslagen.
Daarna wordt bij de initialisatie van \lungo{} gedefinieerd welke afzonderlijke pagina's asynchroon dienen te worden opgehaald.

\subsection{Functionele kenmerken}
De documentatiepagina~\cite{Lungo2013} is opgedeeld in negen groepen die hieronder kort worden aangehaald.

\begin{enumerate}

\item \textbf{Prototype} 
Hierop worden GI-elementen, navigatie, formulieren, scrollen, lijsten en data-attributen aangehaald.
Ook is er directe ondersteuning door het raamwerk voor Pull\&Refresh.
Dit is een lijst die de data automatisch herlaadt wanneer de lijst naar beneden wordt getrokken.

\item \textbf{Core }
Hier worden functies aangehaald die het raamwerk zelf intern gebruikt.
Een voorbeeld hiervan is de \code{Lungo.Core.isMobile}-functie die controleert of de applicatie in een mobiele omgeving wordt uitgevoerd.
Een ander voorbeeld is de aanwezigheid van een sorteer- en zoekfunctie voor rijen.

\item \textbf{Data }
Het raamwerk biedt \term{wrappers} voor cache, opslag en SQL.
De ontwikkelaar dient dus zelf geen \code{if-then-else}-constructies op te stellen of een bepaald kenmerk ondersteund wordt of niet, het raamwerk neemt dat voor zijn rekening.
Indien het apparaat het kenmerk niet ondersteunt, voorziet \lungo{} een \term{fallback}.

\item \textbf{DOM }
Het manipuleren van de DOM gebeurt door de \quo{}-bibliotheek.
Hiervoor wordt gerefereerd naar de documentatie van \quo{}~\cite{TapQuo2013c}.
Zelf biedt \lungo{} enkel ondersteuning voor gebeurtenissen bij het laden en ontladen van pagina's binnen de applicatie.

\item \textbf{Element }
Toevoegen van een telbubbel, vooruitgangsbalk, laadbalk, Pull\&Refresh en een fotocarousel zijn programmeerbaar en manipuleerbaar via de \lungo{} API vanuit \js{}. 

\item \textbf{Notification }
Er worden standaard verschillende dialoogvensters aangeboden voor fout-, succes- en infomeldingen.
Deze dialoogvensters zijn voorzien van een specifieke lay-out.
Zo zal een fout- en succesboodschap respectievelijk een rode en groene achtergrondkleur hebben.
Een ander type venster dat wordt aangeboden is een bevestigingsvenster waarbij een vraag wordt gesteld aan de gebruiker waar ja of nee op geantwoord wordt.
Het raamwerk voorziet voor beide acties de mogelijkheid om hier een eigen functie aan te koppelen.
 
\item \textbf{Routing }
Hier wordt ingegaan op de navigatie doorheen de applicatie vanuit \js{}.
Het is mogelijk om binnen eenzelfde artikel tussen verschillende secties te navigeren alsook van artikel te veranderen.
Daarnaast is het mogelijk om vanuit \js{} een zijnavigatie te tonen.
Deze navigatie wordt zichtbaar door links bovenaan te klikken.
Als laatste voorziet \lungo{} een terugkeerfunctionaliteit, vergelijkbaar met de functie \code{history.back} uit \js{}.

\item \textbf{Service }
Versturen van HTTP-verzoeken kan vanuit \lungo{} zelf.
Zowel HTTP GET als HTTP POST zijn mogelijk.
Het raamwerk kan omgaan met tekst, XML, JSON en HTML als antwoord.
Er is ook een verkorte notatie indien het antwoord JSON is.
Als laatste biedt \lungo{} ook de mogelijkheid om het antwoord van het HTTP-verzoek te cachen, waarbij de maximale tijd moet worden opgegeven.
Indien de oproep nog eens gebeurt en de maximale tijd niet verstreken is, zal \lungo{} geen HTTP-verzoek versturen, maar het opgeslagen antwoord gebruiken.

\item \textbf{View }
Hier worden \js{}-methoden aangeboden om het uitzicht binnen een \code{article} te bepalen.
Zo kan de titel worden aangepast of van sectie binnen het artikel worden veranderd.
Daarnaast wordt ook ingegaan op het tonen en verbergen van de zijnavigatie.
 
\end{enumerate}

\subsection{Niet-functionele kenmerken}
\paragraph{Performantie}
De \js{}-bibliotheek waarop \lungo{} steunt is geoptimaliseerd voor mobiel gebruik.
Hierdoor bevat het geen methoden voor desktopgebruikers, waardoor het bestand kleiner is dan traditionele \js{}-bibliotheken.

\paragraph{Aanpasbaarheid}
\label{sec:lungo-aanpasbaarheid}
TapQuo biedt zelf geen tools aan om de kleuren of het uitzicht van de applicatie te veranderen.
Hierdoor zal een ontwikkelaar zelf aangewezen zijn om eigen CSS-code te schrijven.

\paragraph{Programmeerbaarheid}
\label{sec:lungo-programmeerbaarheid}
\lungo{} dwingt geen enkel ontwerppatroon af.
Voor de echte functionaliteit wordt beroep gedaan op \js{}.
Daarbij is de ontwikkelaar vrij hoe hij te werk gaat en kan hij gebruik maken van de \lungo{} API. 
Voor aanpassingen die van toepassing zijn op DOM-manipulatie, is de ontwikkelaar aangewezen op \quo{}.
Ook deze dwingt geen ontwerppatroon af.

\paragraph{Ondersteuning browser}
TapQuo geeft aan op hun website dat ze ondersteuning bieden voor iOS, Android, Blackberry~OS en Firefox~OS.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overzicht}
\label{sec:raamwerken-tabel}

In tabel~\ref{tabel:raamwerken-tabel} wordt de passieve vergelijking van de raamwerken getoond.
In het volgende hoofdstuk worden de vijf actieve vergelijkingscriteria besproken.
De resultaten van de actieve vergelijking kunnen niet worden bekomen door enkel naar de literatuur te kijken, maar moeten actief onderzocht worden.
De resultaten hiervan zullen in hoofdstuk \ref{chap:evaluatie} besproken worden.

\begin{landscape}
\begin{table}
\centering
\pgfplotstabletypeset[
  begin table=\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{3.5cm} p{3.5cm}},
  end table=\end{tabular},
  col sep=comma,
  string type,
  header=true,
  skip coltypes=true,
  columns={Criterium,ST,Kendo,jQM,Lungo},
  columns/Criterium/.style={column name=\textbf{Criterium}},  
  columns/jQM/.style={column name=\textbf{\jqm}},
  columns/ST/.style={column name=\textbf{\st}},
  columns/Kendo/.style={column name=\textbf{\kendo}},
  columns/Lungo/.style={column name=\textbf{\lungo}},
  every head row/.style={
    before row=\toprule,
    after row=\midrule},
  every last row/.style={
    after row=\bottomrule}
]{tabellen/raamwerken.csv}
\caption{Passieve vergelijking.}
\label{tabel:raamwerken-tabel}
\end{table}
\end{landscape}
